<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vuex的使用入门-极简使用]]></title>
    <url>%2F2019%2F01%2F01%2FVuex-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8-%E6%9E%81%E7%AE%80%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[vuex 是为了解决复杂项目组件之间的数据通信的一个全局状态管理机制，相信很多人都听说过这个东西。有部分人还没有在项目中使用Vuex管理过数据状态，实际上Vuex的起步使用非常之简单，看完本文之后，赶紧在项目中用起来吧！ 1. 安装 Vuex 包1npm install vuex --save 2. 新建一个store.js文件:Vuex 必需的内容都在下面这个文件中，文件中做了详细的注释，注意其中的异步操作actions和同步操作mutations。 12345678910111213141516171819202122232425262728// store.js// 引入vue 和 vueximport Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex); // 使用vuex插件,跟router一样// 直接导出 一个 Store 的实例export default new Vuex.Store(&#123; // 这里是要读取或者写入数据的地方,跟组件里的data项一样 state: &#123; name: 'oldName' &#125;, // 通过actions的commit触发mutations来修改state的数据 // 这里可以包含任意的异步操作，只要最后 actions: &#123; // 第一个参数是用于触发mutations，第二个参数是使用的地方传过来的数据 nameAction(&#123; commit &#125;, data) &#123; // do something 可以是ajax、promise等异步操作 commit('updateName', data); &#125; &#125;, // 同步操作直接修改state里面的数据 mutations: &#123; // 第一个参数是上面的state数据,第二个参数是commit传过来的数据,用以修改state数据。 updateName(state, data) &#123; state.name = data; // 更改state里的数据 &#125; &#125;&#125;); 3. 引入到main.js入口文件中 - 最后一步这是最后一步了，做完这步，然后我们就可以在项目中使用Vuex了。 1234567891011// main.jsimport Vue from 'vue';import App from './App';import store from './store'; // 引入storenew Vue(&#123; el: '#app', store, // 挂载在Vue的配置项中 components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;); 在组件中使用 vuex：在组件中的使用如下，省略了template部分: 12345678910111213// 组件中&lt;script&gt;export default &#123; mounted()&#123; console.log('vuex的数据'，this.$store.state.name) &#125; methods:&#123; changeName () &#123; // commit只接受一个参数，数据多的话，就用对象传递 this.$store.dispatch('nameAction', '传过去的新名字') // 先触发actions，再由commit触发mutations来修改数据 &#125;&#125;&lt;/script&gt; 在 js 文件中使用 vuex:使用方式是一样的，只是调用的名字，稍微有些改变。 重复引用问题： 现在项目中基本使用的都是Webpack打包，所以我们不用担心重复引用的问题。 webpack会记忆你之前有没有引用过这个文件/包，整个项目只会引用一次。 1234// some.jsimport store from './store'; // 引入vuexconsole.log('vuex的数据', store.state.name);store.dispatch('nameAction', '传过去的新名字') 小结实际上使用 Vuex 只需要store.js文件,然后再把文件引到main.js入门文件中，挂在new Vue的配置项中即可使用。 如此之简单，快点来试试吧！ Vuex 文档:这是一个简单的示例，更多内容请阅读vuex 文档 鼓励我一下：觉得还不错的话，给我的项目点个star吧 博客、前端算法、公众号]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[var和let/const的区别]]></title>
    <url>%2F2019%2F01%2F01%2Fvar%E5%92%8Clet-const%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[let和const是 ES6 新增的命令，用于声明变量，这两个命令跟 ES5 的var有许多不同，并且let和const也有一些细微的不同，再认真阅读了阮一峰老师的文档后，发现还是有一些不知道的细节… 博客、前端积累文档、公众号、GitHub 内容：var和let/const的区别 块级作用域 不存在变量提升 暂时性死区 不可重复声明 let、const声明的全局变量不会挂在顶层对象下面 const命令两个注意点: const 声明之后必须马上赋值，否则会报错 const 简单类型一旦声明就不能再更改，复杂类型(数组、对象等)指针指向的地址不能更改，内部数据可以更改。 为什么需要块级作用域?ES5只有全局作用域和函数作用域，没有块级作用域。 这带来很多不合理的场景: 内层变量可能覆盖外层变量 用来计数的循环变量泄露为全局变量 1234567891011121314var tmp = new Date();function f() &#123; console.log(tmp); // 想打印外层的时间作用域 if (false) &#123; var tmp = 'hello world'; // 这里声明的作用域为整个函数 &#125;&#125;f(); // undefinedvar s = 'hello';for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]); // i应该为此次for循环使用的变量&#125;console.log(i); // 5 全局范围都可以读到 块级作用域 作用域 12345678function f1() &#123; let n = 5; if (true) &#123; let n = 10; console.log(n); // 10 内层的n &#125; console.log(n); // 5 当前层的n&#125; 块级作用域任意嵌套 1234&#123;&#123;&#123;&#123; &#123;let insane = 'Hello World'&#125; console.log(insane); // 报错 读不到子作用域的变量&#125;&#125;&#125;&#125;; 块级作用域真正使代码分割成块了 12345678&#123;let a = ...;...&#125;&#123;let a = ...;...&#125; 以上形式，可以用于测试一些想法，不用担心变量重名，也不用担心外界干扰 块级作用域声明函数： 在块级作用域声明函数，因为浏览器的要兼容老代码，会产生一些问题！ 在块级作用域声明函数，最好使用匿名函数的形式。 123if(true)&#123; let a = function () &#123;&#125;; // 作用域为块级 令声明的函数作用域范围更清晰&#125; ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。 1234// 报错'use strict';if (true) function f() &#123;&#125; // 我们需要给if加个&#123;&#125; 不存在变量提升变量提升的现象：在同一作用域下，变量可以在声明之前使用，值为 undefined ES5 时使用var声明变量，经常会出现变量提升的现象。 1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 暂时性死区：只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量 12345var tmp = 123; // 声明if (true) &#123; tmp = 'abc'; // 报错 因为本区域有tmp声明变量 let tmp; // 绑定if这个块级的作用域 不能出现tmp变量&#125; 暂时性死区和不能变量提升的意义在于: 为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。 不允许重复声明变量 在测试时出现这种情况:var a= &#39;声明&#39;;const a = &#39;不报错&#39;，这种情况是因为babel在转化的时候，做了一些处理，在浏览器的控制台中测试，就成功报错 let、const不允许在相同作用域内，重复声明同一个变量 123456789function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; let、const声明的全局变量不会挂在顶层对象下面 浏览器环境顶层对象是: window node环境顶层对象是: global var声明的全局变量会挂在顶层对象下面，而let、const不会挂在顶层对象下面。如下面这个栗子 1234567var a = 1;// 如果在 Node环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined const命令 一旦声明，必须马上赋值 123let p; var p1; // 不报错const p3 = '马上赋值'const p3; // 报错 没有赋值 const一旦声明值就不能改变 简单类型:不能改动 12const p = '不能改变';p = '报错' 复杂类型:变量指针不能变 考虑如下情况： 12345678910const p = ['不能改动']const p2 = &#123; name: 'OBKoro1'&#125;p[0] = '不报错'p2.name = '不报错'p = ['报错']p2 = &#123; name: '报错'&#125; const所说的一旦声明值就不能改变，实际上指的是：变量指向的那个内存地址所保存的数据不得改动 简单类型(number、string、boolean)：内存地址就是值,即常量(一变就报错). 复杂类型(对象、数组等)：地址保存的是一个指针，const只能保证指针是固定的(总是指向同一个地址),它内部的值是可以改变的(不要以为const就安全了！) 所以只要不重新赋值整个数组/对象， 因为保存的是一个指针，所以对数组使用的push、shift、splice等方法也是允许的，你就是把值一个一个全都删光了都不会报错。 复杂类型还有函数，正则等，这点也要注意一下。 总结:再总结一下，看到这些名词，脑子里应该会有对应的理解，如果没有的话，那可以再看看对应的内容。 var和let/const的区别: 块级作用域 不存在变量提升 暂时性死区 不可重复声明 let、const声明的全局变量不会挂在顶层对象下面 const命令两个注意点: let可以先声明稍后再赋值,而const在 声明之后必须马上赋值，否则会报错 const 简单类型一旦声明就不能再更改，复杂类型(数组、对象等)指针指向的地址不能更改，内部数据可以更改。 let、const使用场景: let使用场景：变量，用以替代var。 const使用场景：常量、声明匿名函数、箭头函数的时候。 鼓励我一下：觉得还不错的话，给我的项目点个star吧 博客、前端积累文档、公众号、GitHub 参考资料： let 和 const 命令]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[轻松掌握浏览器重绘重排原理]]></title>
    <url>%2F2018%2F12%2F18%2F%E8%BD%BB%E6%9D%BE%E6%8E%8C%E6%8F%A1%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8D%E7%BB%98%E9%87%8D%E6%8E%92%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[很多人都知道要减少浏览器的重排和重绘，但对其中的具体原理以及如何具体操作并不是很了解，当突然提起这个话题的时候，还是会一脸懵逼。希望大家可以耐着性子阅读本文，仔细琢磨，彻底掌握这个知识点！ 博客、前端积累文档、公众号、GitHub 网页生成过程： HTML被HTML解析器解析成DOM 树 css则被css解析器解析成CSSOM 树 结合DOM树和CSSOM树，生成一棵渲染树(Render Tree) 生成布局（flow），即将所有渲染树的所有节点进行平面合成 将布局绘制（paint）在屏幕上 第四步和第五步是最耗时的部分，这两步合起来，就是我们通常所说的渲染。 网上找了一张图片，我加了注释会更直观一些： 渲染：网页生成的时候，至少会渲染一次。 在用户访问的过程中，还会不断重新渲染 重新渲染需要重复之前的第四步(重新生成布局)+第五步(重新绘制)或者只有第五个步(重新绘制)。 重排比重绘大：大，在这个语境里的意思是：谁能影响谁？ 重绘：某些元素的外观被改变，例如：元素的填充颜色 重排：重新生成布局，重新排列元素。 就如上面的概念一样，单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分。 比如改变元素高度，这个元素乃至周边dom都需要重新绘制。 也就是说：“重绘”不一定会出现”重排”，”重排”必然会出现”重绘” 重排(reflow)：概念：当DOM的变化影响了元素的几何信息(DOM对象的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。 重排也叫回流,重排的过程以下面这种理解方式更清晰一些： 回流就好比向河里(文档流)扔了一块石头(dom变化)，激起涟漪，然后引起周边水流受到波及，所以叫做回流 常见引起重排属性和方法任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发重排，下面列一些栗子： 添加或者删除可见的DOM元素； 元素尺寸改变——边距、填充、边框、宽度和高度 内容变化，比如用户在input框中输入文字 浏览器窗口尺寸改变——resize事件发生时 计算 offsetWidth 和 offsetHeight 属性 设置 style 属性的值 常见引起重排属性和方法 width height margin padding display border position overflow clientWidth clientHeight clientTop clientLeft offsetWudth offsetHeight offsetTop offsetLeft scrollWidth scrollHeight scrollTop scrollLeft scrollIntoView() scrollTo() getComputedStyle() getBoundingClientRect() scrollIntoViewIfNeeded() 重排影响的范围：由于浏览器渲染界面是基于流失布局模型的，所以触发重排时会对周围DOM重新排列，影响的范围有两种： 全局范围：从根节点html开始对整个渲染树进行重新布局。 局部范围：对渲染树的某部分或某一个渲染对象进行重新布局 全局范围重排： 1234567891011&lt;body&gt; &lt;div class="hello"&gt; &lt;h4&gt;hello&lt;/h4&gt; &lt;p&gt;&lt;strong&gt;Name:&lt;/strong&gt;BDing&lt;/p&gt; &lt;h5&gt;male&lt;/h5&gt; &lt;ol&gt; &lt;li&gt;coding&lt;/li&gt; &lt;li&gt;loving&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt;&lt;/body&gt; 当p节点上发生reflow时，hello和body也会重新渲染，甚至h5和ol都会收到影响。 局部范围重排： 用局部布局来解释这种现象：把一个dom的宽高之类的几何信息定死，然后在dom内部触发重排，就只会重新渲染该dom内部的元素，而不会影响到外界。 尽可能的减少重排的次数、重排范围：重排需要更新渲染树,性能花销非常大: 它们的代价是高昂的，会破坏用户体验，并且让UI展示非常迟缓，我们需要尽可能的减少触发重排的次数。 重排的性能花销跟渲染树有多少节点需要重新构建有关系： 所以我们应该尽量以局部布局的形式组织html结构，尽可能小的影响重排的范围。 而不是像全局范围的示例代码一样一溜的堆砌标签，随便一个元素触发重排都会导致全局范围的重排。 重绘(Repaints):概念： 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。 常见的引起重绘的属性: color border-style visibility background text-decoration background-image background-position background-repeat outline-color outline outline-style border-radius outline-width box-shadow background-size 浏览器的渲染队列：思考以下代码将会触发几次渲染？ 1234div.style.left = '10px';div.style.top = '10px';div.style.width = '20px';div.style.height = '20px'; 根据我们上文的定义，这段代码理论上会触发4次重排+重绘，因为每一次都改变了元素的几何属性，实际上最后只触发了一次重排，这都得益于浏览器的渲染队列机制： 当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了一定的数量或者到了一定的时间间隔时，浏览器就会批量执行这些操作。 强制刷新队列:12345678div.style.left = '10px';console.log(div.offsetLeft);div.style.top = '10px';console.log(div.offsetTop);div.style.width = '20px';console.log(div.offsetWidth);div.style.height = '20px';console.log(div.offsetHeight); 这段代码会触发4次重排+重绘，因为在console中你请求的这几个样式信息，无论何时浏览器都会立即执行渲染队列的任务，即使该值与你操作中修改的值没关联。 因为队列中，可能会有影响到这些值的操作，为了给我们最精确的值，浏览器会立即重排+重绘。 强制刷新队列的style样式请求： offsetTop, offsetLeft, offsetWidth, offsetHeight scrollTop, scrollLeft, scrollWidth, scrollHeight clientTop, clientLeft, clientWidth, clientHeight getComputedStyle(), 或者 IE的 currentStyle 我们在开发中，应该谨慎的使用这些style请求，注意上下文关系,避免一行代码一个重排，这对性能是个巨大的消耗 重排优化建议就像上文提到的我们要尽可能的减少重排次数、重排范围，这样说很泛，下面是一些行之有效的建议，大家可以参考一下。 1. 分离读写操作12345678div.style.left = '10px';div.style.top = '10px';div.style.width = '20px';div.style.height = '20px';console.log(div.offsetLeft);console.log(div.offsetTop);console.log(div.offsetWidth);console.log(div.offsetHeight); 还是上面触发4次重排+重绘的代码，这次只触发了一次重排： 在第一个console的时候，浏览器把之前上面四个写操作的渲染队列都给清空了。剩下的console，因为渲染队列本来就是空的，所以并没有触发重排，仅仅拿值而已。 2. 样式集中改变1234div.style.left = '10px';div.style.top = '10px';div.style.width = '20px';div.style.height = '20px'; 虽然现在大部分浏览器有渲染队列优化，不排除有些浏览器以及老版本的浏览器效率仍然低下： 建议通过改变class或者csstext属性集中改变样式 123456789// badvar left = 10;var top = 10;el.style.left = left + "px";el.style.top = top + "px";// good el.className += " theclassname";// goodel.style.cssText += "; left: " + left + "px; top: " + top + "px;"; 3. 缓存布局信息123456789// bad 强制刷新 触发两次重排div.style.left = div.offsetLeft + 1 + 'px';div.style.top = div.offsetTop + 1 + 'px';// good 缓存布局信息 相当于读写分离var curLeft = div.offsetLeft;var curTop = div.offsetTop;div.style.left = curLeft + 1 + 'px';div.style.top = curTop + 1 + 'px'; 4. 离线改变dom 隐藏要操作的dom 在要操作dom之前，通过display隐藏dom，当操作完成之后，才将元素的display属性为可见，因为不可见的元素不会触发重排和重绘。 123dom.display = 'none'// 修改dom样式dom.display = 'block' 通过使用DocumentFragment创建一个dom碎片,在它上面批量操作dom，操作完成之后，再添加到文档中，这样只会触发一次重排。 复制节点，在副本上工作，然后替换它！ 5. position属性为absolute或fixedposition属性为absolute或fixed的元素，重排开销比较小，不用考虑它对其他元素的影响 6. 优化动画 可以把动画效果应用到position属性为absolute或fixed的元素上，这样对其他元素影响较小 动画效果还应牺牲一些平滑，来换取速度，这中间的度自己衡量： 比如实现一个动画，以1个像素为单位移动这样最平滑，但是reflow就会过于频繁，大量消耗CPU资源，如果以3个像素为单位移动则会好很多。 启用GPPU加速 此部分来自优化CSS重排重绘与浏览器性能 GPU(图像加速器)： GPU 硬件加速是指应用 GPU 的图形性能对浏览器中的一些图形操作交给 GPU 来完成，因为 GPU 是专门为处理图形而设计，所以它在速度和能耗上更有效率。 GPU 加速通常包括以下几个部分：Canvas2D，布局合成, CSS3转换（transitions），CSS3 3D变换（transforms），WebGL和视频(video)。 123456789/* * 根据上面的结论 * 将 2d transform 换成 3d * 就可以强制开启 GPU 加速 * 提高动画性能 */div &#123; transform: translate3d(10px, 10px, 0);&#125; 结语重排也是导致DOM脚本执行效率低的关键因素之一，重排与重绘作为大厂经常出现的面试题，并且涉及的性能优化，这是前端必须掌握的基本概念/技能之一(敲黑板!)。 重排会不断触发这是不可避免的，但我们在开发时，应尽量按照文中的建议来组织代码，这种优化，需要平时有意识的去做，一点一滴的去做，希望大家重视一下。 鼓励我一下：觉得还不错的话，给我的项目点个star吧 游泳、健身了解一下：博客、前端算法、公众号 以上2018.12.17 参考资料： 网页性能管理详解 优化CSS重排重绘与浏览器性能]]></content>
      <categories>
        <category>浏览器机制</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>js 机制</tag>
        <tag>浏览器机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页全屏模式轻松掌握[局部元素全屏展示]]]></title>
    <url>%2F2018%2F12%2F02%2F%E7%BD%91%E9%A1%B5%E5%85%A8%E5%B1%8F%E6%A8%A1%E5%BC%8F%E8%BD%BB%E6%9D%BE%E6%8E%8C%E6%8F%A1-%E5%B1%80%E9%83%A8%E5%85%83%E7%B4%A0%E5%85%A8%E5%B1%8F%E5%B1%95%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[我第一次对网页全屏模式有概念，是那种网页播放视频的全屏播 放的那种。感觉很强，前几个星期有个需求也是关于全屏模式的，接触之后才知道全屏模式并不神秘，是个很容易掌握的技能… 博客、前端积累文档、公众号、GitHub CodePen Demo地址：演示、code 进去看看，玩一下，本文将结合这个demo一起进行讲解。 全屏功能封装在一个类里面：我把全屏模式封装在一个类里面，在代码中有详细的注释，如果有需要的话，直接把类拿出来，根据栗子和注释使用即可。 代码在codepen的demo里。 何谓全屏？MDN介绍： 使用提供的API，让一个元素与其子元素，可以占据整个屏幕，并在此期间，从屏幕上隐藏所有的浏览器用户界面以及其他应用。 chrome下的全屏表现： 全屏会隐藏标签栏,书签栏 如果网页一开始不是全部撑开的形式，全屏下，也会将要全屏的元素充满整个屏幕 可以多层全屏，如栗子中一样，可以先左边全屏，然后红色全屏。 在这种情况下退出全屏，只会退出红色全屏，退回到左边全屏的形式，所以页面依然是全屏模式。 进入全屏时，有一个默认的提示：’按esc即可退出全屏模式’，如下图显示： 当按Esc或调用退出全屏方法，退出全屏。标签栏和书签栏依然是隐藏的，网页上的元素恢复成原本的尺寸。 要显示书签栏和标签栏，需要刷新一下页面。 全屏API：总共用到6个API： 浏览器是否支持全屏模式：document.fullscreenEnabled 使元素进入全屏模式：Element.requestFullscreen() 退出全屏：document.exitFullscreen() 检查当前是否有节点处于全屏状态：document.fullscreenElement 进入全屏/离开全屏，触发事件：document.fullscreenchange 无法进入全屏时触发: document.fullscreenerror 浏览器前缀：目前并不是所有的浏览器都实现了API的无前缀版本，所以我们需要针对不同浏览器，做一下API的兼容: 这是我在demo中做的浏览器兼容： 123456789101112131415161718192021222324/** * @description: 是否支持全屏+判断浏览器前缀 * @param &#123;Function&#125; fn 不支持全屏的回调函数 这里设了一个默认值 */isFullscreen(fn) &#123; let fullscreenEnabled; // 判断浏览器前缀 if (document.fullscreenEnabled) &#123; fullscreenEnabled = document.fullscreenEnabled; &#125; else if (document.webkitFullscreenEnabled) &#123; fullscreenEnabled = document.webkitFullscreenEnabled; this.prefixName = 'webkit'; &#125; else if (document.mozFullScreenEnabled) &#123; fullscreenEnabled = document.mozFullScreenEnabled; this.prefixName = 'moz'; &#125; else if (document.msFullscreenEnabled) &#123; fullscreenEnabled = document.msFullscreenEnabled; this.prefixName = 'ms'; &#125; if (!fullscreenEnabled) &#123; if (fn !== undefined) fn(); // 执行不支持全屏的回调 this.isFullscreenData = false; &#125;&#125; 我在实例化的时候进行一次判断浏览器是否支持全屏，然后保存浏览器前缀。 推荐这么做，因为如果每个API都要这样重复的判断浏览器前缀，那也太恶心了！ 1. 浏览器是否支持全屏模式：document.fullscreenEnableddocument.fullscreenEnabled属性返回一个布尔值，表示当前文档是否可以切换到全屏状态。 代码在上方浏览器前缀代码中给出了。 如果没有保存浏览器前缀的话，注意做一下不同浏览器前缀的兼容！下面不再强调。 2. 使元素进入全屏模式：Element.requestFullscreen()123456789101112/** * @description: 将传进来的元素全屏 * @param &#123;String&#125; domName 要全屏的dom名称 */Fullscreen(domName) &#123; const element = document.querySelector(domName); // 获取dom const methodName = this.prefixName === '' ? 'requestFullscreen' : `$&#123;this.prefixName&#125;RequestFullScreen`; // API前缀 element[methodName](); // 调用全屏&#125; 这就是我们实现全屏的API，是不是超简单？ 值得注意的是：调用此API并不能保证元素一定能够进入全屏模式 MDN：例如&lt;iframe&gt; 元素具有 allowfullscreen 属性，可选择是否将其内容以全屏模式显示 这种不被允许全屏的元素属于极少数情况，我试过可以将button全屏。 全屏请求必须在事件处理函数(点击事件等)中调用，否则将会被拒绝。 在demo中有演示,初始化直接全屏，会触发进入全屏失败回调。 3. 退出全屏：document.exitFullscreen()介绍： 1234567exitFullscreen() &#123; const methodName = this.prefixName === '' ? 'exitFullscreen' : `$&#123;this.prefixName&#125;ExitFullscreen`; // API 前缀 document[methodName](); // 调用&#125; 调用这个方法会让文档回退到上一个调用Element.requestFullscreen()方法进入全屏模式之前的状态。 多层全屏 像demo中，先进入左边全屏，再进入红色全屏，即为：多层全屏的情况(虽然这种情况并不多)。 当出现多层全屏的情况，需要一层层的退出到页面最初始的情况，并不是调用一次document.exitFullscreen()就恢复到页面最初始的样子。 4. 检查当前是否有节点处于全屏状态：document.fullscreenElementfullscreenElement属性返回正处于全屏状态的Element节点，如果当前没有节点处于全屏状态，则返回null 12345678910111213141516/** * @description: 检测有没有元素处于全屏状态 * @return 布尔值 */isElementFullScreen() &#123; const fullscreenElement = document.fullscreenElement || document.msFullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement; // 有前缀的f是大写，没前缀是小写 if (fullscreenElement === null) &#123; return false; // 当前没有元素在全屏状态 &#125; else &#123; return true; // 有元素在全屏状态 &#125;&#125; 事实上，还有一个属性document.fullscreen，返回一个布尔值，表示文档是否处于全屏模式。 两个方法效果是一样，但因为IE不支持这个属性，所以这里用的是document.fullscreenElement 5. 进入全屏/离开全屏，触发事件：document.fullscreenchange当我们进入全屏和离开全屏的时候，都会触发一个fullscreenchange事件。 MDN注意：此事件不会提供任何信息，表明是进入全屏或退出全屏。 看了好久事件返回的信息，确实找不到一个值，表明这是在进入全屏，或者离开全屏！ 可以说相当不人性化了！但我们可以通过检查当前是否有节点处于全屏状态，判断当前是否处于全屏模式。 12345678910111213141516/** * @description: 监听进入/离开全屏 * @param &#123;Function&#125; enter 进入全屏的回调 * @param &#123;Function&#125; quit 离开全屏的回调 */screenChange(enter,quit) &#123; if (!this.isFullscreenData) return; const methodName = `on$&#123;this.prefixName&#125;fullscreenchange`; document[methodName] = e =&gt; &#123; if (this.isElementFullScreen()) &#123; enter &amp;&amp; enter(e); // 进入全屏回调 &#125; else &#123; quit &amp;&amp; quit(e); // 离开全屏的回调 &#125; &#125;;&#125; 注意：多层全屏的情况 先进入左边全屏(进入全屏回调)，再进入红色全屏(进入全屏回调) 退出全屏,此时退出红色全屏，左边仍是全屏(触发进入全屏回调) 出现这种情况，可以在点击按钮的时候，做一些状态限制。或者根据全屏事件返回的dom信息来进行判断。 6. 无法进入全屏时触发: document.fullscreenerror进入全屏并不总是成功的，可能是技术原因，也可能是用户拒绝，我们在上文进入全文的APIElement.requestFullscreen()部分讲过了。 比如全屏请求不是在事件处理函数中调用,会在这里拦截到错误 12345678910/** * @description: 浏览器无法进入全屏时触发 * @param &#123;Function&#125; enterErrorFn 回调 */screenError(enterErrorFn) &#123; const methodName = `on$&#123;this.prefixName&#125;fullscreenerror`; document[methodName] = e =&gt; &#123; enterErrorFn &amp;&amp; enterErrorFn(e) &#125;;&#125; Css： 全屏模式下的样式chorme 70 下的默认会为正在全屏的dom添加两个class：稍微看一下 默认设置黑色背景 12345678:not(:root):-webkit-full-screen::backdrop &#123; position: fixed; top: 0px; right: 0px; bottom: 0px; left: 0px; background: black; // 会将背景设为黑色的 如果你没为你的dom设置背景的话，全屏下会为黑色&#125; 默认样式： 1234567891011121314151617:not(:root):-webkit-full-screen &#123; object-fit: contain; position: fixed !important; top: 0px !important; right: 0px !important; bottom: 0px !important; left: 0px !important; box-sizing: border-box !important; min-width: 0px !important; max-width: none !important; min-height: 0px !important; max-height: none !important; width: 100% !important; height: 100% !important; transform: none !important; margin: 0px !important;&#125; 全屏状态的CSS： 全屏状态下，大多数浏览器的CSS支持:full-screen伪类，只有IE11支持:fullscreen伪类。使用这个伪类，可以对全屏状态设置单独的CSS属性。 以下css摘自阮一峰老师的Fullscreen API：全屏操作 1234567891011121314/* 针对dom的全屏设置 */.div:-webkit-full-screen &#123; background: #fff;&#125;/* 全屏属性 */:-webkit-full-screen &#123;&#125;:-moz-full-screen &#123;&#125;:-ms-fullscreen &#123;&#125;/* 全屏伪类 当前chrome:70 不支持 */:full-screen &#123;&#125;:fullscreen &#123; /* IE11支持 */&#125; 结语我们可以把全屏技术应用在H5游戏、信息流网站、视频等地方，下次再有全屏需求时，记住不要慌，回头看看过本文的栗子，把我封装的类拿出来直接用就可以啦！ 希望看完的朋友可以点个喜欢/关注，您的支持是对我最大的鼓励。博客、前端积累文档、公众号、GitHub 以上2018.12.1 参考资料： Fullscreen API：全屏操作 MDN]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>WebWorker</tag>
        <tag>Html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端er来学习一下webWorker吧]]></title>
    <url>%2F2018%2F11%2F28%2F%E5%89%8D%E7%AB%AFer%E6%9D%A5%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%8BwebWorker%E5%90%A7%2F</url>
    <content type="text"><![CDATA[我们都知道，JavaScript 是单线程的，在同一时刻只能处理一个任务，我们会通过 setTimeout()、setInterval()、ajax 和事件处理程序等技术模拟“并行”。但都不是真正意义上的并行: Web Worker 是 HTML5 标准的一部分，这一规范定义了一套 API，它允许一段 JavaScript 程序运行在主线程之外的另外一个线程中。 这在很大程度上利用了现在不断升级的电脑计算能力：能够在同一时间平行处理两个任务。 游泳、健身了解一下：博客、前端积累文档、公众号、GitHub 场景当我们有些任务需要花费大量的时间，进行复杂的运算，就会导致页面卡死：用户点击页面需要很长的时间才能响应，因为前面的任务还未完成，后面的任务只能排队等待。对用户来说，这样的体验无疑是糟糕的，web worker 就是为了解决这种花费大量时间的复杂运算而诞生的！ WebWorker 的作用：创建 worker 线程WebWorker 允许在主线程之外再创建一个 worker 线程，在主线程执行任务的同时，worker 线程也可以在后台执行它自己的任务，互不干扰。 这样就让 JS 变成多线程的环境了，我们可以把高延迟、花费大量时间的运算，分给 worker 线程，最后再把结果返回给主线程就可以了，因为时间花费多的任务被 web worker 承担了，主线程就会很流畅了！ 主线程我们先来看一下栗子：codepen,这里我写了一个 class，里面有详细注释，可以参考一下。 创建 worker 对象：主线程调用new Worker()构造函数，新建一个 worker 线程，构造函数的参数是一个 url，生成这个 url 的方法有两种： 脚本文件： 1const worker = new Worker('https://~.js'); 因为 worker 的两个限制： 分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。 worker 不能读取本地的文件(不能打开本机的文件系统file://)，它所加载的脚本必须来自网络。 可以看到限制还是比较多的，如果要使用这种形式的话，在项目中推荐把文件放在静态文件夹中，打包的时候直接拷贝进去，这样我们就可以拿到固定的链接了， 字符串形式： 123456789const data = ` // worker线程 do something `;// 转成二进制对象const blob = new Blob([data]);// 生成urlconst url = window.URL.createObjectURL(blob);// 加载urlconst worker = new Worker(url); 栗子中就是使用这种形式的，方便我们演示。 在项目中：我们可以把worker线程的逻辑写在js文件里面，然后字符串化，然后再export、import，配合webpack进行模块化管理,这样就很容易使用了。 主线程的其他 API：1. 主线程与 worker 线程通信:123worker.postMessage(&#123; hello: ['hello', 'world']&#125;); 它们相互之间的通信可以传递对象和数组，这样我们就可以根据相互之间传递的信息来进行一些操作，比如可以设置一个type属性，当值为hello时执行什么函数，当值为world的时候执行什么函数。 值得注意的是：它们之间通信是通过拷贝的形式来传递数据的，进行传递的对象需要经过序列化，接下来在另一端还需要反序列化。这就意味着： 我们不能传递不能被序列化的数据，比如函数，会抛出错误的。 在一端改变数据，另外一端不会受影响，因为数据不存在引用，是拷贝过来的。 2. 监听 worker 线程返回的信息1234worker.onmessage = function (e) &#123; console.log('父进程接收的数据：', e.data); // doSomething();&#125; 3. 主线程关闭 worker 线程Worker 线程一旦新建成功，就会始终运行，这样有利于随时响应主线程的通信。 这也是 Worker 比较耗费计算机的计算资源(CPU)的原因，一旦使用完毕，就应该关闭 worker 线程。 1worker.terminate(); // 主线程关闭worker线程 4. 监听错误12345// worker线程报错worker.onerror = e =&gt; &#123; // e.filename - 发生错误的脚本文件名；e.lineno - 出现错误的行号；以及 e.message - 可读性良好的错误消息 console.log('onerror', e);&#125;; 也可以像我给出的栗子一样,把两个报错放在一起写，有报错把信息传出来就好了。 Worker 线程self 代表 worker 进程自身worker 线程的执行上下文是一个叫做WorkerGlobalScope的东西跟主线程的上下文(window)不一样。 我们可以使用self/WorkerGlobalScope来访问全局对象。 监听主线程传过来的信息：1234self.onmessage = e =&gt; &#123; console.log('主线程传来的信息：', e.data); // do something&#125;; 发送信息给主线程123self.postMessage(&#123; hello: [ '这条信息', '来自worker线程' ]&#125;); worker 线程关闭自身1self.close() worker 线程加载脚本：Worker 线程能够访问一个全局函数 imprtScripts()来引入脚本，该函数接受 0 个或者多个 URI 作为参数。 1importScripts('http~.js','http~2.js'); 脚本中的全局变量都能被 worker 线程使用。 脚本的下载顺序是不固定的，但执行时会按照传入 importScripts() 中的文件名顺序进行，这个过程是同步的。 Worker 线程限制因为 worker 创造了另外一个线程，不在主线程上，相应的会有一些限制，我们无法使用下列对象： window 对象 document 对象 DOM 对象 parent 对象 我们可以使用下列对象/功能： 浏览器：navigator 对象 URL：location 对象，只读 发送请求：XMLHttpRequest 对象 定时器：setTimeout/setInterval，在 worker 线程轮询也是很棒！ 应用缓存：Application Cache 多个 worker 线程 在主线程内可以创建多个 worker 线程 栗子最下方有。 worker 线程内还可以新建 worker 线程，使用同源的脚本文件创建。 在 worker 线程内再新建 worker 线程就不能使用window.URL.createObjectURL(blob)，需要使用同源的脚本文件来创建新的 worker 线程，因为我们无法访问到window对象。 这里不方便演示，跟在主线程创建 worker 线程是一个套路，只是改成了脚本文件形式创建 worker 线程。 线程间转移二进制数据因为主线程与 worker 线程之间的通信是拷贝关系，当我们要传递一个巨大的二进制文件给 worker 线程处理时(worker 线程就是用来干这个的)，这时候使用拷贝的方式来传递数据，无疑会造成性能问题。 幸运的是，Web Worker 提供了一中转移数据的方式，允许主线程把二进制数据直接转移给子线程。这种方式比原先拷贝的方式，有巨大的性能提升。 一旦数据转移到其他线程，原先线程就无法再使用这些二进制数据了，这是为了防止出现多个线程同时修改数据的麻烦局面 下方栗子出自浅谈 HTML5 Web Worker 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 创建二进制数据var uInt8Array = new Uint8Array(1024*1024*32); // 32MBfor (var i = 0; i &lt; uInt8Array .length; ++i) &#123; uInt8Array[i] = i;&#125;console.log(uInt8Array.length); // 传递前长度:33554432// 字符串形式创建worker线程var myTask = ` onmessage = function (e) &#123; var data = e.data; console.log('worker:', data); &#125;;`;var blob = new Blob([myTask]);var myWorker = new Worker(window.URL.createObjectURL(blob));// 使用这个格式(a,[a]) 来转移二进制数据myWorker.postMessage(uInt8Array.buffer, [uInt8Array.buffer]); // 发送数据、转移数据console.log(uInt8Array.length); // 传递后长度:0，原先线程内没有这个数据了``` &gt; 二进制数据有：File、Blob、ArrayBuffer 等类型，也允许在 worker 线程之间发送，**这对于影像处理、声音处理、3D 运算等就非常方便了，不会产生性能负担**### 应用场景：1. 数学运算2. 图像、影音等文件处理3. 大量数据检索 比如用户输入时，我们在后台检索答案，或者帮助用户联想，纠错等操作.4. 耗时任务都丢到 webworker 解放我们的主线程。### 兼容：没有找到具体的制定日期，有篇博客是在 10 年的 7 月份写的，也就是说 web worker 至少出现了八年了，以下兼容摘自[MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers)：Chrome：4, Firefox：3.5, IE：10.0, Opera：10.6, Safari：4现在兼容还是做的比较好的，如果实在不放心的话：```jsif (window.Worker) &#123; ...&#125;else&#123; ...&#125; 结语：Web Worker的出现，给浏览器带来了后台计算的能力，把耗时的任务分配给worker线程来做，在很大程度上缓解了主线程UI渲染阻塞的问题，提升页面性能。 使用起来也不复杂，以后有复杂的问题，记得要丢给我们浏览器的后台(web worker)来处理 看完之后，一定要研究一下文中的栗子，自己鼓捣鼓捣，实践出真知！ PS: 推荐一下我上个月写的手摸手教你使用WebSocket，感兴趣的可以看一下。 希望看完的朋友可以点个喜欢/关注，您的支持是对我最大的鼓励。博客、前端积累文档、公众号、GitHub 以上2018.11.25 参考资料： MDN Web Worker 使用教程 浅谈HTML5 Web Worker]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>WebWorker</tag>
        <tag>Html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一份超级详细的Vue-cli3.0使用教程]]></title>
    <url>%2F2018%2F11%2F11%2F%E4%B8%80%E4%BB%BD%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E7%9A%84Vue-cli3-0%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言在vue-cli 2.X的时候，也写过一篇类似的文章，在八月份的时候vue-cli已经更新到了3.X，新版本的脚手架，功能灰常强大，试用过后非常喜欢，写篇教程来帮助各位踩一下坑。 游泳、健身了解一下：博客、前端积累文档、公众号、GitHub 主要内容： 零配置启动/打包一个.vue文件 详细的搭建过程 重点推荐：使用图形化界面创建/管理/运行项目 安装：卸载旧版本：如果你事先已经全局安装了旧版本的vue-cli(1.x 或 2.x),你需要先卸载它: npm uninstall vue-cli -g Node版本要求：3.x需要在Node.js8.9或更高版本(推荐8.11.0+)，点击这里可以安装node 大多数人都安装过了node,使用下面的命令行查询你的node版本: node -v 如果你的版本不够，可以使用下面的命令行来把Node版本更新到最新的稳定版： npm install -g n // 安装模块 这个模块是专门用来管理node.js版本的 n stable // 更新你的node版本 mac下，更新版本的时候,如果提示你权限不够： sudo n stable // 我就遇到了 安装vue-cli:npm install -g @vue/cli // 安装cli3.x vue --version // 查询版本是否为3.x 如果cli3.x用的不舒服，cli3也能使用2.x模板： npm install -g @vue/cli-init // 安装这个模块 // 就可以使用2.x的模板：vue init webpack my-project 零配置启动/打包一个.vue文件：安装扩展：npm install -g @vue/cli-service-global 安装完扩展之后，可以随便找个文件夹建一个如下方示例的.vue文件,然后跑起来： vue serve App.vue // 启动服务 vue build App.vue // 打包出生产环境的包并用来部署 如下图，只需一个.vue文件，就能迅速启动一个服务：如图所示，服务启动的时候回生成一个node_modules包，稍微测试了一下，服务支持ES6语法和热更新，打包的时候会生成一个dist文件夹。(新建一个test.vue文件也只有一个node_modules/dist文件夹) 这是个很棒的功能，用于开发一个库、组件，做一些小demo等都是非常适合的！ 第一次创建项目:1. 命令行:vue create hello-cli3 hello-cli3是文件夹名字，如果不存在会自动创建文件夹，如果存在会安装到那个文件夹中。 相比2.x的时候需要自己手动创建一个文件夹，这里也算是一个小优化吧。 2. 选择模板: 一开始只有两个选项: default(默认配置)和Manually select features(手动配置) 默认配置只有babel和eslint其他的都要自己另外再配置，所以我们选第二项手动配置。 在每次选择手动配置之后，会询问你是否保存配置，也就是图片中的koro选项，这样以后我们在进行创建项目的时候只需使用原先的配置就可以了，而不用再进行配置。 3. 选择配置： 根据你的项目需要来选择配置,空格键是选中与取消，A键是全选 ? Check the features needed for your project: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection) // 检查项目所需的功能:(按&lt;space&gt;选择，&lt;a&gt;切换所有，&lt;i&gt;反转选择） &gt;( ) TypeScript // 支持使用 TypeScript 书写源码 ( ) Progressive Web App (PWA) Support // PWA 支持 ( ) Router // 支持 vue-router ( ) Vuex // 支持 vuex ( ) CSS Pre-processors // 支持 CSS 预处理器。 ( ) Linter / Formatter // 支持代码风格检查和格式化。 ( ) Unit Testing // 支持单元测试。 ( ) E2E Testing 4. 选择css预处理器: 如果你选择了Css预处理器选项，会让你选择这个 ? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): // 选择CSS预处理器（默认支持PostCSS，Autoprefixer和CSS模块）： &gt; SCSS/SASS LESS Stylus 5. 是否使用路由的history模式： 这里我建议选No，这样打包出来丢到服务器上可以直接使用了，后期要用的话，也可以自己再开起来。 选yes的话需要服务器那边再进行设置。 Use history mode for router? (Requires proper server setup for index fallback in production) // 路由使用history模式?(在生产环境中需要适当的服务器设置以备索引) 6. 选择Eslint代码验证规则：&gt; ESLint with error prevention only ESLint + Airbnb config ESLint + Standard config ESLint + Prettier 7. 选择什么时候进行代码规则检测： 建议选保存就检测，等到commit的时候，问题可能都已经积累很多了。 之前写了篇VsCode保存时自动修复Eslint错误推荐一下。 ? Pick additional lint features: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection) &gt;( ) Lint on save // 保存就检测 ( ) Lint and fix on commit // fix和commit时候检查 8. 选择e2e测试:? Pick a E2E testing solution: (Use arrow keys) ❯ Cypress (Chrome only) Nightwatch (Selenium-based) 9. 把babel,postcss,eslint这些配置文件放哪： 通常我们会选择独立放置，让package.json干净些 ? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.? (Use arrow keys) &gt; In dedicated config files // 独立文件放置 In package.json // 放package.json里 10. 是否保存配置：Save this as a preset for future projects? (Y/n) // 是否记录一下以便下次继续使用这套配置 // 选保存之后，会让你写一个配置的名字： Save preset as: name // 然后你下次进入配置可以直接使用你这次的配置了 11. 下载依赖12. webpack配置的目录不见了：一起来看一下新项目的结构(下图),会发现2.x的webpack配置的目录不见了，也就是没有build、config这两个文件夹了： 这种方式的优势对小白来说非常友好，不会一上来就两个文件夹，一堆文件，看着脑袋都大了。 然后在引用抄别人的配置的时候，也非常方便，直接将文件复制过来就好了。 在自定义一下webpack的配置，我们需要在根目录新建一个vue.config.js文件，文件中应该导出一个对象，然后进行配置，详情查阅官方文档 // vue.config.js module.exports = { // 选项... } 还有一些小变动像：static文件夹改为public了，router文件夹变成了单个文件之类的(我之前一直这么做,嘿嘿)。 13.启动项目： 启动项目：npm run serve // 不是之前的 npm run dev 打开http://localhost:8080： 使用图形化界面创建/管理/运行项目：启动图形化界面vue ui 这是个全局的命令 在哪个文件夹都可以打开 界面(下图)，重要的项目可以收藏起来(置顶)： 创建项目和导入项目： 目录选中之后，导入项目点击下面的导入就可以了。 创建项目，填一个文件夹名字： 然后选一下预先保存好的设置就可以了，非常方便，建议采用图形界面来创建项目： 项目管理：当我们点击hello -cli3项目，就会进入项目管理的界面 1. 仪表盘： 这个仪表盘，主要是为了我们操作方便而设置的 可以点击右上角的按钮，来添加/移动这些功能选项。 2. vue-cli3.x插件： vue-cli3的插件功能，详情了解官方文档 cli3插件安装的过程： 3. 项目依赖 直接在图形界面管理依赖很舒服了！ 安装依赖的时候，要记得选择开发依赖/运行依赖！ 4. 项目配置 可以对cli进行一些配置、Eslint规则修改： 5. 任务： serve 运行项目，点击直接运行，再也不用输入命令了！ 可以清楚的看到各个模块用了多久，方便我们针对性的进行优化： ![](https://user-gold-cdn.xitu.io/2018/11/10/166fd41bde538496?w=1913&amp;h=996&amp;f=png&amp;s=223258) build 打包项目：这里主要展示了图表的功能，比以前2.x生成报告更加直观，超级棒！ 6. 其他 夜间风格界面，我更喜欢这个界面 直接打开编辑器,很棒了！ 还有一些乱七八糟的按钮 结语可以说很认真了，希望大家看完能够有些收获，赶紧试试新版的vue-cli吧！ 希望看完的朋友可以点个喜欢/关注，您的支持是对我最大的鼓励。博客、前端积累文档、公众号、GitHub 以上2018.11.10 参考资料： vue-cli3官方文档 vue-cli3.0搭建与配置]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>Vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-奇偶分割数组]]></title>
    <url>%2F2018%2F11%2F04%2F%E7%AE%97%E6%B3%95-%E5%A5%87%E5%81%B6%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[奇偶分割数组难度：简单描述：分割一个整数数组，使得奇数在前偶数在后。 样例：给定 [1, 2, 3, 4]，返回 [1, 3, 2, 4]。 增加一下难度：给定乱序数组：[2, 5, 1, 6, 3, 4]，返回[1, 3, 5, 2, 4, 6] 思路分析：排序好的数组：找到奇数进行操作。 乱序的数组：使用sort方法进行排序+提取奇数 代码模板：1const partitionArray = arr =&gt; &#123;&#125;; 想一想再看答案想一想再看答案想一想再看答案代码： 排序好的数组找到奇数进行操作 12345678910111213const partitionArray = arr =&gt; &#123; let num = arr.length - 1; // 其实如果是乱序数组，可以在这里使用sort将数组排序好再走下面那部分也可以 // 倒序遍历 for (let i = num; i &gt;= 0; i--) &#123; if (arr[i] % 2 !== 0) &#123; let item = arr.splice(i, 1); // 将当前值取出来 arr.unshift(item[0]); // 添加到首位 &#125; &#125; return arr;&#125;;console.log('输出', partitionArray([1, 2, 3, 4])); 乱序数组,排序+取奇数偶数 这种方法无疑是更好的解决方法，事实上涉及排序最好都是使用sort进行排序，对 sort 不熟的，可以看下之前写的这篇数组 API 解析合集 12345678910111213141516171819202122const partitionArray = arr =&gt; &#123; return arr.sort((a, b) =&gt; &#123; if (a % 2 !== 0 &amp;&amp; b % 2 !== 0) &#123; // 当两个数都是奇数的情况下 按大小排序 return a - b; &#125; else if (a % 2 === 0 &amp;&amp; b % 2 === 0) &#123; // 当两个数都是偶数的情况下也是按大小排序 return a - b; &#125; else if (a % 2 !== 0) &#123; // 当a是奇数 要排在b的前面 return -1; &#125; else if (b % 2 !== 0) &#123; // 当b是奇数 排在a的前面 return 1; &#125; &#125;);&#125;;console.log( '输出', partitionArray([1, 2, 3, 4]), partitionArray([2, 5, 1, 6, 3, 4])); 鼓励我一下：觉得还不错的话，给我的项目点个star吧]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-爬楼梯2]]></title>
    <url>%2F2018%2F11%2F04%2F%E7%AE%97%E6%B3%95-%E7%88%AC%E6%A5%BC%E6%A2%AF2%2F</url>
    <content type="text"><![CDATA[爬楼梯 2难度：简单描述：一个小孩爬一个 n 层台阶的楼梯。他可以每次跳 1 步， 2 步 或者 3 步。实现一个方法来统计总共有多少种不同的方式爬到最顶层的台阶 本题跟爬楼梯一毛一样，只是多了可以一次跳三步，所以尽量自己做出来 样例：n = 3，1 + 1 + 1 = 2 + 1 = 1 + 2 = 3 = 3，共有 4 种方法 思路分析：这类题我们首先要来找其中的规律，找到了里面的规律，剩下的就好办了。 我再列举出几个结果： 123451: 1 // 1种方法2: 1+1=2 // 2种方法3: 1 + 1 + 1 = 2 + 1 = 1 + 2 = 3 = 3 // 4种方法4: 1+1+1+1=2+2=1+3 =1+2+1=2+1+1 = 1+1+2= 3+1 // 7种方法5：1 * 5 =1+2+2 =2+1+2 =2+2+1 = 1+1+3 =1+3+1 = 3+1+1 = 3+2 = 2+3 = 1+1+1+2 =1+2+1+1 = 2+1+1+1 = 1+1+2+1 // 13种方法 查找样例中的规律：爬楼梯 代码模板：12345/** * @param n: An integer * @return: An integer */const climbStairs2 = function(n) &#123;&#125;; 想一想再看答案想一想再看答案想一想再看答案规律除了前 3 阶楼梯是没有规律的，第 n 阶的楼梯的方法是第 i-1 、第 i-2 和第 i-3 阶楼梯所用方法的和。 规律都给你总结好了，再给你个机会自己做出来。 代码：解题的核心就是逐步推导，推导出 n 前面的两个值。 递归 因为做过一遍，最先想起来的就是递归。 1234567891011const climbStairs2 = n =&gt; &#123; let everyStairs = k =&gt; &#123; // 循环退出条件 if (k === 1) return 1; if (k === 2) return 2; if (k === 3) return 4; return everyStairs(k - 1) + everyStairs(k - 2) + everyStairs(k - 3); // 三个值相加求出k所用的方法 &#125;; return everyStairs(n);&#125;;console.log('输出', climbStairs2(3), climbStairs2(4), climbStairs2(5)); 交换变量 实际上我们只需要 n 之前的三个值，就可以求出 n 所用的方法，所以我们没必要将 n 之前的所有值都推导出来。 1234567891011const climbStairs2 = k =&gt; &#123; if (k === 1) return 1; if (k === 2) return 2; if (k === 3) return 4; let [a, b, c] = [1, 2, 4]; // 前三阶楼梯 for (let i = 3; i &lt;= n; i++) &#123; [a, b, c] = [b, c, a + b + c]; // 交换变量 更新前两个值，推导k的值 &#125; return c;&#125;;console.log('输出', climbStairs2(3), climbStairs2(4), climbStairs2(5)); 数组形式： 12345678const climbStairs2 = function(n) &#123; let dp = [0, 1, 2, 4]; // 初始数组 前面三个没有规律 // 从第4阶楼梯开始推导 for (let i = 4; i &lt;= n; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]; // 从3开始都是可以由前面3个元素相加推导出来 &#125; return dp[n];&#125;; 鼓励我一下：觉得还不错的话，给我的项目点个star吧]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-相亲数]]></title>
    <url>%2F2018%2F11%2F04%2F%E7%AE%97%E6%B3%95-%E7%9B%B8%E4%BA%B2%E6%95%B0%2F</url>
    <content type="text"><![CDATA[相亲数难度：简单描述：一对整数是相亲数是说他们各自的所有有效因子（除了自己以外的因子）之和等于另外一个数。比如(220, 284)就是一对相亲数。 220 的所有因子：1+2+4+5+10+11+20+22+44+55+110 = 284 284 的所有因子：1+2+4+71+142 = 220 给出整数 k，求 1~k 之间的所有相亲数对。 样例：给出 300, 返回 [[220, 284]] 思路分析：因素：给出一个数，能整除该数的的除数都是这个数的因素。 计算出每个数的因素和，将其存起来，然后再去判断是否为相亲数 代码模板：1const amicablePair = k =&gt; &#123;&#125;; 想一想再看答案想一想再看答案想一想再看答案代码：事实上我们要做的只有两步： 遍历 1~k 求出每个数的因素和，并用对象存储起来,遍历对象，判断相亲数 12345678910111213141516171819202122232425262728293031const amicablePair = k =&gt; &#123; let obj = &#123;&#125;; // 遍历整个范围，包括k for (let i = 1; i &lt;= k; i++) &#123; let arr = []; // 求每个数的因数 for (let j = 1; j &lt; i; j++) &#123; // 能整除 没有余数的 除数都是因数 if (i % j === 0) &#123; arr.push(j); &#125; &#125; // 计算因数和 let total = arr.reduce((a, b) =&gt; &#123; return a + b; &#125;, 0); obj[i] = total; // 储存每个数的相亲数 &#125; let res = []; // 结果 for (let key in obj) &#123; // 顺序 当属性的值比属性大时才进入 此处也可防止重复添加 if (obj[key] &gt; key) &#123; // 判断相亲数 if (key === `$&#123;obj[obj[key]]&#125;`) &#123; res.push([key, obj[key]]); // 按顺序添加 &#125; &#125; &#125; return res;&#125;;console.log('输出', amicablePair(300)); 在求因素和的时候，直接判断是否有对应的相亲数 1234567891011121314151617181920212223242526272829303132const amicablePair = k =&gt; &#123; let res = []; // 遍历整个范围，包括k for (let i = 1; i &lt;= k; i++) &#123; let total = totalFn(i); // i的因素和需要比i小 才能push 防止重复添加 if (total &gt; i) &#123; let total2 = totalFn(total); // 求 i的因素和 的因素和 // 判断相亲数：i是否与i的因素和的因素和相等 if (i === total2) &#123; res.push(i, total); &#125; &#125; &#125; // 计算一个数的因素和 function totalFn(num) &#123; let arr = []; // 求每个数的因数 for (let j = 1; j &lt; num; j++) &#123; // 能整除 没有余数的 除数都是因数 if (num % j === 0) &#123; arr.push(j); &#125; &#125; // 计算因数和 let total = arr.reduce((a, b) =&gt; &#123; return a + b; &#125;, 0); return total; &#125; return res; // 结果&#125;; 鼓励我一下：觉得还不错的话，给我的项目点个star吧]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-丢失的数]]></title>
    <url>%2F2018%2F11%2F04%2F%E7%AE%97%E6%B3%95-%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[丢失的数难度：简单描述：在数组 A 中，包含 0 到 n 的整数，其中缺失了一个数。请编写代码，以查找数组中缺失的整数。 样例：array = [4,3,2,0,5] return 1 array = [0,1,2,3,4,7,6] return 5 array = [0,1,2,3] return 4 思路分析：简单，不分析 代码模板：1const findMissing = arr =&gt; &#123;&#125;; 想一想再看答案想一想再看答案想一想再看答案代码：遍历数组长度的n+1次(包括0)，对比有没有这个值即可 123456789101112const findMissing = arr =&gt; &#123; let num = arr.length + 1; for (let i = 0; i &lt; num; i++) &#123; if (arr.indexOf(i) === -1) &#123; // i不在数组中 就找到这个值 return i; &#125; &#125;&#125;;console.log('输出', findMissing([4, 3, 2, 0, 5])); //1console.log(findMissing([0, 1, 2, 3, 4, 7, 6])); // 5console.log(findMissing([0, 1, 2, 3])); // 4 鼓励我一下：觉得还不错的话，给我的项目点个star吧]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-判断字符串的循环移动]]></title>
    <url>%2F2018%2F11%2F04%2F%E7%AE%97%E6%B3%95-%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BE%AA%E7%8E%AF%E7%A7%BB%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[判断字符串的循环移动难度：简单描述：可以检验某个单词是否为另一个单词的子字符串。给定 s1 和 s2，请设计一种方法来检验 s2 是否为 s1 的循环移动后的字符串。 样例：s1 = waterbottle;s2 = erbottlewat;返回true; s1 = apple;s2 = ppale;返回false; 思路分析：将其中一个字符串转成数组来操作，然后再转成字符，回头来比较字符串。 代码模板：123456/** * @param s1: the first string * @param s2: the socond string * @return: true if s2 is a rotation of s1 or false */const isRotation = function(s1, s2) &#123;&#125;; 想一想再看答案想一想再看答案想一想再看答案代码：123456789101112131415161718// 将最后的值拿出来 再放到第一位上去const isRotation = (s, t) =&gt; &#123; if (s.length === t.length &amp;&amp; s &amp;&amp; t) &#123; for (let i = 0; i &lt; s.length; i++) &#123; t = [...t]; // 转数组 let pop = t.pop(); // 拿最后一个元素 t.unshift(pop); // 添加到第一个元素 t = t.join(''); // 转字符 if (t === s) return true; // 比较 &#125; &#125; return false; // 字符串长度相等 并且有值&#125;;console.log( '输出：', isRotation('waterbottle', 'erbottlewat'), isRotation('apple', 'ppale')); 鼓励我一下：觉得还不错的话，给我的项目点个star吧]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法_字符串压缩]]></title>
    <url>%2F2018%2F10%2F27%2F%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9%2F</url>
    <content type="text"><![CDATA[难度：简单描述：设计一种方法，通过给重复字符计数来进行基本的字符串压缩。 例如，字符串 aabcccccaaa 可压缩为 a2b1c5a3 。而如果压缩后的字符数不小于原始的字符数，则返回原始的字符串。 可以假设字符串仅包括 a-z 的字母。 样例：str=aabcccccaaa 返回 a2b1c5a3 str=aabbcc 返回 aabbcc str=aaaa 返回 a4 思路分析：解题思路：取出字符串，判断重复停止，添加到新字符串中。 注：需判断压缩后的字符串长度和原始字符串长度。 代码模板：1const compress = function(originalString) &#123;&#125;; 想一想再看答案想一想再看答案想一想再看答案代码：1234567891011121314151617181920212223242526272829303132333435// 取出字符串，判断重复停止，添加到新字符串中const compress = function(originalString) &#123; if (originalString.length &lt;= 1) return originalString; // 直接返回源字符串 let newStr = ''; let s = originalString.charAt(0); let num = 1; // 跳过第一个 let total = originalString.length; for (let i = 1; i &lt; total; i++) &#123; let nowS = originalString.charAt(i); if (nowS === s) &#123; num = num + 1; // 增加数量 if (i + 1 === total) &#123; newStr += `$&#123;s&#125;$&#123;num&#125;`; // 遍历结束时，拼接最后的字符串 &#125; &#125; else &#123; newStr += `$&#123;s&#125;$&#123;num&#125;`; // 拼接字符串 num = 1; // 重置为1 s = nowS; // 转为下一个字符s &#125; &#125; // 生成的字符串长度大于等于源字符串 返回源字符串 否则返回生成的字符串 if (newStr.length &gt;= originalString.length) &#123; return originalString; &#125; else &#123; return newStr; &#125;&#125;;console.log( '输出：', compress('aabcccccaaa'), // a2b1c5a3 compress('aabbcc'), // aabbcc compress('aaaa'), // a4 compress('a'), // a compress('') // ''); 鼓励我一下：觉得还不错的话，给我的项目点个star吧]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法_第一次只出现一次的字符]]></title>
    <url>%2F2018%2F10%2F27%2F%E7%AE%97%E6%B3%95-%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[难度：简单描述：给出一个字符串，找出第一个只出现一次的字符。 样例：对于 aabc, b为第一个只出现一次的字符. 对于 abaccdeff, b为第一个只出现一次的字符. 思路分析：可以用对象保存字符出现的次数。 代码模板：1const firstUniqChar = function(str) &#123;&#125;; 想一想再看答案想一想再看答案想一想再看答案代码： 将值删除，用 indexOf 查找还有没有相同字符，并查找之前删过的字符 123456789101112131415const firstUniqChar = function(str) &#123; str = [...str]; let num = str.length; // 保存遍历次数 let obj = &#123;&#125;; // 保存被删元素 for (let i = 0; i &lt; num; i++) &#123; let item = str.splice(0, 1)[0]; // 删除第一个值 if (str.indexOf(item) === -1 &amp;&amp; obj[item] === undefined) &#123; // 当前数组中没有 并且对象中也没有 return item; // 找到 &#125; else &#123; obj[item] = item; // 出现的字符串，用对象保存起来。 &#125; &#125;&#125;;console.log('输出：', firstUniqChar('abaccdeff'), firstUniqChar('aabc')); indexOf 的第二个参数，从当前值往后搜索，并查找之前已经查过的字符 想起了indexOf的第二个参数，省了一步删除的操作。 12345678910111213const firstUniqChar = function(str) &#123; str = [...str]; let obj = &#123;&#125;; for (let [index, key] of str.entries()) &#123; if (str.indexOf(key, index + 1) === -1 &amp;&amp; obj[key] === undefined) &#123; // 跳过这个元素，当后面没有 并且前面也没有 return key; // 找到 &#125; else &#123; obj[key] = key; // 前面出现过 存起来 &#125; &#125;&#125;;console.log('输出：', firstUniqChar('abaccdeff'), firstUniqChar('aabc')); 记录字符出现的次数，遍历字符串，第一个只出现一次的字符，就是要找的值。 12345678910111213141516171819const firstUniqChar = function(str) &#123; var obj = &#123;&#125;; // 用对象 for (var i = 0; i &lt; str.length; i++) &#123; var code = str.charCodeAt(i); // 记录出现的次数 if (obj[code] == undefined) &#123; obj[code] = 1; &#125; else &#123; obj[code]++; &#125; &#125; for (var i = 0; i &lt; str.length; i++) &#123; // 遍历字符串出现的顺序(保证第一次出现重复)，当出现为1时，即找到 if (obj[str.charCodeAt(i)] == 1) &#123; return str.charAt(i); &#125; &#125; return null;&#125;; 鼓励我一下：觉得还不错的话，给我的项目点个star吧]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手摸手教你使用WebSocket[其实WebSocket也不难]]]></title>
    <url>%2F2018%2F10%2F23%2F%E6%89%8B%E6%91%B8%E6%89%8B%E6%95%99%E4%BD%A0%E4%BD%BF%E7%94%A8WebSocket-%E5%85%B6%E5%AE%9EWebSocket%E4%B9%9F%E4%B8%8D%E9%9A%BE%2F</url>
    <content type="text"><![CDATA[前言在本篇文章之前，WebSocket很多人听说过，没见过，没用过，以为是个很高大上的技术，实际上这个技术并不神秘，可以说是个很容易就能掌握的技术，希望在看完本文之后，马上把文中的栗子拿出来自己试一试，实践出真知。 游泳、健身了解一下：博客、前端积累文档、公众号、GitHub WebSocket解决了什么问题：客户端(浏览器)和服务器端进行通信，只能由客户端发起ajax请求，才能进行通信，服务器端无法主动向客户端推送信息。 当出现类似体育赛事、聊天室、实时位置之类的场景时，客户端要获取服务器端的变化，就只能通过轮询(定时请求)来了解服务器端有没有新的信息变化。 轮询效率低，非常浪费资源(需要不断发送请求，不停链接服务器) WebSocket的出现，让服务器端可以主动向服务器端发送信息，使得浏览器具备了实时双向通信的能力,这就是WebSocket解决的问题 一个超简单的栗子：新建一个html文件，将本栗子找个地方跑一下试试，即可轻松入门WebSocket： 12345678910111213141516function socketConnect(url) &#123; // 客户端与服务器进行连接 let ws = new WebSocket(url); // 返回`WebSocket`对象，赋值给变量ws // 连接成功回调 ws.onopen = e =&gt; &#123; console.log('连接成功', e) ws.send('我发送消息给服务端'); // 客户端与服务器端通信 &#125; // 监听服务器端返回的信息 ws.onmessage = e =&gt; &#123; console.log('服务器端返回：', e.data) // do something &#125; return ws; // 返回websocket对象&#125;let wsValue = socketConnect('ws://121.40.165.18:8800'); // websocket对象 上述栗子中WebSocket的接口地址出自：WebSocket 在线测试，在开发的时候也可以用于测试后端给的地址是否可用。 webSocket的class类：当项目中很多地方使用WebSocket，把它封成一个class类，是更好的选择。 下面的栗子，做了非常详细的注释，建个html文件也可直接使用，websocket的常用API都放进去了。 下方注释的代码，先不用管，涉及到心跳机制，用于保持WebSocket连接的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105class WebSocketClass &#123; /** * @description: 初始化实例属性，保存参数 * @param &#123;String&#125; url ws的接口 * @param &#123;Function&#125; msgCallback 服务器信息的回调传数据给函数 * @param &#123;String&#125; name 可选值 用于区分ws，用于debugger */ constructor(url, msgCallback, name = 'default') &#123; this.url = url; this.msgCallback = msgCallback; this.name = name; this.ws = null; // websocket对象 this.status = null; // websocket是否关闭 &#125; /** * @description: 初始化 连接websocket或重连webSocket时调用 * @param &#123;*&#125; 可选值 要传的数据 */ connect(data) &#123; // 新建 WebSocket 实例 this.ws = new WebSocket(this.url); this.ws.onopen = e =&gt; &#123; // 连接ws成功回调 this.status = 'open'; console.log(`$&#123;this.name&#125;连接成功`, e) // this.heartCheck(); if (data !== undefined) &#123; // 有要传的数据,就发给后端 return this.ws.send(data); &#125; &#125; // 监听服务器端返回的信息 this.ws.onmessage = e =&gt; &#123; // 把数据传给回调函数，并执行回调 // if (e.data === 'pong') &#123; // this.pingPong = 'pong'; // 服务器端返回pong,修改pingPong的状态 // &#125; return this.msgCallback(e.data); &#125; // ws关闭回调 this.ws.onclose = e =&gt; &#123; this.closeHandle(e); // 判断是否关闭 &#125; // ws出错回调 this.onerror = e =&gt; &#123; this.closeHandle(e); // 判断是否关闭 &#125; &#125; // heartCheck() &#123; // // 心跳机制的时间可以自己与后端约定 // this.pingPong = 'ping'; // ws的心跳机制状态值 // this.pingInterval = setInterval(() =&gt; &#123; // if (this.ws.readyState === 1) &#123; // // 检查ws为链接状态 才可发送 // this.ws.send('ping'); // 客户端发送ping // &#125; // &#125;, 10000) // this.pongInterval = setInterval(() =&gt; &#123; // this.pingPong = false; // if (this.pingPong === 'ping') &#123; // this.closeHandle('pingPong没有改变为pong'); // 没有返回pong 重启webSocket // &#125; // // 重置为ping 若下一次 ping 发送失败 或者pong返回失败(pingPong不会改成pong)，将重启 // console.log('返回pong') // this.pingPong = 'ping' // &#125;, 20000) // &#125; // 发送信息给服务器 sendHandle(data) &#123; console.log(`$&#123;this.name&#125;发送消息给服务器:`, data) return this.ws.send(data); &#125; closeHandle(e = 'err') &#123; // 因为webSocket并不稳定，规定只能手动关闭(调closeMyself方法)，否则就重连 if (this.status !== 'close') &#123; console.log(`$&#123;this.name&#125;断开，重连websocket`, e) // if (this.pingInterval !== undefined &amp;&amp; this.pongInterval !== undefined) &#123; // // 清除定时器 // clearInterval(this.pingInterval); // clearInterval(this.pongInterval); // &#125; this.connect(); // 重连 &#125; else &#123; console.log(`$&#123;this.name&#125;websocket手动关闭`) &#125; &#125; // 手动关闭WebSocket closeMyself() &#123; console.log(`关闭$&#123;this.name&#125;`) this.status = 'close'; return this.ws.close(); &#125;&#125;function someFn(data) &#123; console.log('接收服务器消息的回调：', data);&#125;// const wsValue = new WebSocketClass('ws://121.40.165.18:8800', someFn, 'wsName'); // 这个链接一天只能发送消息50次const wsValue = new WebSocketClass('wss://echo.websocket.org', someFn, 'wsName'); // 阮一峰老师教程链接wsValue.connect('立即与服务器通信'); // 连接服务器// setTimeout(() =&gt; &#123;// wsValue.sendHandle('传消息给服务器')// &#125;, 1000);// setTimeout(() =&gt; &#123;// wsValue.closeMyself(); // 关闭ws// &#125;, 10000) 栗子里面我直接写在了一起，可以把class放在一个js文件里面,export出去，然后在需要用的地方再import进来，把参数传进去就可以用了。 WebSocket不稳定WebSocket并不稳定，在使用一段时间后，可能会断开连接，貌似至今没有一个为何会断开连接的公论，所以我们需要让WebSocket保持连接状态，这里推荐两种方法。 WebSocket设置变量，判断是否手动关闭连接：class类中就是用的这种方式:设置一个变量，在webSocket关闭/报错的回调中，判断是不是手动关闭的，如果不是的话，就重新连接，这样做的优缺点如下： 优点：请求较少(相对于心跳连接)，易设置。 缺点：可能会导致丢失数据,在断开重连的这段时间中，恰好双方正在通信。 WebSocket心跳机制： 因为第一种方案的缺点，并且可能会有其他一些未知情况导致断开连接而没有触发Error或Close事件。这样就导致实际连接已经断开了，而客户端和服务端却不知道，还在傻傻的等着消息来。 然后聪明的程序猿们想出了一种叫做心跳机制的解决方法： 客户端就像心跳一样每隔固定的时间发送一次ping，来告诉服务器，我还活着，而服务器也会返回pong，来告诉客户端，服务器还活着。 具体的实现方法，在上面class的注释中，将其打开，即可看到效果。 关于WebSocket怕一开始就堆太多文字性的内容，把各位吓跑了，现在大家已经会用了，我们再回头来看看WebSocket的其他知识点。 WebSocket的当前状态:WebSocket.readyState下面是WebSocket.readyState的四个值(四种状态)： 0: 表示正在连接 1: 表示连接成功，可以通信了 2: 表示连接正在关闭 3: 表示连接已经关闭，或者打开连接失败 我们可以利用当前状态来做一些事情，比如上面栗子中当WebSocket链接成功后，才允许客户端发送ping。 1234if (this.ws.readyState === 1) &#123; // 检查ws为链接状态 才可发送 this.ws.send('ping'); // 客户端发送ping&#125; WebSocket还可以发送/接收 二进制数据这里我也没有试过，我是看阮一峰老师的WebSocket教程才知道有这么个东西，有兴趣的可以再去谷歌，大家知道一下就可以。 二进制数据包括：blob对象和Arraybuffer对象，所以我们需要分开来处理。 12345678910111213141516171819202122 // 接收数据ws.onmessage = function(event)&#123; if(event.data instanceof ArrayBuffer)&#123; // 判断 ArrayBuffer 对象 &#125; if(event.data instanceof Blob)&#123; // 判断 Blob 对象 &#125;&#125;// 发送 Blob 对象的例子let file = document.querySelector('input[type="file"]').files[0];ws.send(file);// 发送 ArrayBuffer 对象的例子var img = canvas_context.getImageData(0, 0, 400, 320);var binary = new Uint8Array(img.data.length);for (var i = 0; i &lt; img.data.length; i++) &#123; binary[i] = img.data[i];&#125;ws.send(binary.buffer); 如果你要发送的二进制数据很大的话，如何判断发送完毕： webSocket.bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去： 1234567var data = new ArrayBuffer(10000000);socket.send(data);if (socket.bufferedAmount === 0) &#123; // 发送完毕&#125; else &#123; // 发送还没结束&#125; 上述栗子出自阮一峰老师的WebSocket教程 WebSocket的优点：最后再吹一波WebSocket： 双向通信(一开始说的，也是最重要的一点)。 数据格式比较轻量，性能开销小，通信高效 协议控制的数据包头部较小，而HTTP协议每次通信都需要携带完整的头部 更好的二进制支持 没有同源限制，客户端可以与任意服务器通信 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器 结语看了本文之后，如果还是有点迷糊的话，一定要把文中的两个栗子，新建个html文件跑起来，自己鼓捣鼓捣一下。不然读多少博客/教程都没有用，实践才出真知，切勿纸上谈兵。 希望看完的朋友可以点个喜欢/关注，您的支持是对我最大的鼓励。博客、前端积累文档、公众号、GitHub 以上2018.10.22 参考资料： WebSocket 教程 理解WebSocket心跳及重连机制 WebSocket协议：5分钟从入门到精通]]></content>
  </entry>
  <entry>
    <title><![CDATA[算法_两个字符串是变位词]]></title>
    <url>%2F2018%2F10%2F17%2F%E7%AE%97%E6%B3%95-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%8F%98%E4%BD%8D%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[两个字符串是变位词难度：简单描述：写出一个函数 anagram(s, t) 判断两个字符串是否可以通过改变字母的顺序变成一样的字符串。 样例：给出 s = “abcd”，t=”dcab”，返回 true.给出 s = “aacd”, t = “acdd”, 返回 false.给出 s = “abcd”, t = “dcaba”, 返回 false.给出 s = “abcd”, t = “abce”, 返回 false. 思路分析：想出了两种解法：分别是用对象和用数组。 要注意出现重复字符串的情况：aaccdd这类的。 代码模板：12const anagram = function (s, t) &#123;&#125; 想一想再看答案想一想再看答案想一想再看答案代码： 用对象来接字符，将重复的字符的数量，比较第二个字符串的数量和值 12345678910111213141516171819202122232425const anagram = function (s, t) &#123; if (s.length === t.length) &#123; var obj = &#123;&#125;; for (let key of s) &#123; if (obj[key] === undefined) &#123; obj[key] = 1 // 初始化 &#125; else &#123; obj[key] = obj[key]+1 // 相同的字符 增加数量 &#125; &#125; for (let key of t) &#123; if (obj[key] === undefined) &#123; return false // 出现没有值的情况 直接返回false &#125; else &#123; obj[key] = obj[key]-1 // 将值又减掉 最后全为0 才是正确 &#125; &#125; for (let key in obj) &#123; if(obj[key] !== 0) return false &#125; return true // 每个字符一样 数量也相同 返回true &#125; return false // 数量不同 返回false&#125;console.log(anagram('abcd', 'dcab'), anagram('aacd', 'acdd'), anagram('abcd', 'dcaba'), anagram('abcd', 'abce')) 一个字符串用来匹配，第二个字符串转数组，将找到的字符值设为undefined 1234567891011121314151617const anagram = function (s, t) &#123; if(s.length === t.length)&#123; t = [...t] // 一个字符串用来匹配 for(let key of s)&#123; let index = t.indexOf(key); if(index !== -1)&#123; t[index] = undefined // 找到那个值 设为undefined 下次有重复的 就不会再找到 &#125;else&#123; return false // 没找到即为false &#125; &#125; return true // 数量相等 会全都删光 &#125;else&#123; return false // 数量不等即为false &#125;&#125;console.log(anagram('abcd', 'dcab'), anagram('aacd', 'acdd'), anagram('abcd', 'dcaba'), anagram('abcd', 'abce')) 鼓励我一下：觉得还不错的话，给我的点个star吧]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VsCode添加文件头部注释和函数注释插件-koroFileHeader]]></title>
    <url>%2F2018%2F10%2F16%2FVsCode%E6%B7%BB%E5%8A%A0%E6%96%87%E4%BB%B6%E5%A4%B4%E9%83%A8%E6%B3%A8%E9%87%8A%E5%92%8C%E5%87%BD%E6%95%B0%E6%B3%A8%E9%87%8A%E6%8F%92%E4%BB%B6-koroFileHeader%2F</url>
    <content type="text"><![CDATA[koroFileHeader 一个支持多语言,读取用户设置的自定义模板，通过快捷键添加文件头部注释、在光标处添加函数注释的VsCode插件 language简体中文 | English 一些文档支持语言 插件设置/配置 更新日志 常见问题 简介 文件头部添加注释: 在文件开头添加注释，记录文件信息 支持用户高度自定义注释选项 保存文件的时候，自动更新最后的编辑时间和编辑人 快捷键：window：ctrl+alt+i,mac：ctrl+cmd+i 在光标处添加函数注释: 在光标处自动生成一个注释模板，下方有栗子 支持用户高度自定义注释选项 快捷键：window：ctrl+alt+t,mac：ctrl+cmd+t 快捷键不可用很可能是被占用了,参考这里 支持不同语言的注释格式，如下。 安装在 Vscode 扩展商店中搜索koroFileHeader,点击安装即可。 使用 栗子： 文件头部注释： 在当前编辑文件中使用快捷键:window：ctrl+alt+t/mac：ctrl+cmd+t,即可生成文件头部注释。 函数注释： 将光标放在函数行或者将光标放在函数上方的空白行 使用快捷键window：ctrl+alt+t,mac：ctrl+cmd+t，即可生成函数注释。 事实上，函数注释在文件的任意位置都可生成，这里需要自己控制。 注释模板的设置设置也超方便的，传送门 最后如果觉得还不错的话，就给个 Star ⭐️ 鼓励一下我吧~ 博客、前端积累文档、公众号、GitHub]]></content>
      <categories>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>VsCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法_找到和为零的子数组]]></title>
    <url>%2F2018%2F10%2F14%2F%E7%AE%97%E6%B3%95-%E6%89%BE%E5%88%B0%E5%92%8C%E4%B8%BA%E9%9B%B6%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[找到和为零的子数组难度：简单描述：给定一个整数数组，找到和为零的子数组。你的代码应该返回满足要求的子数组的起始位置和结束位置 样例：给出 [-3, 1, 2, -3, 4]，返回[0, 2] 或者 [1, 3] 代码模板：12345/** * @param nums: A list of integers * @return: A list of integers includes the index of the first number and the index of the last number */const subarraySum = function(nums) &#123;&#125;; 想一想再看答案想一想再看答案想一想再看答案代码：1234567891011121314151617const subarraySum = function(nums) &#123; let [total, res] = [0, []]; // 和,结果 for (let i = 0; i &lt; nums.length; i++) &#123; res = []; res[0] = i; // 保存起始位置 // 需要第二层循环 可能第一个元素直到最后和也不是0 那么需要从第二个元素再找 以此类推 for (let j = i; j &lt; nums.length; j++) &#123; total = total - nums[j]; // 不断减去每个元素 直到结果为0 if (total === 0) &#123; res[1] = j; // 保存第二个下标 return res; // 返回起始和结束的下标 &#125; &#125; &#125; return false; // 没找到&#125;;console.log(subarraySum([-3, 1, 2, -3, 4])); 鼓励我一下：觉得还不错的话，给我的点个star吧]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长单词]]></title>
    <url>%2F2018%2F10%2F14%2F%E7%AE%97%E6%B3%95_%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[数组中的最长单词难度：简单描述：给一个数组，找出其中所有最长的单词。 样例： 1234567[ "dog", "google", "facebook", "internationalization", "blabla"] 最长的单词集合为 [&quot;internationalization&quot;] 123456[ "like", "love", "hate", "yes"] 最长的单词集合为 [&quot;like&quot;, &quot;love&quot;, &quot;hate&quot;] 思路分析：主要要注意一下第二个栗子中描述的情况，建议保存当前字符最大的长度，然后及时更新。 代码模板：12const Solution = (arr) =&gt; &#123;&#125; 想一想再看答案想一想再看答案想一想再看答案代码：123456789101112131415161718192021222324252627282930313233const Solution = (arr) =&gt; &#123; let store = &#123; arr: [], // 保存最长单词的数组 max: 1 // 字符串最大长度 &#125; arr.forEach(val =&gt; &#123; // 当前值的长度 超过或等于 最大字符串长度 if (val.length &gt;= store.max) &#123; if (val.length === store.max) &#123; // 长度一样 将值添加进去 return store.arr.push(val); // 退出循环 &#125; store.arr = []; // 最大值比之前的大，清空原数组 store.arr.push(val); // 添加到数组 store.max = val.length; // 更新最大值 &#125; &#125;); return store.arr; // 返回数组&#125;let data1 = [ "like", "love", "yes", "hate"]let data2 = [ "dog", "google", "facebook", "internationalization", "blabla"]console.log(Solution(data1), Solution(data2)) 鼓励我一下：觉得还不错的话，给我的点个star吧]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法_爬楼梯]]></title>
    <url>%2F2018%2F10%2F10%2F%E7%AE%97%E6%B3%95-%E7%88%AC%E6%A5%BC%E6%A2%AF%2F</url>
    <content type="text"><![CDATA[爬楼梯难度：简单描述：假设你正在爬楼梯，需要 n 步你才能到达顶部。但每次你只能爬一步或者两步，你能有多少种不同的方法爬到楼顶部？ 样例：比如 n=3，1+1+1=1+2=2+1=3，共有 3 种不同的方法 返回 3 思路分析：这类题我们首先要来找其中的规律，找到了里面的规律，剩下的就好办了。 我再列举出几个结果： 1234560 =0 0种方法1 = 1 种方法2 = 1+1 =2 2种方法3=1+1+1=1+2=2+1 3种方法4 = 1*4 = 1+2+1 = 1+1+2 = 2+1+1 = 2+2 5种方法5 = 1*5 = 2+1+2 =2+2+1 = 1+2+2 =1+2+1+1 = 1+1+2+1 = 2+1+1+1 = 1+1+1+2 8种方法 想一下他们的规律，试着自己做出来。 代码模板：12345/** * @param n: An integer * @return: An integer */const climbStairs = function(n) &#123;&#125;; 想一想再看答案想一想再看答案想一想再看答案规律：这道题的规律实际上跟之前做的查找斐波纳契数列中第 N 个数中的规律有点类似。 :::tip 斐波纳契数列中第 N 个数的规律前 2 个数是 0 和 1,第 i 个数是第 i-1 个数和第 i-2 个数的和。::: 本题中的规律是： 除了 1 阶楼梯和 2 阶楼梯是一种和两种方法之外，第 n 阶的楼梯的方法是第 i-1 阶楼梯和第 i-2 阶楼梯所用方法的和。 代码：解题的核心就是逐步推导，推导出n前面的两个值。 数组： 12345678const climbStairs = function(n) &#123; let dp = [0, 1, 2]; // 初始数组 前面三个没有规律 for (let i = 3; i &lt;= n; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2]; // 从3开始都是可以由前面两个元素相加推导出来 &#125; return dp[n];&#125;;console.log(climbStairs(3), climbStairs(4), climbStairs(5)); 递归： 12345678910const climbStairs = function(n) &#123; function item(n) &#123; // 循环退出条件 if (n === 1) return 1; if (n === 2) return 2; return item(n - 1) + item(n - 2); // 将递归到1个楼梯和两个楼梯 最后反推到n个楼梯 &#125; return item(n);&#125;;console.log(climbStairs(3), climbStairs(4), climbStairs(5)); 交换变量： 实际上我们只需要 n 之前的两个值，就可以求出 n 所用的方法，所以我们没必要将 n 之前的所有值都推导出来。 所以我们只需要保存这两个值，然后再求出第三个值就可以了。 12345678910111213141516const climbStairs = function(n) &#123; // 前两个值的返回结果 if (n === 1) return 1; if (n === 2) return 2; let a = 1, // 1阶楼梯 b = 2, // 2阶楼梯 c; for (let i = 3; i &lt;= n; i++) &#123; c = a + b; // n的结果 // 为了后续推导，不断保存前两个值 a = b; b = c; &#125; return c;&#125;;console.log(climbStairs(3), climbStairs(4), climbStairs(5)); 实际上，我们也可以使用 ES6 的交换变量方法，而不用声明第三个变量： 123456789101112const climbStairs = function(n) &#123; // 前两个值的返回结果 if (n === 1) return 1; if (n === 2) return 2; let a = 1, b = 2; for (var i = 3; i &lt;= n; i++) &#123; [a, b] = [b, b + a]; &#125; return b;&#125;;console.log(climbStairs(3), climbStairs(4), climbStairs(5)); 鼓励我一下：觉得还不错的话，给我的点个star吧]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法_落单的数]]></title>
    <url>%2F2018%2F10%2F07%2F%E7%AE%97%E6%B3%95-%E8%90%BD%E5%8D%95%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[落单的数难度：简单描述：给出 2*n + 1 个的数字，除其中一个数字之外其他每个数字均出现两次，找到这个数字。 样例：给出 [1,2,2,1,3,4,3]，返回 4 给出 [7, 10001, 10002, 10003, 10001, 10002, 10003, 10004, 7, 10004, 91985345, 2, 2, 3, 4, 5, 5, 4, 3, 11, 91985345],返回11 思路分析：有很多解决方式，建议用indexOf来查找是否有值。 代码模板：123456/** * @param A: An integer array * @return: An integer */const singleNumber = function (A) &#123;&#125; 想一想再看答案想一想再看答案想一想再看答案代码： 转对象，如果第二次出现，删除该值，最后只剩一个值 12345678910111213141516const singleNumber = function (A) &#123; let [obj, res] = [&#123;&#125;, []]; for (let index of A.keys()) &#123; if (obj[A[index]] !== undefined) &#123; // 判断出现次数 // 第二次出现 let test = A[index]; delete res[obj[A[index]]]; // 删除数组元素 变为undefined &#125; else &#123; // 第一次出现 res.push(A[index]); // 数组元素添加进去 obj[A[index]] = res.length - 1; // 保存下标 用于等下删除第二次出现的元素 &#125; &#125; return Number(res.join('')); // 转成字符串 最终只有一个值输出&#125;console.log(singleNumber([1, 2, 2, 1, 3, 4, 3]), singleNumber([7, 10001, 10002, 10003, 10001, 10002, 10003, 10004, 7, 10004, 91985345, 2, 2, 3, 4, 5, 5, 4, 3, 11, 91985345])); 查找该值的前后是否有该值，如果没有，即找到落单的值 123456789101112const singleNumber = function (A) &#123; var b = [] for (var i = 0; i &lt; A.length; i++) &#123; var v = A[i] // 如果b数组中没有v(没有push过 代表前面没有v)并且A数组在后面也没有该值(也就是后面也没有v) if (b.indexOf(v) === -1 &amp;&amp; A.indexOf(v, i + 1) === -1) &#123; return v // 前面没有v 后面也没有v 即是唯一的值 &#125; b.push(v); // 添加v &#125;&#125;console.log(singleNumber([1, 2, 2, 1, 3, 4, 3]), singleNumber([7, 10001, 10002, 10003, 10001, 10002, 10003, 10004, 7, 10004, 91985345, 2, 2, 3, 4, 5, 5, 4, 3, 11, 91985345])); 转成本地变量操作，将该值删除，再查找是否有该值，如果没有即找到该值 12345678910const singleNumber = function (A) &#123; for (var i = 0; i &lt; A.length; i++) &#123; var s = [].concat(A) // 转成本地变量 s.splice(i, 1) // 将该值删除 if (s.indexOf(A[i]) === -1) &#123; // 被删过一次 再查找是否还有这个值 return A[i] // 如果没有的话 即找到该值 &#125; &#125;&#125;console.log(singleNumber([1, 2, 2, 1, 3, 4, 3]), singleNumber([7, 10001, 10002, 10003, 10001, 10002, 10003, 10004, 7, 10004, 91985345, 2, 2, 3, 4, 5, 5, 4, 3, 11, 91985345])); 鼓励我一下：觉得还不错的话，给我的点个star吧]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法_中位数]]></title>
    <url>%2F2018%2F09%2F30%2F%E7%AE%97%E6%B3%95-%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[中位数难度：简单描述：给定一个未排序的整数数组，找到其中位数。 中位数是排序后数组的中间值，如果数组的个数是偶数个，则返回排序后数组的第 N/2 个数。 样例：给出数组[4, 5, 1, 2, 3]， 返回 3 给出数组[7, 9, 4, 5]，返回 5 思路分析： 升序排序数组 模拟几个数组的返回值，找到里面的规律，找出数组中对应元素。 代码模板：12345/** * @param nums: A list of integers * @return: An integer denotes the middle number of the array */const median = function(nums) &#123;&#125;; 想一想再看答案想一想再看答案想一想再看答案代码： 判断奇数偶数，找到对应的下标 12345678910111213141516/** * @param nums: A list of integers * @return: An integer denotes the middle number of the array */const median = function(nums) &#123; nums.sort((a, b) =&gt; &#123; return a - b; // 升序排序 &#125;); var num = nums.length; // 保存数组长度 if (num % 2 !== 0) &#123; // 判断奇数偶数 return nums[(num + 1) / 2 - 1]; // 奇数转偶数 &#125; else &#123; return nums[num / 2 - 1]; // 减一 对应数组下标 &#125;&#125;; 奇数上舍入，找到下标 两种写法一样，但无疑第二种写法更为优雅。 12345678/** * @param nums: A list of integers * @return: An integer denotes the middle number of the array */const median = function(nums) &#123; nums.sort((v1, v2) =&gt; v1 - v2); return nums[Math.ceil(nums.length / 2) - 1]; // &#125;; 鼓励我一下：觉得还不错的话，给我的点个star吧]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法_两数之和]]></title>
    <url>%2F2018%2F09%2F29%2F%E7%AE%97%E6%B3%95-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[两数之和难度：简单描述：给一个整数数组，找到两个数使得他们的和等于一个给定的数 target。 你需要实现的函数 twoSum 需要返回这两个数的下标, 并且第一个下标小于第二个下标。注意这里下标的范围是 0 到 n-1。 样例：给出 numbers = [2, 7, 11, 15], target = 9, 返回 [0, 1]. 给出 numbers = [2, 33, 11, 2], target = 4, 返回 [0, 3]. 思路分析：target减去每个元素的值，得出来的值，就是我们要搜索的值。 代码模板：123456/** * @param numbers: An array of Integer * @param target: target = numbers[index1] + numbers[index2] * @return: [index1, index2] (index1 &lt; index2) */const twoSum = function(numbers, target) &#123;&#125;; 想一想再看答案想一想再看答案想一想再看答案代码： 转成对象： 这是别人的一种解法，比下面的解法复杂点，可以看看，扩展一下思路。 12345678910111213141516171819202122/** * @param numbers: An array of Integer * @param target: target = numbers[index1] + numbers[index2] * @return: [index1, index2] (index1 &lt; index2) */const twoSum = function(numbers, target) &#123; let map = &#123;&#125;; // key : the complement (target - num) // value: index for that num for (let i = 0; i &lt; numbers.length; i++) &#123; const num = numbers[i]; if (map[num] !== undefined) &#123; // 找到值 return [map[num], i]; // 第一次保存的index 和 刚找到的下标 即结果。 &#125; else &#123; // 第一次进入 保存 要搜索的值和index map[target - num] = i; // 第一次 &#125; &#125; return [-1, -1];&#125;;console.log(twoSum([2, 7, 11, 15], 9), twoSum([2, 33, 11, 2], 4)); 双循环 12345678910const twoSum = function(numbers, target) &#123; for (let index of numbers.keys()) &#123; let res = target - numbers[index]; // 要搜索的值 for (let i = numbers.length - 1; i &gt; index; i--) &#123; // 倒序查找，跳过已经遍历过的值 if (res === numbers[i]) return [index, i]; // 搜索到了 即找到 &#125; &#125;&#125;;console.log(twoSum([2, 7, 11, 15], 9), twoSum([2, 33, 11, 2], 4)); indexOf() indexOf的第二个参数是开始搜索的位置，也可以跳过前面已经搜索过的值。 12345678910const twoSum = function(numbers, target) &#123; for (let index of numbers.keys()) &#123; let res = target - numbers[index]; // 相减 let search = numbers.indexOf(res, index + 1); // 跳过前面已经搜索过的，防止2+2=4 搜索两个2在同一个位置 if (search !== -1) &#123; return [index, search]; // 直接返回值 &#125; &#125;&#125;;console.log(twoSum([2, 7, 11, 15], 9), twoSum([2, 33, 11, 2], 4)); 鼓励我一下：觉得还不错的话，给我的点个star吧]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法_比较字符串]]></title>
    <url>%2F2018%2F09%2F27%2F%E7%AE%97%E6%B3%95_%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[比较字符串难度：简单描述：比较两个字符串 A 和 B，确定 A 中是否包含 B 中所有的字符。字符串 A 和 B 中的字符都是 大写字母 样例：给出 A = “ABCD” B = “ACD”，返回 true 给出 A = “ABCD” B = “AABC”， 返回 false 代码模板：123456/** * @param A: A string * @param B: A string * @return: if string A contains all of the characters in B return true else return false */const compareStrings = function(A, B) &#123;&#125;; 思路分析：将字符串转成数组来处理 想一想再看答案想一想再看答案想一想再看答案代码：123456789101112const compareStrings = function(A, B) &#123; [A, B] = [[...A], [...B]]; // 转成数组操作 for (let index of B.keys()) &#123; if (A.indexOf(B[index]) !== -1) &#123; // B数组元素和A数组元素成功匹配 A.splice(find, 1); // 删除A数组中已匹配到的，保持数量相等 &#125; else &#123; return false; // B数组中有A不包含的字符串 &#125; &#125; return true;&#125;; 鼓励我一下：觉得还不错的话，给我的点个star吧]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法_最大子数组]]></title>
    <url>%2F2018%2F09%2F27%2F%E7%AE%97%E6%B3%95-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[最大子数组难度：简单描述：给定一个整数数组，找到一个具有最大和的子数组，返回其最大和。 样例：给出数组[−2,2,−3,4,−1,2,1,−5,3]，符合要求的子数组为[4,−1,2,1]，其最大和为 6 思路分析：本题只要找出最大和即可，保存两个值，一个为元素之间相加的值(需比较元素相加的值与当前元素的大小)，一个为最大值。 代码：12345678910111213/** * @param nums: A list of integers * @return: A integer indicate the sum of max subarray */const maxSubArray = function(nums) &#123; let max = nums[0]; // 初始化最大值 let newMax = nums[0]; // 数组元素相加的缓存值 for (let i = 1; i &lt; nums.length; i++) &#123; newMax = Math.max(newMax + nums[i], nums[i]); // 相加是否大于当前值 max = Math.max(newMax, max); // 与最大值相比 &#125; return max;&#125;; 第二种方法更难理解点，可以扩展一下思路： 12345678910111213141516/** * @param nums: A list of integers * @return: A integer indicate the sum of max subarray */const maxSubArray = function(nums) &#123; var nSum = nums[0]; // 数组元素相加的缓存值 var nMax = nSum; // 初始化最大值 for (var i = 1; i &lt; nums.length; i++) &#123; var curNum = nums[i]; // 当前元素 if (curNum &gt;= 0) nSum = nSum &gt; 0 ? nSum + curNum : curNum; // 如果两个值都大于0 两个值相加。否则就取后一个大于0的 else nSum = nSum &lt; curNum ? curNum : nSum + curNum; // 如果新加的值小于0 判断结果是否大于新加的值 小于的话就改为新加的值 nMax = Math.max(nMax, nSum); // 最大值与数组元素相加值比较 &#125; return nMax;&#125;; 最大和的数组：如果你想把最大和的数组都找出来，你需要保存数组的开始下标和结束下标，这里我演示了第一个方法，下面那个方法也是一样： 1234567891011121314151617181920212223242526272829303132const maxSubArray = function(nums) &#123; let max = &#123; num: nums[0], start: 0, end: 1 // 结束的下标 后面要切割数组 需比当前下标+1.把当前值也切割 &#125;; let newMax = &#123; num: nums[0], start: 0, end: 1 &#125;; for (let i = 1; i &lt; nums.length; i++) &#123; if (newMax.num + nums[i] &gt; nums[i]) &#123; // 相加大于当前值 缓存改值和结束下标 newMax.num = newMax.num + nums[i]; newMax.end = i + 1; &#125; else &#123; // 小于当前值 重置start end newMax.num = nums[i]; newMax.start = i; newMax.end = i + 1; &#125; // 最大值被超过 把值赋给最大值 if (max.num &lt; newMax.num) &#123; max.num = newMax.num; max.start = newMax.start; max.end = newMax.end; &#125; &#125; let arr = nums.slice(max.start, max.end); // 找出最大和的子数组 return max.num; // 子数组的最大和&#125;; 觉得还不错的话，给我的点个star吧]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法_字符串密钥格式]]></title>
    <url>%2F2018%2F09%2F24%2F%E7%AE%97%E6%B3%95_%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%86%E9%92%A5%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[字符串密钥格式难度：简单描述： 给定字符串 S(非空)，字符串 S 仅由字母数字字符（a-z 和/或 A-Z 和/或 0-9）和短划线（ - ）组成。 给定正整数 K，我们希望重新格式化字符串，使得每个组包含正好的 K 个字符，但第一个组可能比 K 短，但仍必须包含至少一个字符。 必须在两个组之间插入短划线，并且所有小写字母都应转换为大写 样例：Input: S = “5F3Z-2e-9-w”, K = 4 Output: “5F3Z-2E9W” Input: S = “2-5g-3-J”, K = 2 Output: “2-5G-3J” 思路分析：处理字符串通常需要转成数组来处理，仔细观察输出和规则，总结规律。 代码： 去掉-，等下用join连接。 字符串长度不能被K整除的话，需取余，将不能整除的部分拿出来。 然后每隔几个K每割一下字符串，这里用了正则，返回一个数组。 再跟之前被拿出来的部分，合并成一个数组。 用join将数组转成字符串。 123456789101112131415161718192021222324252627282930const licenseKeyFormatting = function(S, K) &#123; S = S.replace(/-/g, ''); // 去掉所有的- let total = [...S].length; // 字符串总数 let num = total % K; // 取余 let strArr = []; // 字符串剩余的放在这个数组中 // 字符串余数 if (num !== 0) &#123; var str = ''; var arr = [...S]; var i = 0; for (let item of arr.keys()) &#123; i++; str += arr[item]; // 有多少个余数就将多少个字符 添加到字符串中 if (i === num) break; &#125; arr.splice(0, num); // 删除已被添加的字符 S = arr.join(''); // S重新变为字符串 用于下面操作 strArr[0] = str; // 添加到数组 等下用于连接 &#125; let spliceNum = `\\w&#123;$&#123;K&#125;&#125;`; // 几个字符串为一个间隔 let reg = new RegExp(spliceNum, 'gim'); let strArr2 = S.match(reg); // 切割字符串返回数组 strArr = strArr.concat(strArr2); // 连接余数数组和切割的数组 S = strArr.join('-').toUpperCase(); // 连接字符串 并转为大写 return S;&#125;;console.log( licenseKeyFormatting('5F3Z-2e-9-w', 4), licenseKeyFormatting('2-5g-3-J', 2));]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法_搜索二维矩阵&分解质因数]]></title>
    <url>%2F2018%2F09%2F23%2F%E7%AE%97%E6%B3%95_%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[搜索二维矩阵难度：简单描述：写出一个高效的算法来搜索 m × n 矩阵中的值。 这个矩阵具有以下特性： 每行中的整数从左到右是从小到大排序的。 每行的第一个数大于上一行的最后一个整数。 样例：12345[ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]] 给出 target = 3，返回 true 题目分析：双循环找出是否有这个值，根据第二个特性，我们可以跳过一些第二层循环，算法更具效率。 代码：123456789101112131415161718192021/** * @param matrix: matrix, a list of lists of integers * @param target: An integer * @return: a boolean, indicate whether matrix contains target */const searchMatrix = function(matrix, target) &#123; for (let key of matrix.keys()) &#123; // 遍历外层数组 let value = matrix[key]; // 拿到每行元素 // 判断target是否在当前行中，跳过其他不必要循环 if (target &lt;= value[value.length - 1]) &#123; for (let item of value.keys()) &#123; // 遍历行中元素 if (target === value[item]) &#123; // 找到值 return true; &#125; else if (target &lt; value[item]) &#123; // 值超过target即找不到(因为是排序的) return false; &#125; &#125; &#125; &#125; return false; // 没有找到即返回false&#125;; 分解质因数难度：简单质因数的定义：能整除给定正整数的质数。 百度百科：质因数 描述： 将一个整数分解为若干质因数之乘积 你需要从小到大排列质因子 样例： 给出 10, 返回 [2, 5] 给出 660, 返回 [2, 2, 3, 5, 11] 题目分析：从小到大排列质因子，需要将同一个质因子整除干净。 比如：20 可以被 2 整除两次。 提示：需要两层循环。 代码：123456789101112131415// 分解质因数const primeFactorization = function(num) &#123; let res = []; // 不需要判定i是否为质数，如果i不为质数，且能整除num时，num早被i的因数所除。故能整除num的i必是质数。 // i * i &gt; num 退出循环 num一开始会在第二层循环被i整除成比较小的数字 for (let i = 2; i * i &lt;= num; i++) &#123; while (num % i === 0) &#123; // 直到有余数退出循环 num = num / i; // 改变num res.push(i); // 没有余数 能整除 这一步会找出所有质因数 不会出现4的那种情况 &#125; &#125; if (num !== 1) res.push(num); // num到最后也是质因数 return res;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法_数组重复次数最多的元素&合并排序数组]]></title>
    <url>%2F2018%2F09%2F23%2F%E7%AE%97%E6%B3%95_%E6%95%B0%E7%BB%84%E9%87%8D%E5%A4%8D%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%85%83%E7%B4%A0-%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[找出数组重复次数最多的元素难度：入门描述：给定一个字符串数组, 每一个元素代表一个 IP 地址，找到出现频率最高的 IP。 注：给定数据只有一个频率最高的 IP 样例：12lines = ['192.168.1.1', '192.118.2.1', '192.168.1.1'];return '192.168.1.1'; 题目分析：说了一堆，其实就是找出数组重复次数最多的元素 思路： 用对象来处理，将元素赋值到属性上，判断之前有没有这个属性。 这个方法数组去重的缺点： 虽然对象属性同样可以用来做数组去重，但是会将 number,NaN,undefined,null，变为字符串形式，因为对象的属性名就是一个字符串 代码：123456789101112131415161718192021/** * @param ipLines: ip address * @return: return highestFrequency ip address */const highestFrequency = function(ipLines) &#123; var [obj, max, name] = [&#123;&#125;, 1, '']; ipLines.forEach(value =&gt; &#123; if (obj[value]) &#123; // 已经有值了 就把值+1 obj[value]++; if (obj[value] &gt; max) &#123; // 判断重复次数有没有超过当前最高的 max = obj[value]; // 重复次数 name = value; // 当前元素 &#125; &#125; else &#123; // 没有值 就初始化一个值 obj[value] = 1; &#125; &#125;); return name;&#125;; 合并排序数组难度：简单描述：合并两个排序的整数数组 A 和 B 变成一个新的排序数组。 样例：给出A=[1,2,3,4]，B=[2,4,5,6]，返回 [1,2,2,3,4,4,5,6] 题目分析：注意 A 和 B 本来就是排序好的数组，最简单的就是用sort排序了。 sort排序 把两个数组合并成一个数组 用 sort 升序进行排序。 123456const mergeSortedArray = function(A, B) &#123; let newArr = A.concat(B); // 合并数组 return newArr.sort((a, b) =&gt; &#123; return a - b; // sort排序 &#125;);&#125;; 先对比完一个数组： 初始两个变量分别对应一个数组，进入循环 i 和 j 不会同时递增，只在对应数组元素打败另一数组元素时才会递增，只要打败一个即可，因为两个数组一开始就是排序好的 i 和 j 必须有一个超过对应数组长度(这样至少有一个数组的元素被逐一比较过) 如果一个数组那边超过长度，会退出循环，但是可能由一方的长度还有剩余（比如一个元素打败另一数组的所有元素），所以我们需要将长度有剩余的数组剩下的元素全都 push 到新数组中(因为一开始就排序好的，后面出场的只会更强) 1234567891011121314151617181920212223const mergeSortedArray = function(A, B) &#123; var i, j; var arr = []; for (i = 0, j = 0; i &lt; A.length &amp;&amp; j &lt; B.length; ) &#123; // i或者j必须有一个超过对应数组长度 才退出循环 所以至少有一个数组的元素被逐一比较 if (A[i] &lt; B[j]) &#123; // 下面两种写法是一样的 arr.push(A[i]); i++; &#125; else &#123; arr.push(B[j++]); // 这里会先把j赋值给B[j]， 然后再j++ &#125; &#125; // 上面至少有一个数组已经比较了每个元素 如果还有一方长度有剩余 直接push进来就可以(AB一开始就是排序好的数组) while (i &lt; A.length) &#123; arr.push(A[i++]); &#125; while (j &lt; B.length) &#123; arr.push(B[j++]); &#125; return arr;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VsCode读取项目文件的Eslint规则 保存时自动修复格式错误]]></title>
    <url>%2F2018%2F09%2F16%2FVsCode%E8%AF%BB%E5%8F%96%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E7%9A%84Eslint%E8%A7%84%E5%88%99-%E4%BF%9D%E5%AD%98%E6%97%B6%E8%87%AA%E5%8A%A8%E4%BF%AE%E5%A4%8D%E6%A0%BC%E5%BC%8F%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[前言：同一个项目，保持代码风格的一致，是非常重要的一个规范。但事实上项目小组成员的代码校验规则、格式化工具通常都不一致，为了避免项目到后期出现无法维护的问题，项目成员使用同一套校验规则，同一个格式化方式是相当好的步骤之一。 个人博客了解一下：obkoro1.com 保存时自动统一代码风格：先通过一些简单的配置，然后： Ctrl+s / command+s 时自动修复代码的格式错误 自动修复的规则是读取项目根目录的Eslint规则 这样就能保证项目成员都是一套验证规则的代码风格 配置：1.安装VsCode的EsLint和vetur插件如图安装EsLint插件： 2.为项目安装EsLint包： 注意要安装在开发环境上，还有就是如果你使用的是脚手架的话，选了Eslint选项，会自带这些包。 3.在项目的根目录下添加.eslintrc.js用于校验代码格式，根据项目情况，可自行编写校验规则： 123module.exports = &#123; // Eslint规则&#125; 4.首选项设置：将下面这部分放入首选项设置中： &quot;eslint.autoFixOnSave&quot;: true, // 启用保存时自动修复,默认只支持.js文件 &quot;eslint.validate&quot;: [ &quot;javascript&quot;, // 用eslint的规则检测js文件 { &quot;language&quot;: &quot;vue&quot;, // 检测vue文件 &quot;autoFix&quot;: true // 为vue文件开启保存自动修复的功能 }, { &quot;language&quot;: &quot;html&quot;, &quot;autoFix&quot;: true }, ], 想了解更多的话，推荐看一下VsCode的EsLint插件 大功告成：点开文件，你可能会看到如下报错，无需一个一个去改，只要保存一下文件，就可以自动修复这些代码格式上的问题了。 注意： 如果整个文件都飘红的话，不会一次性修改如果的格式问题，会一下改一部分，你可能需要多按几次保存。 一键修复项目格式问题：遇到下面这两种情况： 你刚刚引入这个自动修复，但你项目的文件比较多，且你又比较懒。 隔一段时间，修复一下代码格式上的问题 你可以像下面这样，在package.json里面的scripts里面新增一条如下命令： &quot;lint&quot;: &quot;eslint --ext .js,.vue src --fix&quot; --ext后面跟上的.js、.vue是你要检测文件的后缀，.vue后面的src是要检测的哪个目录下面的文件。 --fix的作用是自动修复根据你配置的规则检测出来的格式问题 一键修复: 输入如下命令行，就可以自动修复你src文件夹下面的所有根据你配置的规则检测出来的格式问题。 npm run lint .eslintignore 不检测一些文件：在项目的根目录创建一个.eslintignore文件，用于让EsLint不检测一些文件。 比如引的一些别人的文件，插件等,比如文件中： src/test/* src/test2/* 文件中的内容像上面这样写，这里第一行是不检测src目录下的test文件夹下面的所有文件。 自定义规则：// .eslintrc.js文件 module.exports = { &quot;rules&quot;: { // 自定义规则 &quot;no-console&quot;: 0, &quot;no-const-assign&quot;: 1, &quot;no-extra-bind&quot;: 2, } } 0、1、2的意思： &quot;off&quot; 或 0 - 关闭这项规则 &quot;warn&quot; 或 1 - 将规则视为一个警告 &quot;error&quot; 或 2 - 将规则视为一个错误 结语设置如上，很快就能弄好，赶紧在团队中用起来吧！ 使用自动VsCode+EsLint格式化代码，在团队内部相互去看别人的代码的时候，就可以更容易的看的懂，能够极大的降低团队的沟通成本和提高心情。 希望看完的朋友可以点个喜欢/关注，您的支持是对我最大的鼓励。个人blog and 前端积累文档，如需转载，请放上原文链接并署名。码字不易，感谢支持！ 如果喜欢本文的话，欢迎扫描关注我的订阅号，最新文章，面试题等都将第一时间发布在订阅号上。 以上2018.9.16]]></content>
      <categories>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>VsCode</tag>
        <tag>Eslint</tag>
        <tag>团队协作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法(入门)_水仙花数&反转一个3位整数]]></title>
    <url>%2F2018%2F09%2F12%2F%E7%AE%97%E6%B3%95-%E5%85%A5%E9%97%A8%E4%B8%A4%E7%AF%87-%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0-%E5%8F%8D%E8%BD%AC%E4%B8%80%E4%B8%AA3%E4%BD%8D%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[水仙花数水仙花数的定义：一个 N 位非负整数，其各位数字的 N 次方和等于该数本身。 栗子： 153 = 13^3 + 53^3 + 33^3 370 = 3^3 + 7^3 + 0^3 371 = 3^3 + 7^3 + 1^3 1634 = 14^4 + 64^4 + 34^4 + 44^4。 更详细的推荐：维基百科 描述：给出n，找到所有的n位十进制水仙花数。 样例：比如 n = 1, 所有水仙花数为：[0,1,2,3,4,5,6,7,8,9]。 而对于 n = 2, 则没有 2 位的水仙花数，返回 []。 题目分析:弄懂水仙花数！ 判断一个数是否为水仙花数：要找出水仙花数，首先我们需要能识别一个数是否为水仙花数： 1234567891011121314// 判断一个数是否为水仙花数const isTrue = num =&gt; &#123; const n = num.toString().length; // 数的长度 const str = num.toString(); // 转字符 等下取数字 let total = 0; // 总数 for (let i = 0; i &lt; n; i++) &#123; total += Math.pow(str.charAt(i), n); // 转字符串一个字符一个字符拿出来 计算其各位数字的N次方和 &#125; if (num === total) &#123; return true; // 最终相等 即为正确 &#125; else &#123; return false; &#125;&#125;; 找出所有的n位十进制水仙花数 确定查找的范围(找出n位的最大值与最小值) 遍历每个数，判断为水仙花数，添加到数组中 1234567891011121314151617181920const getNarcissisticNumbers = n =&gt; &#123; let min = Math.pow(10, n - 1), max = Math.pow(10, n), arr = []; if (n === 1) &#123; // n == 1的时候，min应该等于0，但是min等于1,所以这边手动判断一下。 min = 0; &#125; for (let j = min; j &lt; max; j++) &#123; const str = j.toString(); // 转字符 let total = 0; for (let i = 0; i &lt; n; i++) &#123; // 判断一个数是否为水仙花数 total += Math.pow(str.charAt(i), n); // 转字符串一个字符一个字符拿出来 计算其各位数字的N次方和 &#125; if (j === total) &#123; arr.push(j); &#125; &#125; return arr;&#125;; 注意： 查找位数过大会出现性能问题，以及最大值溢出问题。 反转一个 3 位整数描述：反转一个只有 3 位数的整数 样例：123 反转之后是 321。900 反转之后是 9。 题目分析： 009这种形式需要转为9 最后输出的数字。 转数组操作:这是最简单，最容易想到的答案： 数字转成字符串再转成数组 颠倒数组(翻转了),恢复成字符串 输出正常数字，这里用了+号。(用parseInt等也是可以的) 123const reverseInteger = function(number) &#123; return +[...number.toString()].reverse().join('');&#125;; 取余数，逐个颠倒123const reverseInteger = function (number) &#123; return parseInt(number%10)*100+parseInt((number%100)/10)*10+parseInt(number/100)*1&#125; 通过取余操作，个位转百位，十位转十位，百位转个位。 比如：123=&gt;300+20+1,输出321 拼接字符串： 数字转字符串 从后往前取对应位置字符,拼接成一个颠倒的字符串 1234const reverseInteger = function(number) &#123; var str = number.toString(); // 转字符 return parseInt(str.charAt(2) + str.charAt(1) + str.charAt(0)); // 取对应位置字符，拼接成新的字符串&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VuePress 手摸手教你搭建一个类Vue文档风格的技术文档/博客]]></title>
    <url>%2F2018%2F09%2F09%2FVuePress-%E6%89%8B%E6%91%B8%E6%89%8B%E6%95%99%E4%BD%A0%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B1%BBVue%E6%96%87%E6%A1%A3%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3-%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言：VuePress是尤大为了支持 Vue 及其子项目的文档需求而写的一个项目，VuePress界面十分简洁，并且非常容易上手，一个小时就可以将项目架构搭好。现在已经有很多这种类型的文档，如果你有写技术文档的项目的话，VuePress绝对可以成为你的备选项之一。 VuePress特性： 为技术文档而优化的 内置 Markdown 拓展 在 Markdown 文件中使用 Vue 组件的能力 Vue 驱动的自定义主题系统 自动生成 Service Worker Google Analytics 集成 基于 Git 的 “最后更新时间” 多语言支持 默认主题包含： 建议先看一下官方文档 效果：可能你会搭建出一个类似这样的文档： 搭建：全局安装VuePressyarn global add vuepress # 或者：npm install -g vuepress 新建文件夹可以手动右键新建，也可以使用下面的命令新建文件夹： mkdir project 项目初始化进入到project文件夹中，使用命令行初始化项目: yarn init -y # 或者 npm init -y 将会创建一个package.json文件，长这样子： { &quot;name&quot;: &quot;project&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; }, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot; } 在project的根目录下新建docs文件夹：这个文档将作为项目文档的根目录来使用： mkdir docs 在docs文件夹下创建.vuepress文件夹：mkdir .vuepress 所有 VuePress 相关的文件都将会被放在这里 在.vuepress文件夹下面创建config.js:touch config.js config.js是VuePress必要的配置文件，它导出一个javascript对象。 你可以先加入如下配置： module.exports = { title: &apos;Hello VuePress&apos;, description: &apos;Just playing around&apos; } 在.vuepress文件夹下面创建public文件夹:mkdir public 这个文件夹是用来放置静态资源的，打包出来之后会放在.vuepress/dist/的根目录。 首页(像VuePress文档主页一样)在docs文件夹下面创建一个README.md： 默认的主题提供了一个首页，像下面一样设置home:true即可，可以把下面的设置放入README.md中，待会儿你将会看到跟VuePress一样的主页。 --- home: true heroImage: /logo.jpg actionText: 快速上手 → actionLink: /zh/guide/ features: - title: 简洁至上 details: 以 Markdown 为中心的项目结构，以最少的配置帮助你专注于写作。 - title: Vue驱动 details: 享受 Vue + webpack 的开发体验，在 Markdown 中使用 Vue 组件，同时可以使用 Vue 来开发自定义主题。 - title: 高性能 details: VuePress 为每个页面预渲染生成静态的 HTML，同时在页面被加载的时候，将作为 SPA 运行。 footer: MIT Licensed | Copyright © 2018-present Evan You --- ps：你需要放一张图片到public文件夹中。 我们的项目结构已经搭好了：project ├─── docs │ ├── README.md │ └── .vuepress │ ├── public │ └── config.js └── package.json 在 package.json 里添加两个启动命令:{ &quot;scripts&quot;: { &quot;docs:dev&quot;: &quot;vuepress dev docs&quot;, &quot;docs:build&quot;: &quot;vuepress build docs&quot; } } 启动你的VuePress：默认是localhost:8080端口。 yarn docs:dev # 或者：npm run docs:dev 构建：build生成静态的HTML文件,默认会在 .vuepress/dist 文件夹下 yarn docs:build # 或者：npm run docs:build 基本配置：最标准的当然是官方文档,可以自己的需求来配置config.js。 可以参考一下我的config.js的配置： module.exports = { title: &apos;网站标题&apos;, description: &apos;网站描述&apos;, // 注入到当前页面的 HTML &lt;head&gt; 中的标签 head: [ [&apos;link&apos;, { rel: &apos;icon&apos;, href: &apos;/favicon.ico&apos; }], // 增加一个自定义的 favicon(网页标签的图标) ], base: &apos;/web_accumulate/&apos;, // 这是部署到github相关的配置 下面会讲 markdown: { lineNumbers: true // 代码块显示行号 }, themeConfig: { sidebarDepth: 2, // e&apos;b将同时提取markdown中h2 和 h3 标题，显示在侧边栏上。 lastUpdated: &apos;Last Updated&apos; // 文档更新时间：每个文件git最后提交的时间 } }; 导航栏配置： module.exports = { themeConfig: { nav:[ { text: &apos;前端算法&apos;, link: &apos;/algorithm/&apos; }, // 内部链接 以docs为根目录 { text: &apos;博客&apos;, link: &apos;http://obkoro1.com/&apos; }, // 外部链接 // 下拉列表 { text: &apos;GitHub&apos;, items: [ { text: &apos;GitHub地址&apos;, link: &apos;https://github.com/OBKoro1&apos; }, { text: &apos;算法仓库&apos;, link: &apos;https://github.com/OBKoro1/Brush_algorithm&apos; } ] } ] } } 侧边栏配置：侧边栏的配置相对麻烦点，我里面都做了详细的注释，仔细看，自己鼓捣鼓捣 就知道怎么搞了。 module.exports = { themeConfig: { sidebar:{ // docs文件夹下面的accumulate文件夹 文档中md文件 书写的位置(命名随意) &apos;/accumulate/&apos;: [ &apos;/accumulate/&apos;, // accumulate文件夹的README.md 不是下拉框形式 { title: &apos;侧边栏下拉框的标题1&apos;, children: [ &apos;/accumulate/JS/test&apos;, // 以docs为根目录来查找文件 // 上面地址查找的是：docs&gt;accumulate&gt;JS&gt;test.md 文件 // 自动加.md 每个子选项的标题 是该md文件中的第一个h1/h2/h3标题 ] } ], // docs文件夹下面的algorithm文件夹 这是第二组侧边栏 跟第一组侧边栏没关系 &apos;/algorithm/&apos;: [ &apos;/algorithm/&apos;, { title: &apos;第二组侧边栏下拉框的标题1&apos;, children: [ &apos;/algorithm/simple/test&apos; ] } ] } } } 其他：代码块编译错误：像下面这段代码会导致编译错误，VuePress会去找里面的变量，把它编译成text： {{}} 啦 {{}} 所以我们的代码块要以这种形式书写： 123//```js&#123;&#123;&#125;&#125; 啦 &#123;&#123;&#125;&#125; // 注释需要打开 这样vuepress会把这里面包裹的当成代码块而不是js// ` 并且这样也会让我们的代码高亮显示(下图第一个没有高亮，第二个有高亮)，阅读体验更好： 自定义容器了解一下： 更改标题： ::: tip 替换tip的标题 这里是内容。 ::: 其实文档里有，我这里只是提一下。 支持Emoji 文档中只提了支持Emoji,我在GitHub上找到了Emoji的列表，分享一下。 一个命令行发布到github上：在 docs/.vuepress/config.js 中设置正确的 base:如果你打算发布到 https://&lt;USERNAME&gt;.github.io/，则可以省略这一步，因为 base 默认即是 &quot;/&quot;。 如果你打算发布到 https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;/（也就是说你的仓库在 https://github.com/&lt;USERNAME&gt;/&lt;REPO&gt;），则将 base 设置为 &quot;/&lt;REPO&gt;/&quot;。 module.exports = { base: &apos;/test/&apos;, // 比如你的仓库是test } 创建脚步文件:在project的根目录下，创建一个deploy.sh文件： #!/usr/bin/env sh # 确保脚本抛出遇到的错误 set -e # 生成静态文件 npm run docs:build # 进入生成的文件夹 cd docs/.vuepress/dist # 如果是发布到自定义域名 # echo &apos;www.example.com&apos; &gt; CNAME git init git add -A git commit -m &apos;deploy&apos; # 如果发布到 https://&lt;USERNAME&gt;.github.io USERNAME=你的用户名 # git push -f git@github.com:&lt;USERNAME&gt;/&lt;USERNAME&gt;.github.io.git master # 如果发布到 https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt; REPO=github上的项目 # git push -f git@github.com:&lt;USERNAME&gt;/&lt;REPO&gt;.git master:gh-pages cd - 设置package.json：{ &quot;scripts&quot;: { &quot;d&quot;: &quot;bash deploy.sh&quot; } } 部署：然后你每次可以运行下面的命令行，来把最新更改推到github上： npm run d 如果你对运行项目和构建项目的命令行觉得很烦，你也可以像我这么做： &quot;scripts&quot;: { &quot;dev&quot;: &quot;vuepress dev docs&quot;, // 本地运行项目 npm run dev &quot;build&quot;: &quot;vuepress build docs&quot;, // 构建项目 nom run build &quot;d&quot;: &quot;bash deploy.sh&quot; // 部署项目 npm run d }, 更多：实际上VuePress的配置、用法还有很多，像还可以配置PWA，以及在markdown里面使用Vue组件等，这些功能我也还在摸索，所以大家一定要去看文档! 结语上面已经写得尽可能详细了，我遇到的坑都写上去了。搭建起来确实很简单，心动不如行动，随手花一两个小时搭建一下又不吃亏，何乐而不为？ 希望看完的朋友可以点个喜欢/关注，您的支持是对我最大的鼓励。个人blog and 前端积累文档，如需转载，请放上原文链接并署名。码字不易，感谢支持！ 如果喜欢本文的话，欢迎扫描关注我的订阅号，最新文章，面试题等都将第一时间发布在订阅号上。 以上2018.9.9]]></content>
  </entry>
  <entry>
    <title><![CDATA[算法-反转整数]]></title>
    <url>%2F2018%2F08%2F23%2F%E7%AE%97%E6%B3%95-%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[难度：简单描述将一个整数中的数字进行颠倒，当颠倒后的整数溢出时，返回 0 (标记为 32 位整数)。 样例：给定 x = 123，返回 321 给定 x = -123，返回 -321 给定 x = 1534236469， 返回 0 这题很简单,自己想一下！这题很简单,自己想一下！这题很简单,自己想一下！给 你 点 时 间 想 一 下 解法： 最优：转字符串 再转数组进行操作 看到有人用四则运算+遍历反转整数，会把这个解法放到下面 提示:整数溢出的值为Math.pow(2, 31) - 1和Math.pow(-2, 31) + 1，转为数字：2147483647和-2147483647 这部分跟位操作符，二进制有关，有兴趣可以去搜下。 code: 转数组操作： const reverseInteger = (n) =&gt; { if (n &lt; 0) { n = n.toString().split(&apos;-&apos;)[1]; // 负数提取数字 n = &apos;-&apos; + [...n].reverse().join(&apos;&apos;); n = +n; // 转数字 } else { n = n.toString(); // 转字符 n = +[...n].reverse().join(&apos;&apos;); // 转为数组 颠倒数组 再合字符 最后转数字 } if (n &gt;= Math.pow(2, 31) - 1 || n &lt;= Math.pow(-2, 31) + 1) { // 判断溢出 return 0; } return n; } 遍历，一位一位颠倒： const reverseInteger = function (n) { if (n === 0) return 0; let res = 0 while (n !== 0) { // 从个位起一位一位的颠倒 res = res * 10 + n % 10; n = parseInt(n / 10); // n除以10， 一位数转化完成 到最后小于1 被转成0 退出循环 } if (res &gt;= 2147483647 || res &lt;= -2147483647) { return 0; } return res; } 转数组操作运行效率也更高点： github 算法仓库地址2018.8.23]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题-树状数组结构转化]]></title>
    <url>%2F2018%2F08%2F20%2F%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BB%93%E6%9E%84%E8%BD%AC%E5%8C%96%2F</url>
    <content type="text"><![CDATA[题目如下： 这道题是我朋友发给我的，之前一开始看的时候，觉得很简单，但仔细往下看的时候，眉头一皱发现事情并不简单。 传进去的数组：let oldArr = [ { &apos;1_class&apos;: &apos;工具&apos;, &apos;2_class&apos;: &apos;备忘录&apos;, &apos;1_id&apos;: 1, &apos;2_id&apos;: 2 }, { &apos;1_class&apos;: &apos;教育&apos;, &apos;2_class&apos;: &apos;学历教育&apos;, &apos;3_class&apos;: &apos;中等&apos;, &apos;1_id&apos;: 3, &apos;2_id&apos;: 4, &apos;3_id&apos;: 6 }, { &apos;1_class&apos;: &apos;教育&apos;, &apos;2_class&apos;: &apos;学历教育&apos;, &apos;3_class&apos;: &apos;高等&apos;, &apos;1_id&apos;: 3, &apos;2_id&apos;: 4, &apos;3_id&apos;: 5 }, { &apos;1_class&apos;: &apos;教育&apos;, &apos;2_class&apos;: &apos;成人教育&apos;, &apos;1_id&apos;: 3, &apos;2_id&apos;: 7, }, ]; 输出的数组：let result = [ { value: 1, label: &apos;工具&apos;, children: [ { value: 2, label: &apos;备忘录&apos;, children: [] } ] }, { value: 3, label: &apos;教育&apos;, children: [ { value: 4, label: &apos;学历教育&apos;, children: [ { value: 6, label: &apos;中等&apos;, children: [] }, { value: 5, label: &apos;高等&apos;, children: [] } ] }, { value: 7, label: &apos;成人教育&apos;, children: [] } ] } ] 建议大家好好想想，争取能够自己解出来参考一下我的解题方法： 先算出层级嵌套数 遍历数组，再遍历数组的元素，用parseInt拿到每一个值，将最大的值取出来，即为层级嵌套数。 数组转成属性层级的对象。对象的属性是层级，值是数组，层级里面的值。 1.去重操作(比如:1_id相等的话就不再重复添加) 2.提取需要的信息，最终的值和相应父级的信息(之后组装数组的时候放到对应的地方，需要的信息)。 最后输出的对象是这个样子 将属性层级的对象转成树状结构数组。 遍历对象，获取层级值。 遍历层级的每个元素。 找到对应的层级将值添加进去，否则递归继续找对应层级。 通关秘籍这里有一份通关秘籍，全宇宙最低价，998卖给你。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-姓名去重]]></title>
    <url>%2F2018%2F08%2F16%2F%E7%AE%97%E6%B3%95-%E5%A7%93%E5%90%8D%E5%8E%BB%E9%87%8D%2F</url>
    <content type="text"><![CDATA[描述给一串名字，将他们去重之后返回。两个名字重复是说在忽略大小写的情况下是一样的。 说明：你可以假设名字只包含大小写字母和空格。 样例：给出： [ &quot;James&quot;, &quot;james&quot;, &quot;Bill Gates&quot;, &quot;bill Gates&quot;, &quot;Hello World&quot;, &quot;HELLO WORLD&quot;, &quot;Helloworld&quot; ] 返回： [ &quot;james&quot;, &quot;bill gates&quot;, &quot;hello world&quot;, &quot;helloworld&quot; ] 这题很简单,自己想一下！这题很简单,自己想一下！这题很简单,自己想一下！给 你 点 时 间 想 一 下 题目分析： 思路就是：去重和转小写 code:题目基本就像下面这样解了，其他的不过是循环的方法，去重的方法不同，事实上都大同小异。 const nameDeduplication = names =&gt; { names.forEach((value, index) =&gt; { names[index] = value.toLowerCase(); // 全部转小写 }); return [...new Set(names)]; // 去重 } 再讲一个坑吧： 题目描述的时候说是输出是这样的： [&quot;james&quot;, &quot;bill gates&quot;, &quot;hello world&quot;, &quot;helloworld&quot;] 当我把代码提交之后，告诉我，期望答案是这样的： [&quot;bill gates&quot;, &quot;hello world&quot;, &quot;helloworld&quot;, &quot;james&quot;] 一般来说不会这么坑： return [...new Set(names)].sort(); // 我在后面加了一个sort方法就符合他们的预期答案了。。 题目比较简单，就不放代码(上面就是)了。github 算法仓库地址2018.8.16]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法_判断字符串回文]]></title>
    <url>%2F2018%2F08%2F12%2F%E7%AE%97%E6%B3%95-%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9B%9E%E6%96%87%2F</url>
    <content type="text"><![CDATA[描述给定非空字符串s，您最多可以删除一个字符。判断是否可以成为回文。 该字符串仅包含小写字符a-z,字符串的最大长度为50000。 样例：Given s = “aba” return true Given s = “abca” return true // delete c 题目分析： 如果单单是回文的话，就很简单了: s === [...s].reverse().join(&quot;&quot;); // 翻转字符串与原字符相比 // 实际上这里做了很多步操作，字符转数组 翻转数组 再转字符串，所以这里性能也不是很好 // 如果对性能要求比较高的话，还是通过循环从两侧向中间逐一比较，会更好一点 题目中还有一个要求：删除一个字符，也就是允许一个字符的不同。 下面我们的解法主体思路就是通过循环，从两侧向中间比较，然后解决当出现不同的情况，如何保证只允许出现一个不同。 code: 出现一处不同 将值传入一个新函数，再进行判断字符串： const validPalindrome = s =&gt; { let left = 0; let right = s.length - 1; while (left &lt; right) { if (s[left] !== s[right]) { // 左右两边字符都要尝试一下 一边返回true即可 return isSubPalindrom(s, left + 1, right) || isSubPalindrom(s, left, right - 1); } left++; right--; } return true; // 循环结束返回true } const isSubPalindrom = (s, left, right) =&gt; { while (left &lt; right) { if (s[left] !== s[right]) { return false; // 再有不同之处 返回false } left++; right--; } return true; // 循环结束一直相等返回true // 并且left不小于right 直接返回right，说明不同之处只有一个 } console.log(&apos;回文验证:&apos;, validPalindrome(&apos;abaacaaa&apos;), validPalindrome(&apos;ab&apos;), validPalindrome(&apos;abc&apos;), validPalindrome(&apos;aabsjdbaa&apos;)) 这个写好之后，我在想能不能通过递归的形式来解决，为什么要创建第二个函数？ 递归解法： const validPalindrome = (s, left = 0, right = s.length - 1, type = &apos;first&apos;) =&gt; { if (type === &apos;first&apos;) { // 第一次进入允许出现一次不同 while (left &lt; right) { if (s[left] !== s[right]) { return validPalindrome(s, left + 1, right, &apos;second&apos;) || validPalindrome(s, left, right - 1, &apos;second&apos;); // 左右两边都尝试一下 一边返回true即可 } left++; right--; } return true; // 循环结束返回true } else { // 第二次 再有不同之处 返回false while (left &lt; right) { if (s[left] !== s[right]) { return false; } left++; right--; } return true; // 循环结束一直相等返回true // 并且left不小于right 直接返回right，说明不同之处只有一个 } } console.log(&apos;回文验证:&apos;, validPalindrome(&apos;abaacaaa&apos;), validPalindrome(&apos;ab&apos;), validPalindrome(&apos;abc&apos;), validPalindrome(&apos;aabsjdbaa&apos;)) 相对于上个解法这里就是多设置了一个变量，然后将两方区分开来，但是这样递归我还是觉得太傻了，所以在想你能不能通过设置变量来处理？出现两次不同即失败。 设置一个变量允许一次不同 const validPalindrome = s =&gt; { let removed = false; for (let [i, j] = [0, s.length - 1]; i &lt; j; i++ , j--) { // 从两侧向中间递减 i- j-1 减到最后 i&gt;j i=j 退出循环 if (s[i] !== s[j]) { // 如果两侧不相同 if (removed) { // 只允许一次不同 return false; } if (s[i] === s[j - 1]) { // 转数组删除一个不同元素 下次直接return // s = [...s].splice(j, 1); // s = s.join(&apos;&apos;); // 处理过的字符串 j--; removed = true; } else if (s[i + 1] === s[j]) { // s = [...s].splice(i, 1); // s = s.join(&apos;&apos;); // 处理过的字符串 i++; removed = true; } else { // 上面两个else 右边-1 或左边+1相不相等 如果两边也不相等即false return false; } } } return true; } console.log(&apos;回文验证:&apos;, validPalindrome(&apos;abaacaaa&apos;), validPalindrome(&apos;ab&apos;), validPalindrome(&apos;abc&apos;), validPalindrome(&apos;aabsjdbaa&apos;)) 代码地址github 算法仓库地址2018.8.12]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-查找斐波纳契数列中第N个数]]></title>
    <url>%2F2018%2F08%2F08%2F%E7%AE%97%E6%B3%95-%E6%9F%A5%E6%89%BE%E6%96%90%E6%B3%A2%E7%BA%B3%E5%A5%91%E6%95%B0%E5%88%97%E4%B8%AD%E7%AC%ACN%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[描述查找斐波纳契数列中第 N 个数。所谓的斐波纳契数列是指： 前2个数是 0 和 1 。 第 i 个数是第 i-1 个数和第i-2 个数的和。 斐波纳契数列的前10个数字是： 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 ... 怎样算解成功：给定 1，返回 0 给定 2，返回 1 给定 10，返回 34 题目分析：值得注意的是：前两个数字可以算成是起始元素，从第三个元素才开始有规则。 code: 递归解法： const fibonacci = (n) =&gt; { if (!(typeof n === &apos;number&apos; &amp;&amp; n % 1 === 0 &amp;&amp; n &gt; 1)) { throw &apos;请输入大于0的整数数字&apos;; } var array = [0, 0, 1]; let temp = (n) =&gt; { if (n == 1 || n == 2) return array[n]; array[n] = temp(n - 1) + temp(n - 2); // 递归获取推算数组每一个元素的值 return array[n]; } let num = temp(n); array.splice(2, 1); // 将数组恢复成 斐波纳契数列 return num; } 遍历保存结果 const fibonacci = (n) =&gt; { let a = 0, b = 1, c, d = [0]; for (let i = 1; i &lt; n; i++) { c = a + b; a = b; b = c; d.push(a); // 加戏 恢复数列 } console.log(d, &apos;斐波纳契数列&apos;) return a } 一次遍历 逐步推导所有元素 时间消耗:158ms 最优 const fibonacci = (n) =&gt; { let num = new Array(n).fill(0); // 初始化数组，并设置初始值 num[1] = 1; // 设置第二个元素的值 推导第3个元素 for (let i = 2; i &lt;= n - 1; i++) { num[i] = num[i - 2] + num[i - 1]; // 遍历逐步推导元素值 数组完全符合数列不用进行判断等 运行效率最高。 } return num[n - 1]; // 数组是从0开始计算 所以要减1 } 不行，我一定要秀一波，不然心里难受： 最后一题的提交，甩的第二名看不到我的车尾灯，开心！ 第一回刷算法题，以后要继续坚持！ 代码地址2018.8.5]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端er怎样操作剪切复制以及禁止复制+破解等]]></title>
    <url>%2F2018%2F08%2F08%2F%E5%89%8D%E7%AB%AFer%E6%80%8E%E6%A0%B7%E6%93%8D%E4%BD%9C%E5%89%AA%E5%88%87%E5%A4%8D%E5%88%B6%E4%BB%A5%E5%8F%8A%E7%A6%81%E6%AD%A2%E5%A4%8D%E5%88%B6-%E7%A0%B4%E8%A7%A3%E7%AD%89%2F</url>
    <content type="text"><![CDATA[前言有时候我们经常会碰到这些场景：玩掘金、知乎的时候复制一段文字，总是会在内容后面加上一些版权信息，以及像小说网站等都有禁止选中，禁止复制这种功能，还有点击自动复制账号的功能。 我也经常遇到这些场景，有时候会去想这后面到底是怎么做，周末趁着有空去研究了一下，然后发现这些都跟操作剪贴板有关系，并且都不难，了解一下基本都知道怎么做了，整理分享一波给大家。 个人博客了解一下：obkoro1.com 目录： API介绍 实现类知乎/掘金复制大段文本添加版权信息 实现类起点网的防复制功能 破解防复制 点击复制功能 API介绍:复制、剪切、粘贴事件： copy 发生复制操作时触发; cut 发生剪切操作时触发; paste 发生粘贴操作时触发; 每个事件都有一个before事件对应：beforecopy、beforecut、beforepaste; 这几个before一般不怎么用，所以我们把注意力放在另外三个事件就可以了。 触发条件: 鼠标右键菜单的复制、粘贴、剪切; 使用了相应的键盘组合键，比如:command+c、command+v; 就算你是随便按的，也会触发事件。高程中介绍在Chorme、Firefox和Safari中，这几个before事件只会在真实会发生剪贴板事件的情况下触发，IE上则可以触发before。我实际测试的时候最新版chorme也会乱按也会触发，所以限制应该是在早一点的版本上。 so 想说的是：before这几个事件最好不要用,有关于剪切板的处理最好放在copy、cut、paste上面。 使用姿势： 以copy为例: document.body.oncopy = e =&gt; { // 监听全局复制 做点什么 } // 还有这种写法： document.addEventListener(&quot;copy&quot;, e =&gt; { // 监听全局复制 做点什么 }); 上面是在document.body上全局监听的，然而很多人不知道的是，我们还可以为某些dom单独添加剪切板事件： // html结构 &lt;div id=&quot;test1&quot;&gt;&lt;/div&gt; &lt;div id=&quot;test2&quot;&gt;&lt;/div&gt; // 写法一样： let test1 = document.querySelector(&apos;#test1&apos;); test1.oncopy = e =&gt; { // 监听test1发生的复制事件 做点什么 // test1发生的复制事件会触发回调，其他地方不会触发回调 } 其他事件也是一样的，这里就不赘述了。 clipboardData对象:用于访问以及修改剪贴板中的数据兼容： 不同浏览器，所属的对象不同：在IE中这个对象是window对象的属性，在Chrome、Safari和Firefox中，这个对象是相应的event对象的属性。所以我们在使用的时候，需要做一下如下兼容: document.body.oncopy = e =&gt; { let clipboardData = (e.clipboardData || window.clipboardData); // 获取clipboardData对象 + do something } 对象方法： 对象有三个方法: getData()、setData()、clearData() getData() 访问剪切板中的数据 参数： getData()接受一个&#39;text&#39;参数，即要取得的数据的格式。 在复制、剪切、粘贴触发的事件的数据： 实际上在chorme上测试只有paste粘贴的时候才能用getData()访问到数据，用法如下： 要粘贴的数据： document.body.onpaste = e =&gt; { let clipboardData = (e.clipboardData || window.clipboardData); // 兼容处理 console.log(&apos;要粘贴的数据&apos;, clipboardData.getData(&apos;text&apos;)); } 被复制/剪切的数据： 在复制和剪切中的数据，需要通过window.getSelection(0).toString()来访问: document.body.oncopy = e =&gt; { console.log(&apos;被复制的数据:&apos;, window.getSelection(0).toString()); } setData(): 修改剪切板中的数据 参数：第一个参数也是&#39;text&#39;，第二个参数是要放在剪切板中的文本。 剩下的留在下面仿知乎/掘金复制大段文本添加版权信息那里再说。 clearData() : 这个方法就不太知道了，试了好久不知道怎么用(如果有大佬知道，可以在评论区指点一下)。 如果只是为了禁止复制，或者禁止粘贴，在下面还有另外的方法可以做到，并且可以细粒化操作。 应用:如果学习不是为了装X，那么一切将毫无意义，来看这个东西可以在哪些场景使用： 实现类知乎/掘金复制大段文本添加版权信息:实现很简单：取消默认复制之后，主要是在被复制的内容后面添加信息，然后根据clipboardData的setData()方法将信息写入剪贴板。 可以直接复制这段代码到本地去试试。 // 掘金这里不是全局监听，应该只是监听文章的dom范围内。 document.body.oncopy = event =&gt; { event.preventDefault(); // 取消默认的复制事件 let textFont, copyFont = window.getSelection(0).toString(); // 被复制的文字 等下插入 // 防知乎掘金 复制一两个字则不添加版权信息 超过一定长度的文字 就添加版权信息 if (copyFont.length &gt; 10) { textFont = copyFont + &apos;\n&apos; + &apos;作者：OBKoro1\n&apos; + &apos;链接：https://juejin.im/user/58714f0eb123db4a2eb95372/posts\n&apos; + &apos;来源：掘金\n&apos; + &apos;著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&apos;; } else { textFont = copyFont; // 没超过十个字 则采用被复制的内容。 } if (event.clipboardData) { return event.clipboardData.setData(&apos;text&apos;, textFont); // 将信息写入粘贴板 } else { // 兼容IE return window.clipboardData.setData(&quot;text&quot;, textFont); } } 然后command+c、command+v，输出: 你复制的内容 作者：OBKoro1 链接：https://juejin.im/user/58714f0eb123db4a2eb95372/posts 来源：掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 实现类起点网的防复制功能: 禁止复制+剪切 禁止右键，右键某些选项:全选，复制，粘贴等。 禁用文字选择，能选择却不能复制，体验很差。 user-select 用css禁止选择文本。 可以把代码拷到本地玩一玩： // 禁止右键菜单 document.body.oncontextmenu = e =&gt; { console.log(e, &apos;右键&apos;); return false; // e.preventDefault(); }; // 禁止文字选择。 document.body.onselectstart = e =&gt; { console.log(e, &apos;文字选择&apos;); return false; // e.preventDefault(); }; // 禁止复制 document.body.oncopy = e =&gt; { console.log(e, &apos;copy&apos;); return false; // e.preventDefault(); } // 禁止剪切 document.body.oncut = e =&gt; { console.log(e, &apos;cut&apos;); return false; // e.preventDefault(); }; // 禁止粘贴 document.body.onpaste = e =&gt; { console.log(e, &apos;paste&apos;); return false; // e.preventDefault(); }; // css 禁止文本选择 这样不会触发js body { user-select: none; -moz-user-select: none; -webkit-user-select: none; -ms-user-select: none; } PS： 使用e.preventDefault()也可以禁用，但建议使用return false这样就不用去访问e和e的方法了。 示例中document.body全局都禁用了，也可以对dom(某些区域)进行禁用。 破解防复制： 上面的防复制方法通过js+css实现的，所以思路就是：禁用js+取消user-select样式。 Chrome浏览器的话：打开浏览器控制台，按F1进入Setting，勾选Disable JavaScript(禁止js)。 此时如果还不能复制的话，就要去找user-select样式,取消这个样式就可以了。 所以那些盗版小说手打的，我真的不太能理解，Excuse me？？？ 点击复制功能：不能使用clipboardData： 在IE中可以用window.clipboardData.setData(&#39;text&#39;,&#39;内容&#39;)实现。 上文提到过，在IE中clipboardData是window的属性。 而其他浏览器则是相应的event对象的属性，这实际上是一种安全措施，防止未经授权的访问,为了兼容其他浏览器，所以我们不能通过clipboardData来实现这种操作。 具体做法： 创建一个隐藏的input框 点击的时候，将要复制的内容放进input框中 选择文本内容input.select() 这里只能用input或者textarea才能选择文本。 document.execCommand(“copy”)，执行浏览器的复制命令。 function copyText() { var text = document.getElementById(&quot;text&quot;).innerText; // 获取要复制的内容也可以传进来 var input = document.getElementById(&quot;input&quot;); // 获取隐藏input的dom input.value = text; // 修改文本框的内容 input.select(); // 选中文本 document.execCommand(&quot;copy&quot;); // 执行浏览器复制命令 alert(&quot;复制成功&quot;); } 点击复制内容的demo在这里，可以点进去看看。 结语工作之余了解一下这些东西还是很有趣的，也可以扩宽你的知识面。 事实上只要监听了这些事件，我们就可以对要剪切的内容进行各种各样的操作，比如:复制的时候更换文本，粘贴的时候查找有没有图片(上传图片)，或者文本的长度进行剪切等等，唯一限制你的 希望看完的朋友可以点个喜欢/关注，您的支持是对我最大的鼓励。个人blog and 掘金个人主页，如需转载，请放上原文链接并署名。码字不易，感谢支持！ 如果喜欢本文的话，欢迎关注我的订阅号，漫漫技术路，期待未来共同学习成长。 以上2018.8.8 参考资料： js高程 14.2.2操作剪贴板 网页上如何实现禁止复制粘贴以及如何破解 原生 js 实现点击按钮复制文本]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue的钩子函数[路由导航守卫、keep-alive、生命周期钩子]]]></title>
    <url>%2F2018%2F07%2F21%2FVue%E7%9A%84%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0-%E8%B7%AF%E7%94%B1%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB%E3%80%81keep-alive%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%2F</url>
    <content type="text"><![CDATA[前言说到Vue的钩子函数，可能很多人只停留在一些很简单常用的钩子(created,mounted)，而且对于里面的区别，什么时候该用什么钩子，并没有仔细的去研究过，且Vue的生命周期在面试中也算是比较高频的考点，那么该如何回答这类问题，让人有眼前一亮的感觉呢… 个人博客了解一下：obkoro1.com Vue-Router导航守卫：有的时候，我们需要通过路由来进行一些操作，比如最常见的登录权限验证，当用户满足条件时，才让其进入导航，否则就取消跳转，并跳到登录页面让其登录。 为此我们有很多种方法可以植入路由的导航过程：全局的, 单个路由独享的, 或者组件级的,推荐优先阅读路由文档 全局守卫vue-router全局有三个守卫： router.beforeEach 全局前置守卫 进入路由之前 router.beforeResolve 全局解析守卫(2.5.0+) 在beforeRouteEnter调用之后调用 router.afterEach 全局后置钩子 进入路由之后 使用方法： // main.js 入口文件 import router from &apos;./router&apos;; // 引入路由 router.beforeEach((to, from, next) =&gt; { next(); }); router.beforeResolve((to, from, next) =&gt; { next(); }); router.afterEach((to, from) =&gt; { console.log(&apos;afterEach 全局后置钩子&apos;); }); to,from,next 这三个参数：to和from是将要进入和将要离开的路由对象,路由对象指的是平时通过this.$route获取到的路由对象。 next:Function 这个参数是个函数，且必须调用，否则不能进入路由(页面空白)。 next() 进入该路由。 next(false): 取消进入路由，url地址重置为from路由地址(也就是将要离开的路由地址)。 next 跳转新路由，当前的导航被中断，重新开始一个新的导航。 我们可以这样跳转：next(&apos;path地址&apos;)或者next({path:&apos;&apos;})或者next({name:&apos;&apos;}) 且允许设置诸如 replace: true、name: &apos;home&apos; 之类的选项 以及你用在router-link或router.push的对象选项。 路由独享守卫如果你不想全局配置守卫的话，你可以为某些路由单独配置守卫： const router = new VueRouter({ routes: [ { path: &apos;/foo&apos;, component: Foo, beforeEnter: (to, from, next) =&gt; { // 参数用法什么的都一样,调用顺序在全局前置守卫后面，所以不会被全局守卫覆盖 // ... } } ] }) 路由组件内的守卫： beforeRouteEnter 进入路由前 beforeRouteUpdate (2.2) 路由复用同一个组件时 beforeRouteLeave 离开当前路由时 文档中的介绍： beforeRouteEnter (to, from, next) { // 在路由独享守卫后调用 不！能！获取组件实例 `this`，组件实例还没被创建 }, beforeRouteUpdate (to, from, next) { // 在当前路由改变，但是该组件被复用时调用 可以访问组件实例 `this` // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 }, beforeRouteLeave (to, from, next) { // 导航离开该组件的对应路由时调用，可以访问组件实例 `this` } beforeRouteEnter访问this 因为钩子在组件实例还没被创建的时候调用，所以不能获取组件实例 this，可以通过传一个回调给next来访问组件实例。 但是回调的执行时机在mounted后面,所以在我看来这里对this的访问意义不太大，可以放在created或者mounted里面。 beforeRouteEnter (to, from, next) { console.log(&apos;在路由独享守卫后调用&apos;); next(vm =&gt; { // 通过 `vm` 访问组件实例`this` 执行回调的时机在mounted后面， }) } beforeRouteLeave： 导航离开该组件的对应路由时调用，我们用它来禁止用户离开，比如还未保存草稿，或者在用户离开前，将setInterval销毁，防止离开之后，定时器还在调用。 beforeRouteLeave (to, from , next) { if (文章保存) { next(); // 允许离开或者可以跳到别的路由 上面讲过了 } else { next(false); // 取消离开 } } 关于钩子的一些知识：路由钩子函数的错误捕获如果我们在全局守卫/路由独享守卫/组件路由守卫的钩子函数中有错误，可以这样捕获： router.onError(callback =&gt; { // 2.4.0新增 并不常用，了解一下就可以了 console.log(callback, &apos;callback&apos;); }); 在路由文档中还有更多的实例方法：动态添加路由等，有兴趣可以了解一下。 跳转死循环，页面永远空白我了解到的，很多人会碰到这个问题，来看一下这段伪代码： router.beforeEach((to, from, next) =&gt; { if(登录){ next() }else{ next({ name: &apos;login&apos; }); } }); 看逻辑貌似是对的，但是当我们跳转到login之后，因为此时还是未登录状态，所以会一直跳转到login然后死循环，页面一直是空白的，所以：我们需要把判断条件稍微改一下。 if(登录 || to.name === &apos;login&apos;){ next() } // 登录，或者将要前往login页面的时候，就允许进入路由 全局后置钩子的跳转：文档中提到因为router.afterEach不接受next函数所以也不会改变导航本身，意思就是只能当成一个钩子来使用，但是我自己在试的时候发现，我们可以通过这种形式来实现跳转： // main.js 入口文件 import router from &apos;./router&apos;; // 引入路由 router.afterEach((to, from) =&gt; { if (未登录 &amp;&amp; to.name !== &apos;login&apos;) { router.push({ name: &apos;login&apos; }); // 跳转login } }); 额，通过router.beforeEach 也完全可以实现且更好，我就骚一下。 完整的路由导航解析流程(不包括其他生命周期)： 触发进入其他路由。 调用要离开路由的组件守卫beforeRouteLeave 调用局前置守卫：beforeEach 在重用的组件里调用 beforeRouteUpdate 调用路由独享守卫 beforeEnter。 解析异步路由组件。 在将要进入的路由组件中调用beforeRouteEnter 调用全局解析守卫 beforeResolve 导航被确认。 调用全局后置钩子的 afterEach 钩子。 触发DOM更新(mounted)。 执行beforeRouteEnter 守卫中传给 next 的回调函数 你不知道的keep-alive[我猜你不知道]在开发Vue项目的时候，大部分组件是没必要多次渲染的，所以Vue提供了一个内置组件keep-alive来缓存组件内部状态，避免重新渲染，文档在这里。 文档：和 &lt;transition&gt;相似，&lt;keep-alive&gt; 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。 用法：缓存动态组件： &lt;keep-alive&gt;包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们，此种方式并无太大的实用意义。 &lt;!-- 基本 --&gt; &lt;keep-alive&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt; &lt;!-- 多个条件判断的子组件 --&gt; &lt;keep-alive&gt; &lt;comp-a v-if=&quot;a &gt; 1&quot;&gt;&lt;/comp-a&gt; &lt;comp-b v-else&gt;&lt;/comp-b&gt; &lt;/keep-alive&gt; 缓存路由组件： 使用keep-alive可以将所有路径匹配到的路由组件都缓存起来，包括路由组件里面的组件，keep-alive大多数使用场景就是这种。 &lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; 生命周期钩子：这篇既然是Vue钩子函数的专场，那肯定要扣题呀~ 在被keep-alive包含的组件/路由中，会多出两个生命周期的钩子:activated 与 deactivated。 文档：在 2.2.0 及其更高版本中，activated 和 deactivated 将会在 树内的所有嵌套组件中触发。 activated在组件第一次渲染时会被调用，之后在每次缓存组件被激活时调用。 activated调用时机： 第一次进入缓存路由/组件，在mounted后面，beforeRouteEnter守卫传给 next 的回调函数之前调用： beforeMount=&gt; 如果你是从别的路由/组件进来(组件销毁destroyed/或离开缓存deactivated)=&gt; mounted=&gt; activated 进入缓存组件 =&gt; 执行 beforeRouteEnter回调 因为组件被缓存了，再次进入缓存路由/组件时，不会触发这些钩子： // beforeCreate created beforeMount mounted 都不会触发。 所以之后的调用时机是： 组件销毁destroyed/或离开缓存deactivated =&gt; activated 进入当前缓存组件 =&gt; 执行 beforeRouteEnter回调 // 组件缓存或销毁，嵌套组件的销毁和缓存也在这里触发 deactivated：组件被停用(离开路由)时调用 使用了keep-alive就不会调用beforeDestroy(组件销毁前钩子)和destroyed(组件销毁)，因为组件没被销毁，被缓存起来了。 这个钩子可以看作beforeDestroy的替代，如果你缓存了组件，要在组件销毁的的时候做一些事情，你可以放在这个钩子里。 如果你离开了路由，会依次触发： 组件内的离开当前路由钩子beforeRouteLeave =&gt; 路由前置守卫 beforeEach =&gt; 全局后置钩子afterEach =&gt; deactivated 离开缓存组件 =&gt; activated 进入缓存组件(如果你进入的也是缓存路由) // 如果离开的组件没有缓存的话 beforeDestroy会替换deactivated // 如果进入的路由也没有缓存的话 全局后置钩子afterEach=&gt;销毁 destroyed=&gt; beforeCreate等 那么，如果我只是想缓存其中几个路由/组件，那该怎么做？ 缓存你想缓存的路由：Vue2.1.0之前:想实现类似的操作，你可以： 配置一下路由元信息 创建两个keep-alive标签 使用v-if通过路由元信息判断缓存哪些路由。 &lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt; &lt;!--这里是会被缓存的路由--&gt; &lt;/router-view&gt; &lt;/keep-alive&gt; &lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt; &lt;!--因为用的是v-if 所以下面还要创建一个未缓存的路由视图出口--&gt; &lt;/router-view&gt; //router配置 new Router({ routes: [ { path: &apos;/&apos;, name: &apos;home&apos;, component: Home, meta: { keepAlive: true // 需要被缓存 } }, { path: &apos;/:id&apos;, name: &apos;edit&apos;, component: Edit, meta: { keepAlive: false // 不需要被缓存 } } ] }); Vue2.1.0版本之后：使用路由元信息的方式，要多创建一个router-view标签，并且每个路由都要配置一个元信息，是可以实现我们想要的效果，但是过于繁琐了点。 幸运的是在Vue2.1.0之后，Vue新增了两个属性配合keep-alive来有条件地缓存 路由/组件。 新增属性： include：匹配的 路由/组件 会被缓存 exclude：匹配的 路由/组件 不会被缓存 include和exclude支持三种方式来有条件的缓存路由：采用逗号分隔的字符串形式，正则形式，数组形式。 正则和数组形式，必须采用v-bind形式来使用。 缓存组件的使用方式： &lt;!-- 逗号分隔字符串 --&gt; &lt;keep-alive include=&quot;a,b&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt; &lt;!-- 正则表达式 (使用 `v-bind`) --&gt; &lt;keep-alive :include=&quot;/a|b/&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt; &lt;!-- 数组 (使用 `v-bind`) --&gt; &lt;keep-alive :include=&quot;[&apos;a&apos;, &apos;b&apos;]&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt; 但更多场景中，我们会使用keep-alive来缓存路由： &lt;keep-alive include=&apos;a&apos;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; 匹配规则： 首先匹配组件的name选项，如果name选项不可用。 则匹配它的局部注册名称。 (父组件 components 选项的键值) 匿名组件，不可匹配。 比如路由组件没有name选项，并且没有注册的组件名。 只能匹配当前被包裹的组件，不能匹配更下面嵌套的子组件。 比如用在路由上，只能匹配路由组件的name选项，不能匹配路由组件里面的嵌套组件的name选项。 文档：&lt;keep-alive&gt;不会在函数式组件中正常工作，因为它们没有缓存实例。 exclude的优先级大于include 也就是说：当include和exclude同时存在时，exclude生效，include不生效。 &lt;keep-alive include=&quot;a,b&quot; exclude=&quot;a&quot;&gt; &lt;!--只有a不被缓存--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; 当组件被exclude匹配，该组件将不会被缓存，不会调用activated 和 deactivated。 组件生命周期钩子：关于组件的生命周期，是时候放出这张图片了： 这张图片已经讲得很清楚了，很多人这部分也很清楚了，大部分生命周期并不会用到，这里提一下几点： ajax请求最好放在created里面，因为此时已经可以访问this了，请求到数据就可以直接放在data里面。 这里也碰到过几次，面试官问：ajax请求应该放在哪个生命周期。 关于dom的操作要放在mounted里面，在mounted前面访问dom会是undefined。 每次进入/离开组件都要做一些事情，用什么钩子： 不缓存： 进入的时候可以用created和mounted钩子，离开的时候用beforeDestory和destroyed钩子,beforeDestory可以访问this，destroyed不可以访问this。 缓存了组件： 缓存了组件之后，再次进入组件不会触发`beforeCreate`、`created` 、`beforeMount`、 `mounted`，**如果你想每次进入组件都做一些事情的话，你可以放在`activated`进入缓存组件的钩子中**。 同理：离开缓存组件的时候，`beforeDestroy`和`destroyed`并不会触发，可以使用`deactivated`离开缓存组件的钩子来代替。 触发钩子的完整顺序：将路由导航、keep-alive、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件： beforeRouteLeave:路由组件的组件离开路由前钩子，可取消路由离开。 beforeEach: 路由全局前置守卫，可用于登录验证、全局路由loading等。 beforeEnter: 路由独享守卫 beforeRouteEnter: 路由组件的组件进入路由前钩子。 beforeResolve:路由全局解析守卫 afterEach:路由全局后置钩子 beforeCreate:组件生命周期，不能访问this。 created:组件生命周期，可以访问this，不能访问dom。 beforeMount:组件生命周期 deactivated: 离开缓存组件a，或者触发a的beforeDestroy和destroyed组件销毁钩子。 mounted:访问/操作dom。 activated:进入缓存组件，进入a的嵌套子组件(如果有的话)。 执行beforeRouteEnter回调函数next。 结语Vue提供了很多钩子，但很多钩子我们几乎不会用到，只有清楚这些钩子函数的触发顺序以及背后的一些限制等，这样我们才能够正确的使用这些钩子，希望看了本文的同学，能对这些钩子有更加清晰的认识，使用起来更加得心应手。 希望看完的朋友可以点个喜欢/关注，您的支持是对我最大的鼓励。个人blog and 掘金个人主页，如需转载，请放上原文链接并署名。码字不易，感谢支持！ 如果喜欢本文的话，欢迎关注我的订阅号，漫漫技术路，期待未来共同学习成长。 以上2018.7.21 参考资料： Vue文档 keep-alive的深入理解与使用(配合router-view缓存整个路由页面)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS高程中的垃圾回收机制与常见内存泄露的解决方法]]></title>
    <url>%2F2018%2F07%2F08%2FJS%E9%AB%98%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言起因是因为想了解闭包的内存泄露机制，然后想起《js高级程序设计》中有关于垃圾回收机制的解析，之前没有很懂，过一年回头再看就懂了，写篇博客与大家分享一下。如果喜欢的话可以点波赞/关注，支持一下。 个人博客了解一下：obkoro1.com 内存的生命周期： 分配你所需要的内存： 由于字符串、对象等没有固定的大小，js程序在每次创建字符串、对象的时候，程序都会分配内存来存储那个实体。 使用分配到的内存做点什么。 不需要时将其释放回归： 在不需要字符串、对象的时候，需要释放其所占用的内存，否则将会消耗完系统中所有可用的内存，造成系统崩溃，这就是垃圾回收机制所存在的意义。 所谓的内存泄漏指的是：由于疏忽或错误造成程序未能释放那些已经不再使用的内存，造成内存的浪费。 垃圾回收机制：在C和C++之类的语言中，需要手动来管理内存的，这也是造成许多不必要问题的根源。幸运的是，在编写js的过程中，内存的分配以及内存的回收完全实现了自动管理，我们不用操心这种事情。 垃圾收集机制的原理：垃圾收集器会按照固定的时间间隔，周期性的找出不再继续使用的变量，然后释放其占用的内存。 什么叫不再继续使用的变量？ 不再使用的变量也就是生命周期结束的变量，是局部变量，局部变量只在函数的执行过程中存在，当函数运行结束，没有其他引用(闭包)，那么该变量会被标记回收。 全局变量的生命周期直至浏览器卸载页面才会结束，也就是说全局变量不会被当成垃圾回收。 标记清除：当前采用的垃圾收集策略工作原理： 当变量进入环境时(例如在函数中声明一个变量)，将这个变量标记为“进入环境”，当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。 工作流程： 垃圾收集器会在运行的时候会给存储在内存中的所有变量都加上标记。 去掉环境中的变量以及被环境中的变量引用的变量的标记。 那些还存在标记的变量被视为准备删除的变量。 最后垃圾收集器会执行最后一步内存清除的工作，销毁那些带标记的值并回收它们所占用的内存空间。 到2008年为止,IE、Chorme、Fireofx、Safari、Opera 都使用标记清除式的垃圾收集策略，只不过垃圾收集的时间间隔互有不同。 引用计数略：被废弃的垃圾收集策循环引用：跟踪记录每个值被引用的技术 在老版本的浏览器中(对，又是IE)，IE9以下BOM和DOM对象就是使用C++以COM对象的形式实现的。 COM的垃圾收集机制采用的就是引用计数策略，这种机制在出现循环引用的时候永远都释放不掉内存。 var element = document.getElementById(&apos;something&apos;); var myObject = new Object(); myObject.element = element; // element属性指向dom element.someThing = myObject; // someThing回指myObject 出现循环引用(两个对象一直互相包含 一直存在计数)。 解决方式是，当我们不使用它们的时候，手动切断链接： myObject.element = null; element.someThing = null; 淘汰： IE9把BOM和DOM对象转为了真正的js对象，避免了使用这种垃圾收集策略，消除了IE9以下常见的内存泄漏的主要原因。 IE7以下有一个声明狼藉的性能问题，大家了解一下： 256个变量，4096个对象(或数组)字面或者64KB的字符串，达到任何一个临界值会触发垃圾收集器运行。 如果一个js脚本的生命周期一直保有那么多变量，垃圾收集器会一直频繁的运行，引发严重的性能问题。 IE7已修复这个问题。 哪些情况会引起内存泄漏？虽然有垃圾回收机制，但我们在编写代码的时候，有些情况还是会造成内存泄漏，了解这些情况，并在编写程序的时候，注意避免，我们的程序会更具健壮性。 意外的全局变量：上文我们提到了全局变量不会被当成垃圾回收，我们在编码中有时会出现下面这种情况： function foo() { this.bar2 = &apos;默认绑定this指向全局&apos; // 全局变量=&gt; window.bar2 bar = &apos;全局变量&apos;; // 没有声明变量 实际上是全局变量=&gt;window.bar } foo(); 当我们使用默认绑定，this会指向全局，this.something也会创建一个全局变量，这一点可能很多人没有注意到。 解决方法：在函数内使用严格模式or细心一点 function foo() { &quot;use strict&quot;; this.bar2 = &quot;严格模式下this指向undefined&quot;; bar = &quot;报错&quot;; } foo(); 当然我们也可以手动释放全局变量的内存： window.bar = undefined delete window.bar2 被遗忘的定时器和回调函数当不需要setInterval或者setTimeout时，定时器没有被clear，定时器的回调函数以及内部依赖的变量都不能被回收，造成内存泄漏。 var someResource = getData(); setInterval(function() { var node = document.getElementById(&apos;Node&apos;); if(node) { node.innerHTML = JSON.stringify(someResource)); // 定时器也没有清除 } // node、someResource 存储了大量数据 无法回收 }, 1000); 解决方法： 在定时器完成工作的时候，手动清除定时器。 闭包：闭包可以维持函数内局部变量，使其得不到释放，造成内存泄漏。 function bindEvent() { var obj = document.createElement(&quot;XXX&quot;); var unused = function () { console.log(obj,&apos;闭包内引用obj obj不会被释放&apos;); }; // obj = null; } 解决方法：手动解除引用，obj = null。 循环引用问题就是IE9以下的循环引用问题，上文讲过了。 没有清理DOM元素引用：var refA = document.getElementById(&apos;refA&apos;); document.body.removeChild(refA); // dom删除了 console.log(refA, &quot;refA&quot;); // 但是还存在引用 能console出整个div 没有被回收 不信的话，可以看下这个dom。 解决办法：refA = null; console保存大量数据在内存中。过多的console，比如定时器的console会导致浏览器卡死。 解决：合理利用console，线上项目尽量少的使用console，当然如果你要发招聘，除外。 如何避免内存泄漏：记住一个原则：不用的东西，及时归还，毕竟你是’借的’嘛。 减少不必要的全局变量，使用严格模式避免意外创建全局变量。 在你使用完数据后，及时解除引用(闭包中的变量，dom引用，定时器清除)。 组织好你的逻辑，避免死循环等造成浏览器卡顿，崩溃的问题。 关于内存泄漏： 即使是1byte的内存，也叫内存泄漏，并不一定是导致浏览器崩溃、卡顿才能叫做内存泄漏。 一般是堆区内存泄漏，栈区不会泄漏。 基本类型的值存在内存中，被保存在栈内存中，引用类型的值是对象，保存在堆内存中。所以对象、数组之类的，才会发生内存泄漏。 使用chorme监控内存泄漏，可以看一下这篇文章 结语了解了内存泄漏的原因以及出现的情况，那么我们在编码过程中只要多加注意，就不会发生非常严重的内存泄漏问题。 PS：目前离职中，有坑位可以介绍一下，base：上海2号线淞虹路。 希望看完的朋友可以点个喜欢/关注，您的支持是对我最大的鼓励。个人blog and 掘金个人主页，如需转载，请放上原文链接并署名。码字不易，感谢支持！ 如果喜欢本文的话，欢迎关注我的订阅号，漫漫技术路，期待未来共同学习成长。 以上2018.7.7 参考资料： JS高程4.3垃圾收集 4类 JavaScript 内存泄漏及如何避免 JavaScript内存泄露及解决方案详解 4类 JavaScript 内存泄漏及如何避免]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js 机制</tag>
        <tag>浏览器机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的js中关于this绑定机制的解析[看完还不懂算我输]]]></title>
    <url>%2F2018%2F06%2F30%2F%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js%E4%B8%AD%E5%85%B3%E4%BA%8Ethis%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6%E7%9A%84%E8%A7%A3%E6%9E%90-%E7%9C%8B%E5%AE%8C%E8%BF%98%E4%B8%8D%E6%87%82%E7%AE%97%E6%88%91%E8%BE%93%2F</url>
    <content type="text"><![CDATA[前言最近正在看《你不知道的JavaScript》，里面关于this绑定机制的部分讲的特别好，很清晰，这部分对我们js的使用也是相当关键的，并且这也是一个面试的高频考点，所以整理一篇文章分享一下这部分的内容，相信看本文的解析，你一定会有所收获的，如果喜欢的话可以点波赞/关注，支持一下。 个人博客了解一下：obkoro1.com 为什么要用this：function identify() { console.log(&quot;Hello,I&apos;m &quot; + this.name); } let me = { name: &quot;Kyle&quot; }; let you = { name: &quot;Reader&quot; }; identify.call(me); // Hello,I&apos;m Kyle identify.call(you); // Hello,I&apos;m Reader 这个简单的栗子，可以在不同的对象中复用函数identify，不用针对每个对象编写一个新函数。 this解决的问题: this提供了一种更优雅的方法来隐式’传递’一个对象的引用，因此可以将API设计得更加简洁并且易于复用。 this的四种绑定规则：默认绑定：规则：在非严格模式下，默认绑定的this指向全局对象，严格模式下this指向undefined function foo() { console.log(this.a); // this指向全局对象 } var a = 2; foo(); // 2 function foo2() { &quot;use strict&quot;; // 严格模式this绑定到undefined console.log(this.a); } foo2(); // TypeError:a undefined 默认绑定规则如上述栗子，书中还提到了一个微妙的细节： function foo() { console.log(this.a); // foo函数不是严格模式 默认绑定全局对象 } var a = 2; function foo2(){ &quot;use strict&quot;; foo(); // 严格模式下调用其他函数，不影响默认绑定 } foo2(); // 2 所以：对于默认绑定来说，决定this绑定对象的是函数体是否处于严格模式，严格指向undefined，非严格指向全局对象。 通常不会在代码中混用严格模式和非严格模式，所以这种情况很罕见，知道一下就可以了，避免某些变态的面试题挖坑。 隐式绑定：规则：函数在调用位置，是否有上下文对象，如果有，那么this就会隐式绑定到这个对象上。 function foo() { console.log(this.a); } var a = &quot;Oops, global&quot;; let obj2 = { a: 2, foo: foo }; let obj1 = { a: 22, obj2: obj2 }; obj2.foo(); // 2 this指向调用函数的对象 obj1.obj2.foo(); // 2 this指向最后一层调用函数的对象 // 隐式绑定丢失 let bar = obj2.foo; // bar只是一个函数别名 是obj2.foo的一个引用 bar(); // &quot;Oops, global&quot; - 指向全局 隐式绑定丢失： 隐式绑定丢失的问题：实际上就是函数调用时，并没有上下文对象，只是对函数的引用，所以会导致隐式绑定丢失。 同样的问题，还发生在传入回调函数中，这种情况更加常见，并且隐蔽，类似： test(obj2.foo); // 传入函数的引用，调用时也是没有上下文对象。 显式绑定:就像我们上面看到的，如果单纯使用隐式绑定肯定没有办法得到期望的绑定，幸好我们还可以在某个对象上强制调用函数，从而将this绑定在这个函数上。 规则：我们可以通过apply、call、bind将函数中的this绑定到指定对象上。 function foo() { console.log(this.a); } let obj = { a: 2 }; foo.call(obj); // 2 传入的不是对象： 如果你传入了一个原始值(字符串,布尔类型，数字类型)，来当做this的绑定对象，这个原始值转换成它的对象形式。 如果你把null或者undefined作为this的绑定对象传入call/apply/bind，这些值会在调用时被忽略，实际应用的是默认绑定规则。 new绑定： 书中提到：在js中，实际上并不存在所谓的’构造函数’，只有对于函数的’构造调用’。 new的时候会做哪些事情： 创建一个全新的对象。 这个新对象会被执行 [[Prototype]] 连接。 这个新对象会绑定到函数调用的this。 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。 规则：使用构造调用的时候，this会自动绑定在new期间创建的对象上。 function foo(a) { this.a = a; // this绑定到bar上 } let bar = new foo(2); console.log(bar.a); // 2 this四种绑定规则的优先级如果在某个调用位置应用了多条规则，如何确定哪条规则生效？ obj.foo.call(obj2); // this指向obj2 显式绑定比隐式绑定优先级高。 new obj.foo(); // thsi指向new新创建的对象 new绑定比隐式绑定优先级高。 显式绑定和隐式绑定无法直接比较(会报错),默认绑定是不应用其他规则之后的兜底绑定所以优先级最低，最后的结果是： 显式绑定 &gt; 隐式绑定 &gt; 默认绑定 new绑定 &gt; 隐式绑定 &gt; 默认绑定 箭头函数的this指向不会使用上述的四条规则：function foo() { return () =&gt; { console.log(this.a); }; } let obj1 = { a: 2 }; let obj2 = { a: 22 }; let bar = foo.call(obj1); // foo this指向obj1 bar.call(obj2); // 输出2 这里执行箭头函数 并试图绑定this指向到obj2 从上述栗子可以得出，箭头函数的this规则： 箭头函数中的this继承于它外面第一个不是箭头函数的函数的this指向。 箭头函数的 this 一旦绑定了上下文，就不会被任何代码改变。 结语认真看完的话，相信你已经get到this的用法了，最后推荐一下《你不知道的JavaScript》，这本书真的很好，写的也很有趣，没看过的小伙伴抓紧入手了。 PS：目前离职中，大佬们有坑位可以介绍一下呀，base：上海长宁。 希望看完的朋友可以点个喜欢/关注，您的支持是对我最大的鼓励。个人blog and 掘金个人主页，如需转载，请放上原文链接并署名。码字不易，感谢支持！ 如果喜欢本文的话，欢迎关注我的订阅号，漫漫技术路，期待未来共同学习成长。 以上2018.6.30]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>js 机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[160行代码仿Vue实现极简双向绑定[详细注释]]]></title>
    <url>%2F2018%2F06%2F24%2F160%E8%A1%8C%E4%BB%A3%E7%A0%81%E4%BB%BFVue%E5%AE%9E%E7%8E%B0%E6%9E%81%E7%AE%80%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A-%E8%AF%A6%E7%BB%86%E6%B3%A8%E9%87%8A%2F</url>
    <content type="text"><![CDATA[前言现在的前端面试不管你用的什么框架，总会问你这个框架的双向绑定机制，有的甚至要求你现场实现一个双向绑定出来，那对于没有好好研究过这方面知识的同学来说，当然是很难的，接下来本文用160行代码带你实现一个极简的双向绑定机制。如果喜欢的话可以点波赞/关注，支持一下，希望大家看完本文可以有所收获。 本文是在面试题：你能写一个Vue的双向数据绑定吗？的基础上仔细研究+改动，并添加了详细注释，而成的。 个人博客了解一下：obkoro1.com 效果GIF： demo地址：codepen:仿Vue极简双向绑定 Github:仿Vue极简双向绑定 了解Object.defineProperty()：这个API是实现双向绑定的核心，最主要的作用是重写数据的get、set方法，现在的三大框架(vue react angular)也都是通过这个API来实现双向绑定的。 使用方式：let obj = { singer: &quot;周杰伦&quot; }; let value = &quot;青花瓷&quot;; Object.defineProperty(obj, &quot;music&quot;, { // value: &apos;七里香&apos;, // 设置属性的值 下面设置了get set函数 所以这里不能设置 configurable: false, // 是否可以删除属性 默认不能删除 // writable: true, // 是否可以修改对象 下面设置了get set函数 所以这里不能设置 enumerable: true, // music是否可以被枚举 默认是不能被枚举(遍历) // ☆ get,set设置时不能设置writable和value，要一对一对设置，交叉设置/同时存在 就会报错 get() { // 获取obj.music的时候就会调用get方法 // let value = &quot;强行设置get的返回值&quot;; // 打开注释 读取属性永远都是‘强行设置get的返回值’ return value; }, set(val) { // 将修改的值重新赋给song value = val; } }); console.log(obj.music); // 青花瓷 delete obj.music; // configurable设为false 删除无效 console.log(obj.music); // 青花瓷 obj.music = &quot;听妈妈的话&quot;; console.log(obj.music); // 听妈妈的话 for (let key in obj) { // 默认情况下通过defineProperty定义的属性是不能被枚举(遍历)的 // 需要设置enumerable为true才可以 否则只能拿到singer 属性 console.log(key); // singer, music } 示例demo：对，这里有个demo。 画一下重点： get,set设置时不能设置writable和value, 他们是一对情侣的存在，交叉设置或同时存在,会报错 通过defineProperty设置的属性，默认不能删除，不能遍历，当然你可以通过设置更改他们。 get、set 是函数，可以做的事情很多。 兼容性：IE 9,Firefox 4, Chorme 5,Opera 11.6,Safari 5.1 更详细的可以看一下MDN 实现思路：mvvm系列的双向绑定，关键步骤： 实现数据监听器Observer，用Object.defineProperty()重写数据的get、set，值更新就在set中通知订阅者更新数据。 实现模板编译Compile，深度遍历dom树，对每个元素节点的指令模板进行替换数据以及订阅数据。 实现Watch用于连接Observer和Compile，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图。 mvvm入口函数，整合以上三者。 流程图： 这部分讲的很清楚，现在有点懵逼也没关系，看完代码，自己copy下来玩一玩之后，回头再看实现思路，相信会有收获的。 具体代码实现：html结构：&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt; &lt;h3 v-bind=&quot;name&quot;&gt;&lt;/h3&gt; &lt;input type=&quot;text&quot; v-model=&quot;testData1&quot;&gt; &lt;h3&gt;{{ testData1 }}&lt;/h3&gt; &lt;input type=&quot;text&quot; v-model=&quot;testData2&quot;&gt; &lt;h3&gt;{{ testData2 }}&lt;/h3&gt; &lt;/div&gt; 看到这个模板，相信用过Vue的同学都不会陌生。 调用方法：采用类Vue方式来使用双向绑定： window.onload = function () { var app = new myVue({ el: &apos;#app&apos;, // dom data: { // 数据 testData1: &apos;仿Vue&apos;, testData2: &apos;极简双向绑定&apos;, name: &apos;OBKoro1&apos; } }) } 创建myVue函数：实际上这里是我们实现思路中的第四步，用于整合数据监听器this._observer()、指令解析器this._compile()以及连接Observer和Compile的_watcherTpl的watch池。 function myVue(options = {}) { // 防止没传，设一个默认值 this.$options = options; // 配置挂载 this.$el = document.querySelector(options.el); // 获取dom this._data = options.data; // 数据挂载 this._watcherTpl = {}; // watcher池 this._observer(this._data); // 传入数据，执行函数，重写数据的get set this._compile(this.$el); // 传入dom，执行函数，编译模板 发布订阅 }; Watcher函数:这是实现思路中的第三步，因为下方数据监听器_observer()需要用到Watcher函数，所以这里就先讲了。 像实现思路中所说的，这里起到了连接Observer和Compile的作用： 在模板编译_compile()阶段发布订阅 在赋值操作的时候，更新视图 // new Watcher() 为this._compile()发布订阅+ 在this._observer()中set(赋值)的时候更新视图 function Watcher(el, vm, val, attr) { this.el = el; // 指令对应的DOM元素 this.vm = vm; // myVue实例 this.val = val; // 指令对应的值 this.attr = attr; // dom获取值，如value获取input的值 / innerHTML获取dom的值 this.update(); // 更新视图 } Watcher.prototype.update = function () { this.el[this.attr] = this.vm._data[this.val]; // 获取data的最新值 赋值给dom 更新视图 } 没有看错，代码量就这么多，可能需要把整个代码连接起来，多看几遍才能够理解。 实现数据监听器_observer()：实现思路中的第一步，用Object.defineProperty()遍历data重写所有属性的get set。 然后在给对象的某个属性赋值的时候，就会触发set。 在set中我们可以监听到数据的变化，然后就可以触发watch更新视图。 myVue.prototype._observer = function (obj) { var _this = this; Object.keys(obj).forEach(key =&gt; { // 遍历数据 _this._watcherTpl[key] = { // 每个数据的订阅池() _directives: [] }; var value = obj[key]; // 获取属性值 var watcherTpl = _this._watcherTpl[key]; // 数据的订阅池 Object.defineProperty(_this._data, key, { // 双向绑定最重要的部分 重写数据的set get configurable: true, // 可以删除 enumerable: true, // 可以遍历 get() { console.log(`${key}获取值：${value}`); return value; // 获取值的时候 直接返回 }, set(newVal) { // 改变值的时候 触发set console.log(`${key}更新：${newVal}`); if (value !== newVal) { value = newVal; watcherTpl._directives.forEach((item) =&gt; { // 遍历订阅池 item.update(); // 遍历所有订阅的地方(v-model+v-bind+{{}}) 触发this._compile()中发布的订阅Watcher 更新视图 }); } } }) }); } 实现Compile 模板编译这里是实现思路中的第三步，让我们来总结一下这里做了哪些事情： 首先是深度遍历dom树，遍历每个节点以及子节点。 将模板中的变量替换成数据，初始化渲染页面视图。 把指令绑定的属性添加到对应的订阅池中 一旦数据有变动，收到通知，更新视图。 myVue.prototype._compile = function (el) { var _this = this, nodes = el.children; // 获取app的dom for (var i = 0, len = nodes.length; i &lt; len; i++) { // 遍历dom节点 var node = nodes[i]; if (node.children.length) { _this._compile(node); // 递归深度遍历 dom树 } // 如果有v-model属性，并且元素是INPUT或者TEXTAREA，我们监听它的input事件 if (node.hasAttribute(&apos;v-model&apos;) &amp;&amp; (node.tagName = &apos;INPUT&apos; || node.tagName == &apos;TEXTAREA&apos;)) { node.addEventListener(&apos;input&apos;, (function (key) { var attVal = node.getAttribute(&apos;v-model&apos;); // 获取v-model绑定的值 _this._watcherTpl[attVal]._directives.push(new Watcher( // 将dom替换成属性的数据并发布订阅 在set的时候更新数据 node, _this, attVal, &apos;value&apos; )); return function () { _this._data[attVal] = nodes[key].value; // input值改变的时候 将新值赋给数据 触发set=&gt;set触发watch 更新视图 } })(i)); } if (node.hasAttribute(&apos;v-bind&apos;)) { // v-bind指令 var attrVal = node.getAttribute(&apos;v-bind&apos;); // 绑定的data _this._watcherTpl[attrVal]._directives.push(new Watcher( // 将dom替换成属性的数据并发布订阅 在set的时候更新数据 node, _this, attrVal, &apos;innerHTML&apos; )) } var reg = /\{\{\s*([^}]+\S)\s*\}\}/g, txt = node.textContent; // 正则匹配{{}} if (reg.test(txt)) { node.textContent = txt.replace(reg, (matched, placeholder) =&gt; { // matched匹配的文本节点包括{{}}, placeholder 是{{}}中间的属性名 var getName = _this._watcherTpl; // 所有绑定watch的数据 getName = getName[placeholder]; // 获取对应watch 数据的值 if (!getName._directives) { // 没有事件池 创建事件池 getName._directives = []; } getName._directives.push(new Watcher( // 将dom替换成属性的数据并发布订阅 在set的时候更新数据 node, _this, placeholder, &apos;innerHTML&apos; )); return placeholder.split(&apos;.&apos;).reduce((val, key) =&gt; { return _this._data[key]; // 获取数据的值 触发get 返回当前值 }, _this.$el); }); } } } 完整代码&amp;demo地址GitHub完整代码 codepen:仿Vue极简双向绑定 Github:仿Vue极简双向绑定 如果觉得还不错的话，就给个Star⭐️鼓励一下我吧~ 结语本文只是一个简单的实现双向绑定的方法，主要目的是帮助各位同学理解mvvm框架的双向绑定机制，也并没有很完善，这里还是有很多缺陷，比如：没有实现数据的深度对数据进行get、set等。希望看完本文，大家能有所收获。 希望看完的朋友可以点个喜欢/关注，您的支持是对我最大的鼓励。个人blog and 掘金个人主页，如需转载，请放上原文链接并署名。码字不易，感谢支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。 如果喜欢本文的话，欢迎关注我的订阅号，漫漫技术路，期待未来共同学习成长。 以上2018.6.24 参考资料：剖析Vue原理&amp;实现双向绑定MVVM 面试题：你能写一个Vue的双向数据绑定吗？ 不好意思！耽误你的十分钟，让MVVM原理还给你]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS忍者秘籍中的定时器机制详解]]></title>
    <url>%2F2018%2F06%2F17%2FJS%E5%BF%8D%E8%80%85%E7%A7%98%E7%B1%8D%E4%B8%AD%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言前段时间刚看完《JS忍者秘籍》，虽说是15年出版的，有些东西是过时了，但像对原型链、闭包、正则、定时器之类的机制却是不会过时的，里面很多东西都讲的很细，还是值得一读的，本文将对这本书中对定时器机制的部分进行详细的解析，如果喜欢的话可以点波赞/关注，支持一下，希望大家看完本文可以有所收获。 个人博客了解一下：obkoro1.com 准备阅读本文之前，推荐先阅读Js 的事件循环(Event Loop)机制以及实例讲解这篇文章来理解背后发生的事情，本文对事件循环机制不会很仔细的讲解。 定时器解决的问题：由于JS的单线程特性，定时器提供了一种跳出单线程限制的方法，即让一段代码在一定毫秒之后，再异步执行。 设置和清除定时器：直接引用忍者秘籍中的图片： 注意： 定时器的时间间隔设为0，也会有几毫秒的延迟。 在使用setTimeout和setInterval的时候最好将其赋值给一个变量，以便取消定时器。 在使用Vue的时候，setTimeout和setInterval的this指向的是window对象，访问不到组件数据以及方法。 在使用Vue的时候，路由跳转并不会销毁setInterval，但是组件已经销毁了，这会导致问题。 在执行线程中setTimeout/setInterval无法保证准时执行回调函数的。 setInterval调用有可能会被废弃以及setInterval的连续执行 第三点和第四点的解决方法可以参考我之前写的Vue 实践过程中的几个问题。 接下来要讲的是第五点和第六点，这两点是最重要，也是本文要重点解析的内容。 执行线程中的定时器执行下面来看忍者秘籍中的栗子： 让我们看看这里发生了什么事情： 首先在0毫秒的时候有一个持续18毫秒的js代码块要执行。 然后在0毫秒的时候设了两个10毫秒延迟的定时器，setTimeout以及setInterval,setTimeout先设定。 在第6毫秒的时候有一个发生了鼠标单击事件。 事件排队。同时发生了这么多事情，由于js的单线程特性，当线程正在执行状态，有异步事件触发时，它就会排队，并且在线程空闲时才进行执行。 这里的异步事件包括：鼠标单击，定时器触发，ajax请求、promise等事件。 让我们回到栗子中： 栗子中首先有一个18毫秒的代码块要执行，在这18毫秒中只能执行这段代码块，其他事件触发了之后只能排队等待执行。 在代码块还在运行期间，第6毫秒的时候，发生了一个鼠标单击事件，以及第10毫秒时的setTimeout和setInterval两个处理程序，这三个事件不能立即执行，而是被添加到等待执行的队列中。 先进先出(先排队的先执行)18毫秒的时候代码块结束执行，有三个任务在排队等待执行，根据先进先出的原则，此时会先执行click事件，setTimeout和setInterval将继续排队等待执行。 setInterval调用被废弃在click事件执行时，第20毫秒处，第二个setInterval也到期了，因为此时已经click事件占用了线程，所以setInterval还是不能被执行，并且因为此时队列中已经有一个setInterval正在排队等待执行，所以这一次的setInterval的调用将被废弃。 浏览器不会对同一个setInterval处理程序多次添加到待执行队列。 setTimeout/setInterval无法保证准时执行回调函数click事件在第28毫秒处结束执行，有两个任务(setTimeout和setInterval)正在等待执行，遵循先进先出的原则，setTimeout早于setInterval设定，所以先执行setTimeout。 so:我们期望在第10毫秒处执行的setTimeout处理程序，最终会在第28毫秒处才开始执行，这就是上文提到的setTimeout/setInterval无法保证准时执行回调函数。 在30毫秒处，setInterval又触发了，因为队列中已经有setInterval在排队，所以这次的触发又作废了。 setInterval的连续执行setTimeout执行结束，在第36毫秒处，队列中的setInterval处理程序才开始执行，setInterval需要执行6毫秒。 在第40毫秒的时候setInterval再次触发，因为此时上一个setInterval正在执行期间，队列中并没有setInterval在排队，这次触发的setInterval将进入队列等候。 所以：setInterval的处理时长不能比设定的间隔长，否则setInterval将会没有间隔的重复执行 第42毫秒的时候，第一个setInterval结束，然后队列中的setInterval立即开始执行，在48毫秒的时候完成执行。然后50毫秒的时候再次触发setInterval，此时没有任务在排队，将会立即执行。 setTimeout按照一定的间隔周期性的触发定时器。上文说了，setInterval的处理时长不能比设定的间隔长，否则setInterval将会没有间隔的重复执行。 但是对这个问题，很多情况下，我们并不能清晰的把控处理程序所消耗的时长，为了我们能按照一定的间隔周期性的触发定时器，忍者秘籍中提供了下面这种使用方法： // 实际上我不止在忍者秘籍中见过，在很多地方都见过这种技术。 setTimeout(function repeatMe(){ // do something setTimeout(repeatMe,10); // 执行完处理程序的内容后，在末尾再间隔10毫秒来调用该程序，这样就能保证一定是10毫秒的周期调用 },10) 忍者秘籍中关于定时器的其他知识： 定时器不能非常细粒化的控制执行的时间，书中建议在15ms以上。 可以使用定时器来分解长时间运行的任务，这里可以自行谷歌。 任务队列只有排队这么简单吗？事实上，关于任务队列并不是只有简单的排队而已，忍者秘籍中提到为了方便，使用了这个概念，如果希望能更清晰的了解背后的机制，再次推荐阅读一下：Js 的事件循环(Event Loop)机制以及实例讲解， 结语这上面所有一切，都是由js单线程特性导致的，所以会有事件排队、先进先出、setInterval调用被废弃、定时器无法保证准时执行回调函数以及出现setInterval的连续执行，时刻记住这一特性，很多关于事件执行顺序的问题都能想的通，并且找出解决方法。 希望看完的朋友可以点个喜欢/关注，您的支持是对我最大的鼓励。个人blog and 掘金个人主页，如需转载，请放上原文链接并署名。码字不易，感谢支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。 如果喜欢本文的话，欢迎关注我的订阅号，漫漫技术路，期待未来共同学习成长。 以上2018.6.17 参考资料：JS忍者秘籍第8章:驯服线程和定时器]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>js定时器</tag>
        <tag>js 机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js 的事件循环(Event Loop)机制以及实例讲解]]></title>
    <url>%2F2018%2F06%2F17%2FJs-%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-Event-Loop-%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言大家都知道js是单线程的脚本语言，在同一时间，只能做同一件事，为了协调事件、用户交互、脚本、UI渲染和网络处理等行为，防止主线程阻塞，Event Loop方案应运而生… 个人博客了解一下：obkoro1.com 为什么js是单线程？js作为主要运行在浏览器的脚本语言，js主要用途之一是操作DOM。 在js高程中举过一个栗子，如果js同时有两个线程，同时对同一个dom进行操作，这时浏览器应该听哪个线程的，如何判断优先级？ 为了避免这种问题，js必须是一门单线程语言，并且在未来这个特点也不会改变。 执行栈与任务队列因为js是单线程语言，当遇到异步任务(如ajax操作等)时，不可能一直等待异步完成，再继续往下执行，在这期间浏览器是空闲状态，显而易见这会导致巨大的资源浪费。 执行栈当执行某个函数、用户点击一次鼠标，Ajax完成，一个图片加载完成等事件发生时，只要指定过回调函数，这些事件发生时就会进入执行栈队列中，等待主线程读取,遵循先进先出原则。 主线程要明确的一点是，主线程跟执行栈是不同概念，主线程规定现在执行执行栈中的哪个事件。 主线程循环：即主线程会不停的从执行栈中读取事件，会执行完所有栈中的同步代码。 当遇到一个异步事件后，并不会一直等待异步事件返回结果，而是会将这个事件挂在与执行栈不同的队列中，我们称之为任务队列(Task Queue)。 当主线程将执行栈中所有的代码执行完之后，主线程将会去查看任务队列是否有任务。如果有，那么主线程会依次执行那些任务队列中的回调函数。 不太理解的话，可以运行一下下面的代码，或者点击一下这个demo 结果是当a、b、c函数都执行完成之后，三个setTimeout才会依次执行。 let a = () =&gt; { setTimeout(() =&gt; { console.log(&apos;任务队列函数1&apos;) }, 0) for (let i = 0; i &lt; 5000; i++) { console.log(&apos;a的for循环&apos;) } console.log(&apos;a事件执行完&apos;) } let b = () =&gt; { setTimeout(() =&gt; { console.log(&apos;任务队列函数2&apos;) }, 0) for (let i = 0; i &lt; 5000; i++) { console.log(&apos;b的for循环&apos;) } console.log(&apos;b事件执行完&apos;) } let c = () =&gt; { setTimeout(() =&gt; { console.log(&apos;任务队列函数3&apos;) }, 0) for (let i = 0; i &lt; 5000; i++) { console.log(&apos;c的for循环&apos;) } console.log(&apos;c事件执行完&apos;) } a(); b(); c(); // 当a、b、c函数都执行完成之后，三个setTimeout才会依次执行 js 异步执行的运行机制。 所有任务都在主线程上执行，形成一个执行栈。 主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。 一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”。那些对应的异步任务，结束等待状态，进入执行栈并开始执行。 主线程不断重复上面的第三步。 宏任务与微任务:异步任务分为 宏任务（macrotask） 与 微任务 (microtask)，不同的API注册的任务会依次进入自身对应的队列中，然后等待 Event Loop 将它们依次压入执行栈中执行。 宏任务(macrotask)：： script(整体代码)、setTimeout、setInterval、UI 渲染、 I/O、postMessage、 MessageChannel、setImmediate(Node.js 环境) 微任务(microtask)： Promise、 MutaionObserver、process.nextTick(Node.js环境） Event Loop(事件循环)：Event Loop(事件循环)中，每一次循环称为 tick, 每一次tick的任务如下： 选择最先进入队列的宏任务(通常是script整体代码)，如果有则执行 检查是否存在 Microtask，如果存在则不停的执行，直至清空 microtask 队列 更新render(每一次事件循环，浏览器都可能会去更新渲染) 重复以上步骤 宏任务 &gt; 所有微任务 &gt; 宏任务，如下图所示： 从上图我们可以看出： 将所有任务看成两个队列：执行队列与事件队列。 执行队列是同步的，事件队列是异步的，宏任务放入事件列表，微任务放入执行队列之后，事件队列之前。 当执行完同步代码之后，就会执行位于执行列表之后的微任务，然后再执行事件列表中的宏任务 上面提到的demo结果可以这么理解：先执行script宏任务，执行完了之后，再执行其他两个定时器宏任务。 面试题实践下面这个题，很多人都应该看过/遇到过，重新来看会不会觉得清晰很多： // 执行顺序问题，考察频率挺高的，先自己想答案** setTimeout(function () { console.log(1); }); new Promise(function(resolve,reject){ console.log(2) resolve(3) }).then(function(val){ console.log(val); }) console.log(4); 根据本文的解析，我们可以得到: 先执行script同步代码 先执行new Promise中的console.log(2),then后面的不执行属于微任务 然后执行console.log(4) 执行完script宏任务后，执行微任务，console.log(3)，没有其他微任务了。 执行另一个宏任务，定时器，console.log(1)。 根据本文的内容，可以很轻松，且有理有据的猜出写出正确答案：2,4,3,1. 结语类似上文的面试题还有很多，实则都大同小异，只要掌握了事件循环的机制，这些问题都会变得很简单。 文章如有不正确的地方欢迎各位路过的大佬鞭策！希望大家看完可以有所收获，喜欢的话，赶紧点波订阅关注/喜欢。 看完的朋友可以点个喜欢/关注，您的支持是对我最大的鼓励。个人blog and 掘金个人主页，如需转载，请放上原文链接并署名。码字不易，感谢支持！ 如果喜欢本文的话，欢迎关注我的订阅号，漫漫技术路，期待未来共同学习成长。 以上2018.6.16 参考资料：详解JavaScript中的Event Loop（事件循环）机制 JavaScript中的事件循环 Event Loop JavaScript 运行机制详解：再谈Event Loop]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>js 机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析HTTP缓存的机制-浏览器缓存]]></title>
    <url>%2F2018%2F06%2F09%2F%E6%B5%85%E6%9E%90HTTP%E7%BC%93%E5%AD%98%E7%9A%84%E6%9C%BA%E5%88%B6-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[在浏览器众多缓存中的HTTP缓存可能很多人对这个的概念并没有很清晰，每个人都知道进入一次网页之后再刷新一次页面，加载速度会比首次加载快非常多，每个人都知道这是浏览器缓存的magic，但是对此背后的原因可能不甚了解… 当我们在谈论HTTP缓存时我们在谈论什么:我们实际上是在谈论下面这两种情况: 如上图，浏览器对静态资源的HTTP缓存有两种情况，一种是强缓存(本地缓存)，另一种是弱缓存(协商缓存)。 缓存流程：浏览器第一次请求资源时： 浏览器第一次请求资源时，必须下载所有的资源，然后根据响应的header内容来决定，如何缓存资源。可能采用的是强缓存，也可能是弱缓存 浏览器后续请求资源时的匹配流程： 由上图可以知道当浏览器请求一个静态资源时的HTTP流程： 强缓存阶段：先在本地查找该资源，如果发现该资源，并且其他限制也没有问题(比如:缓存有效时间)，就命中强缓存，返回200，直接使用强缓存，并且不会发送请求到服务器 弱缓存阶段：在本地缓存中找到该资源，发送一个http请求到服务器，服务器判断这个资源没有被改动过，则返回304，让浏览器使用该资源。 缓存失败阶段(重新请求)：当服务器发现该资源被修改过，或者在本地没有找到该缓存资源，服务器则返回该资源的数据。 强缓存与弱缓存的区别：获取资源形式： 都是从缓存中获取资源的。 状态码： 强缓存返回200(from cache),弱缓存返回304状态码 请求(最大区别)： 强缓存不发送请求，直接从缓存中取。 弱缓存需要发送一个请求，验证这个文件是否可以使用（有没有被改动过）。 强缓存：强缓存是利用Expires或者Cache-Control，让原始服务器为文件设置一个过期时间，在多长时间内可以将这些内容视为最新的。 若时间未过期，则命中强缓存，使用缓存文件不发送请求。 Cache-ControlCache-Control 是http1.1中为了弥补Expires的缺陷而加入的，当Expires和Cache-Control同时存在时，Cache-Control优先级高于Expires。 选项： 可缓存性: public： 服务器端和浏览器端都能缓存 private: 只能浏览器端缓存 no-cache: 强制浏览器在使用cache拷贝之前先提交一个http请求到源服务器进行确认。http请求没有减少，会减少一个响应体(文件内容),这种个选项类似弱缓存。 only-if-cached: 表明客户端只接受已缓存的响应，并且不要向原始服务器检查是否有更新的拷贝。 到期设置： max-age=60：设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。 这里是60秒 其他设置： no-store: 不缓存，使用协商缓存 must-revalidate: 缓存必须在使用之前验证旧资源的状态，并且不可使用过期资源。 更多设置，移动MDN 1234// 示例Cache-Control: no-cache, no-store, must-revalidateCache-Control:public, max-age=31536000Cache-Control: max-age=3600, must-revalidate http1.0时代的缓存 Expires+PragmaExpires用于设置缓存到期时间： 指定缓存到期GMT的绝对时间，如果设了max-age，max-age就会覆盖expires，如果expires到期需要重新请求。 1Expires:Sat, 09 Jun 2018 08:13:56 GMT 有一个问题是由于使用具体时间，如果时间表示出错或者没有转换到正确的时区都可能造成缓存生命周期出错。 Pragma禁用缓存： Pragma : no-cache 表示防止客户端缓存，需要强制从服务器获取最新的数据； 1Pragma : no-cache //只有这一个用法 禁用缓存，强制从服务器获取最新的数据； 强缓存命中 from memory cache &amp; from disk cache在测试的时候，看到命中强缓存时，有两种状态，200 (from memory cache) cache &amp; 200 (from disk cache)，于是去找了一下这两者的区别： memory cache: 将资源存到内存中，从内存中获取。 disk cache：将资源缓存到磁盘中，从磁盘中获取。 二者最大的区别在于：当退出进程时，内存中的数据会被清空，而磁盘的数据不会。 更详细的介绍推荐这篇文章 弱缓存：如果强缓存时间过期，或者没有设置，导致未命中的话。就进入到了弱缓存的阶段了， Last-Modified &amp; if-modified-since: Last-Modified与If-Modified-Since是一对报文头，属于http 1.0。 last-modified是web服务器认为文件的最后修改时间，last-modified是第一次请求文件的时候，服务器返回的一个属性。 1Last-Modified: Sat, 09 Jun 2018 08:13:56 GMT 第二次请求这个文件时，浏览器把If-Modified-Since发送给服务器，询问该时间之后文件是否被修改过。 1If-Modified-Since: Sat, 09 Jun 2018 08:13:56 GMT // 跟Last-Modified的值一样 ETag &amp; If-None-Match ETag与If-None-Match是一对报文，属于http 1.1。 ETag是一个文件的唯一标志符。就像一个哈希或者指纹，每个文件都有一个单独的标志，只要这个文件发生了改变，这个标志就会发生变化。 ETag机制类似于乐观锁机制，如果请求报文的ETag与服务器的不一致，则表示该资源已经被修改过来，需要发最新的内容给浏览器。 ETag也是首次请求的时候，服务器返回的: 1ETag: "8F759D4F67D66A7244638AD249675BE2" // 长这样 If-None-Match也是浏览器发送到服务器验证，文件是否改变的: 1If-None-Match: "8F759D4F67D66A7244638AD249675BE2" // 跟ETag的值一样 Etag/lastModified过程如下: 客户端第一次向服务器发起请求,服务器将附加Last-Modified/ETag到所提供的资源上去 当再一次请求资源,如果没有命中强缓存,在执行在验证时,将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。 服务器检查该Last-Modified或ETag，并判断出该资源页面自上次客户端请求之后还未被修改，返回响应304和一个空的响应体。 同时使用两个报文头:同时使用这两个报文头，两个都匹配才会命中弱缓存，否则将重新请求资源。 Etag 主要为了解决 Last-Modified 无法解决的一些问题： 一些文件也许内容并不改变(仅仅改变的修改时间)，这个时候我们不希望文件重新加载。（Etag值会触发缓存，Last-Modified不会触发） If-Modified-Since能检查到的粒度是秒级的，当修改非常频繁时，Last-Modified会触发缓存，而Etag的值不会触发，重新加载。 某些服务器不能精确的得到文件的最后修改时间。 用户操作行为与缓存F5刷新导致强缓存失效。 ctrl+F5强制刷新页面强缓存，弱缓存都会失效。 如何设置？一般是服务器端设置这些请求头的，我自己试了用阿里云服务器设置Cache-Control，设置一下很方便的。 小结通过网络重复请求资源既缓慢，成本又高，缓存和重用以前获取的资源的能力成为优化性能很关键的一个方面,也是大厂面试时很频繁出现的内容，掌握好这块知识点是非常重要的，希望本文能给你带来些收获。 文章如有不正确的地方欢迎各位路过的大佬鞭策！喜欢的话，赶紧点波订阅关注/喜欢。 鼓励我一下：觉得还不错的话，给我的项目点个star吧]]></content>
      <categories>
        <category>浏览器机制</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Http缓存</tag>
        <tag>浏览器缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你或许不知道Vue的这些小技巧]]></title>
    <url>%2F2018%2F06%2F03%2F%E4%BD%A0%E6%88%96%E8%AE%B8%E4%B8%8D%E7%9F%A5%E9%81%93Vue%E7%9A%84%E8%BF%99%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[前言用Vue开发一个网页并不难，但是也经常会遇到一些问题，其实大部分的问题都在文档中有所提及，再不然我们通过谷歌也能成功搜索到问题的答案，为了帮助小伙伴们提前踩坑，在遇到问题的时候，心里大概有个谱知道该如何去解决问题。这篇文章是将自己知道的一些小技巧，结合查阅资料整理成的一篇文章，如果喜欢的话可以点波赞/关注，支持一下，希望大家看完本文可以有所收获。 个人博客了解一下：obkoro1.com 文章内容总结: 组件style的scoped Vue 数组/对象更新 视图不更新 vue filters 过滤器的使用 列表渲染相关 深度watch与watch立即触发回调 这些情况下不要使用箭头函数 路由懒加载写法 路由的项目启动页和404页面 Vue调试神器:vue-devtools 组件style的scoped:问题：在组件中用js动态创建的dom，添加样式不生效。 场景: &lt;template&gt; &lt;div class=&quot;test&quot;&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; let a=document.querySelector(&apos;.test&apos;); let newDom=document.createElement(&quot;div&quot;); // 创建dom newDom.setAttribute(&quot;class&quot;,&quot;testAdd&quot; ); // 添加样式 a.appendChild(newDom); // 插入dom &lt;/script&gt; &lt;style scoped&gt; .test{ background:blue; height:100px; width:100px; } .testAdd{ background:red; height:100px; width:100px; } &lt;/style&gt; 结果： // test生效 testAdd 不生效 &lt;div data-v-1b971ada class=&quot;test&quot;&gt;&lt;div class=&quot;testAdd&quot;&gt;&lt;/div&gt;&lt;/div&gt; .test[data-v-1b971ada]{ // 注意data-v-1b971ada background:blue; height:100px; width:100px; } 原因: 当 &lt;style&gt; 标签有 scoped 属性时，它的 CSS 只作用于当前组件中的元素。 它会为组件中所有的标签和class样式添加一个scoped标识，就像上面结果中的data-v-1b971ada。 所以原因就很清楚了：因为动态添加的dom没有scoped添加的标识，没有跟testAdd的样式匹配起来，导致样式失效。 解决方式 推荐：去掉该组件的scoped 每个组件的css并不会很多，当设计到动态添加dom，并为dom添加样式的时候，就可以去掉scoped，会比下面的方法方便很多。 可以动态添加style // 上面的栗子可以这样添加样式 newDom.style.height=&apos;100px&apos;; newDom.style.width=&apos;100px&apos;; newDom.style.background=&apos;red&apos;; Vue 数组/对象更新 视图不更新很多时候，我们习惯于这样操作数组和对象: data() { // data数据 return { arr: [1,2,3], obj:{ a: 1, b: 2 } }; }, // 数据更新 数组视图不更新 this.arr[0] = &apos;OBKoro1&apos;; this.arr.length = 1; console.log(arr);// [&apos;OBKoro1&apos;]; // 数据更新 对象视图不更新 this.obj.c = &apos;OBKoro1&apos;; delete this.obj.a; console.log(obj); // {b:2,c:&apos;OBKoro1&apos;} 由于js的限制，Vue 不能检测以上数组的变动，以及对象的添加/删除，很多人会因为像上面这样操作，出现视图没有更新的问题。 解决方式: this.$set(你要改变的数组/对象，你要改变的位置/key，你要改成什么value) this.$set(this.arr, 0, &quot;OBKoro1&quot;); // 改变数组 this.$set(this.obj, &quot;c&quot;, &quot;OBKoro1&quot;); // 改变对象 如果还是不懂的话，可以看看这个codependemo。 数组原生方法触发视图更新: Vue可以监测到数组变化的，数组原生方法: splice()、 push()、pop()、shift()、unshift()、sort()、reverse() 意思是使用这些方法不用我们再进行额外的操作，视图自动进行更新。 推荐使用splice方法会比较好自定义,因为slice可以在数组的任何位置进行删除/添加操作，这部分可以看看我前几天写的一篇文章:【干货】js 数组详细操作方法及解析合集 替换数组/对象 比方说:你想遍历这个数组/对象，对每个元素进行处理，然后触发视图更新。 // 文档中的栗子: filter遍历数组，返回一个新数组，用新数组替换旧数组 example1.items = example1.items.filter(function (item) { return item.message.match(/Foo/) }) 举一反三：可以先把这个数组/对象保存在一个变量中，然后对这个变量进行遍历，等遍历结束后再用变量替换对象/数组。 并不会重新渲染整个列表: Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的、启发式的方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。 如果你还是很困惑，可以看看Vue文档中关于这部分的解释。 vue filters 过滤器的使用:过滤器，通常用于后台管理系统，或者一些约定类型，过滤。Vue过滤器用法是很简单，但是很多朋友可能都没有用过，这里稍微讲解一下。 在html模板中的两种用法： &lt;!-- 在双花括号中 --&gt; {{ message | filterTest }} &lt;!-- 在 `v-bind` 中 --&gt; &lt;div :id=&quot;message | filterTest&quot;&gt;&lt;/div&gt; 在组件script中的用法: export default { data() { return { message:1 } }, filters: { filterTest(value) { // value在这里是message的值 if(value===1){ return &apos;最后输出这个值&apos;; } } } } 用法就是上面讲的这样，可以自己在组件中试一试就知道了，很简单很好用的。 如果不想自己试，可以点这个demo里面修改代码就可以了，demo中包括过滤器串联、过滤器传参。 推荐看Vue过滤器文档，你会更了解它的。 列表渲染相关v-for循环绑定model: input在v-for中可以像如下这么进行绑定，我敢打赌很多人不知道。 // 数据 data() { return{ obj: { ob: &quot;OB&quot;, koro1: &quot;Koro1&quot; }, model: { ob: &quot;默认ob&quot;, koro1: &quot;默认koro1&quot; } } }, // html模板 &lt;div v-for=&quot;(value,key) in obj&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;model[key]&quot;&gt; &lt;/div&gt; // input就跟数据绑定在一起了，那两个默认数据也会在input中显示 为此，我做了个demo,你可以点进去试试。 一段取值的v-for 如果我们有一段重复的html模板要渲染，又没有数据关联，我们可以: &lt;div v-for=&quot;n in 5&quot;&gt; &lt;span&gt;这里会被渲染5次，渲染模板{{n}}&lt;/span&gt; &lt;/div&gt; v-if尽量不要与v-for在同一节点使用: v-for 的优先级比 v-if 更高,如果它们处于同一节点的话，那么每一个循环都会运行一遍v-if。 如果你想根据循环中的每一项的数据来判断是否渲染，那么你这样做是对的: &lt;li v-for=&quot;todo in todos&quot; v-if=&quot;todo.type===1&quot;&gt; {{ todo }} &lt;/li&gt; 如果你想要根据某些条件跳过循环，而又跟将要渲染的每一项数据没有关系的话，你可以将v-if放在v-for的父节点： // 根据elseData是否为true 来判断是否渲染，跟每个元素没有关系 &lt;ul v-if=&quot;elseData&quot;&gt; &lt;li v-for=&quot;todo in todos&quot;&gt; {{ todo }} &lt;/li&gt; &lt;/ul&gt; // 数组是否有数据 跟每个元素没有关系 &lt;ul v-if=&quot;todos.length&quot;&gt; &lt;li v-for=&quot;todo in todos&quot;&gt; {{ todo }} &lt;/li&gt; &lt;/ul&gt; &lt;p v-else&gt;No todos left!&lt;/p&gt; 如上，正确使用v-for与v-if优先级的关系，可以为你节省大量的性能。 深度watch与watch立即触发回调watch很多人都在用，但是这watch中的这两个选项deep、immediate，或许不是很多人都知道，我猜。 选项：deep 在选项参数中指定 deep: true，可以监听对象中属性的变化。 选项：immediate 在选项参数中指定 immediate: true, 将立即以表达式的当前值触发回调，也就是默认触发一次。 watch: { obj: { handler(val, oldVal) { console.log(&apos;属性发生变化触发这个回调&apos;,val, oldVal); }, deep: true // 监听这个对象中的每一个属性变化 }, step: { // 属性 //watch handler(val, oldVal) { console.log(&quot;默认触发一次&quot;, val, oldVal); }, immediate: true // 默认触发一次 }, }, 这两个选项可以同时使用，另外：是的，又有一个demo。 还有下面这一点需要注意。 这些情况下不要使用箭头函数: 不应该使用箭头函数来定义一个生命周期方法 不应该使用箭头函数来定义 method 函数 不应该使用箭头函数来定义计算属性函数 不应该使用箭头函数来定义 watcher 函数 不应该对 data 属性使用箭头函数 不应该使用箭头函数来定义 watcher 函数 示例： // 上面watch的栗子： handler:(val, oldVal)=&gt; { // 可以执行 console.log(&quot;默认触发一次&quot;, val, oldVal); }, // method： methods: { plus: () =&gt; { // 可以执行 // do something } } // 生命周期: created:()=&gt;{ // 可以执行 console.log(&apos;lala&apos;,this.obj) }, 是的，没错，这些都能执行。 but: 箭头函数绑定了父级作用域的上下文，this 将不会按照期望指向 Vue 实例。 也就是说，你不能使用this来访问你组件中的data数据以及method方法了。 this将会指向undefined。 路由懒加载写法:// 我所采用的方法，个人感觉比较简洁一些，少了一步引入赋值。 const router = new VueRouter({ routes: [ path: &apos;/app&apos;, component: () =&gt; import(&apos;./app&apos;), // 引入组件 ] }) // Vue路由文档的写法: const app = () =&gt; import(&apos;./app.vue&apos;) // 引入组件 const router = new VueRouter({ routes: [ { path: &apos;/app&apos;, component: app } ] }) 文档的写法在于问题在于：如果我们的路由比较多的话，是不是要在路由上方引入赋值十几行组件？ 第一种跟第二种方法相比就是把引入赋值的一步，直接写在component上面，本质上是一样的。两种方式都可以的，大家自由选择哈。 路由的项目启动页和404页面实际上这也就是一个设置而已: export default new Router({ routes: [ { path: &apos;/&apos;, // 项目启动页 redirect:&apos;/login&apos; // 重定向到下方声明的路由 }, { path: &apos;*&apos;, // 404 页面 component: () =&gt; import(&apos;./notFind&apos;) // 或者使用component也可以的 }, ] }) 比如你的域名为:www.baidu.com 项目启动页指的是: 当你进入www.baidu.com，会自动跳转到login登录页。 404页面指的是: 当进入一个没有 声明/没有匹配 的路由页面时就会跳转到404页面。 比如进入www.baidu.com/testRouter,就会自动跳转到notFind页面。 当你没有声明一个404页面，进入www.baidu.com/testRouter，显示的页面是一片空白。 Vue调试神器:vue-devtools每次调试的时候，写一堆console是否很烦？想要更快知道组件/Vuex内数据的变化？ 那么这款尤大开发的调试神器:vue-devtools，你真的要了解一下了。 这波稳赚不赔，真的能提高开发效率。 安装方法： 谷歌商店+科学上网,搜索vue-devtools即可安装。 不会科学上网？手动安装 安装之后： 在chrome开发者工具中会看一个vue的一栏，如下对我们网页应用内数据变化，组件层级等信息能够有更准确快速的了解。 前几个月也写过一篇类似的:Vue 实践过程中的几个问题 结语本文的内容很多都在Vue文档里面有过说明，推荐大家可以多看看Vue文档，不止看教程篇，还有文档的Api什么的，也都可以看。然后其实还有两三点想写的，因为预计篇幅都会比较长一点，所以准备留到以后的文章里面吧~ 文章如有不正确的地方欢迎各位路过的大佬鞭策！希望大家看完可以有所收获，喜欢的话，赶紧点波订阅关注/喜欢。 看完的朋友可以点个喜欢/关注，您的支持是对我最大的鼓励。个人blog and 掘金个人主页，如需转载，请放上原文链接并署名。码字不易，感谢支持！ 如果喜欢本文的话，欢迎关注我的订阅号，漫漫技术路，期待未来共同学习成长。 以上2018.6.3 参考资料：Vue文档 Vue Api文档]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 数组详细操作方法及解析合集]]></title>
    <url>%2F2018%2F05%2F30%2Fjs-%E6%95%B0%E7%BB%84%E8%AF%A6%E7%BB%86%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95%E5%8F%8A%E8%A7%A3%E6%9E%90%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[前言在开发中，数组的使用场景非常多，平日中也涉及到很多数组的api/相关操作，一直也没有对这块内容进行一块整理总结，很多时候就算用过几次这个api，在开发中也很容易忘记，还是要谷歌一下。所以就希望对这块内容有一个比较系统性的总结，在这背景下，就有了本篇文章，如果喜欢的话可以点波赞/关注，支持一下，希望大家看完本文可以有所收获。 个人博客了解一下：obkoro1.com 本文篇幅较长，建议点赞保存再看，也便于日后翻阅。 创建一个数组:// 字面量方式: // 这个方法也是我们最常用的，在初始化数组的时候 相当方便 var a = [3, 11, 8]; // [3,11,8]; // 构造器: // 实际上 new Array === Array,加不加new 一点影响都没有。 var a = Array(); // [] var a = Array(3); // [undefined,undefined,undefined] var a = Array(3,11,8); // [ 3,11,8 ] ES6 Array.of() 返回由所有参数值组成的数组定义：返回由所有参数值组成的数组，如果没有参数，就返回一个空数组。 目的：Array.of() 出现的目的是为了解决上述构造器因参数个数不同，导致的行为有差异的问题。 let a = Array.of(3, 11, 8); // [3,11,8] let a = Array.of(3); // [3] ES6 Arrar.from() 将两类对象转为真正的数组定义：用于将两类对象转为真正的数组（不改变原对象，返回新的数组）。 参数： 第一个参数(必需):要转化为真正数组的对象。 第二个参数(可选): 类似数组的map方法，对每个元素进行处理，将处理后的值放入返回的数组。 第三个参数(可选): 用来绑定this。 // 1. 对象拥有length属性 let obj = {0: &apos;a&apos;, 1: &apos;b&apos;, 2:&apos;c&apos;, length: 3}; let arr = Array.from(obj); // [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]; // 2. 部署了 Iterator接口的数据结构 比如:字符串、Set、NodeList对象 let arr = Array.from(&apos;hello&apos;); // [&apos;h&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;] let arr = Array.from(new Set([&apos;a&apos;,&apos;b&apos;])); // [&apos;a&apos;,&apos;b&apos;] 方法:数组原型提供了非常多的方法，这里分为三类来讲，一类会改变原数组的值，一类是不会改变原数组，以及数组的遍历方法。 改变原数组的方法(9个):let a = [1,2,3]; ES5: a.pop()/ a.shift()/ a.push()/ a.unshift()/ a.reverse()/ a.splice()/ a.sort() ES6: a.copyWithin() / a.fill 对于这些能够改变原数组的方法，要注意避免在循环遍历中改变原数组的选项，比如: 改变数组的长度，导致遍历的长度出现问题。 pop() 删除一个数组中的最后的一个元素定义: pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。 参数: 无。 let a = [1,2,3]; let item = a.pop(); // 3 console.log(a); // [1,2] shift() 删除数组的第一个元素定义: shift()方法删除数组的第一个元素，并返回这个元素。 参数: 无。 let a = [1,2,3]; let item = a.shift(); // 1 console.log(a); // [2,3] push() 向数组的末尾添加元素定义：push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。 参数: item1, item2, …, itemX ,要添加到数组末尾的元素 let a = [1,2,3]; let item = a.push(&apos;末尾&apos;); // 4 console.log(a); // [1,2,3,&apos;末尾&apos;] unshift()定义：unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。 参数: item1, item2, …, itemX ,要添加到数组开头的元素 let a = [1,2,3]; let item = a.unshift(&apos;开头&apos;); // 4 console.log(a); // [&apos;开头&apos;,1,2,3] reverse() 颠倒数组中元素的顺序定义: reverse() 方法用于颠倒数组中元素的顺序。 参数: 无 let a = [1,2,3]; a.reverse(); console.log(a); // [3,2,1] splice() 添加/删除数组元素定义： splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目 语法： array.splice(index,howmany,item1,.....,itemX) 参数: index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。 howmany：必需。要删除的项目数量。如果设置为 0，则不会删除项目。 item1, …, itemX： 可选。向数组添加的新项目。 返回值: 如果有元素被删除,返回包含被删除项目的新数组。 eg1:删除元素 let a = [1, 2, 3, 4, 5, 6, 7]; let item = a.splice(0, 3); // [1,2,3] console.log(a); // [4,5,6,7] // 从数组下标0开始，删除3个元素 let item = a.splice(-1, 3); // [7] // 从最后一个元素开始删除3个元素，因为最后一个元素，所以只删除了7 eg2: 删除并添加 let a = [1, 2, 3, 4, 5, 6, 7]; let item = a.splice(0,3,&apos;添加&apos;); // [1,2,3] console.log(a); // [&apos;添加&apos;,4,5,6,7] // 从数组下标0开始，删除3个元素，并添加元素&apos;添加&apos; let b = [1, 2, 3, 4, 5, 6, 7]; let item = b.splice(-2,3,&apos;添加1&apos;,&apos;添加2&apos;); // [6,7] console.log(b); // [1,2,3,4,5,&apos;添加1&apos;,&apos;添加2&apos;] // 从数组最后第二个元素开始，删除3个元素，并添加两个元素&apos;添加1&apos;、&apos;添加2&apos; eg3: 不删除只添加: let a = [1, 2, 3, 4, 5, 6, 7]; let item = a.splice(0,0,&apos;添加1&apos;,&apos;添加2&apos;); // [] 没有删除元素，返回空数组 console.log(a); // [&apos;添加1&apos;,&apos;添加2&apos;,1,2,3,4,5,6,7] let b = [1, 2, 3, 4, 5, 6, 7]; let item = b.splice(-1,0,&apos;添加1&apos;,&apos;添加2&apos;); // [] 没有删除元素，返回空数组 console.log(b); // [1,2,3,4,5,6,&apos;添加1&apos;,&apos;添加2&apos;,7] 在最后一个元素的前面添加两个元素 从上述三个栗子可以得出: 数组如果元素不够，会删除到最后一个元素为止 操作的元素，包括开始的那个元素 可以添加很多个元素 添加是在开始的元素前面添加的 sort() 数组排序定义: sort()方法对数组元素进行排序，并返回这个数组。 参数可选: 规定排序顺序的比较函数。 默认情况下sort()方法没有传比较函数的话，默认按字母升序，如果不是元素不是字符串的话，会调用toString()方法将元素转化为字符串的Unicode(万国码)位点，然后再比较字符。 // 字符串排列 看起来很正常 var a = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]; a.sort(); // [&quot;Apple&quot;,&quot;Banana&quot;,&quot;Mango&quot;,&quot;Orange&quot;] // 数字排序的时候 因为转换成Unicode字符串之后，有些数字会比较大会排在后面 这显然不是我们想要的 var a = [10, 1, 3, 20,25,8]; console.log(a.sort()) // [1,10,20,25,3,8]; 比较函数的两个参数： sort的比较函数有两个默认参数，要在函数中接收这两个参数，这两个参数是数组中两个要比较的元素，通常我们用 a 和 b 接收两个将要比较的元素： 若比较函数返回值&lt;0，那么a将排到b的前面; 若比较函数返回值=0，那么a 和 b 相对位置不变； 若比较函数返回值&gt;0，那么b 排在a 将的前面； 对于sort()方法更深层级的内部实现以及处理机制可以看一下这篇文章深入了解javascript的sort方法 sort排序常见用法： 数组元素为数字的升序、降序: var array = [10, 1, 3, 4,20,4,25,8]; // 升序 a-b &lt; 0 a将排到b的前面，按照a的大小来排序的 // 比如被减数a是10，减数是20 10-20 &lt; 0 被减数a(10)在减数b(20)前面 array.sort(function(a,b){ return a-b; }); console.log(array); // [1,3,4,4,8,10,20,25]; // 降序 被减数和减数调换了 20-10&gt;0 被减数b(20)在减数a(10)的前面 array.sort(function(a,b){ return b-a; }); console.log(array); // [25,20,10,8,4,4,3,1]; 数组多条件排序 var array = [{id:10,age:2},{id:5,age:4},{id:6,age:10},{id:9,age:6},{id:2,age:8},{id:10,age:9}]; array.sort(function(a,b){ if(a.id === b.id){// 如果id的值相等，按照age的值降序 return b.age - a.age }else{ // 如果id的值不相等，按照id的值升序 return a.id - b.id } }) // [{&quot;id&quot;:2,&quot;age&quot;:8},{&quot;id&quot;:5,&quot;age&quot;:4},{&quot;id&quot;:6,&quot;age&quot;:10},{&quot;id&quot;:9,&quot;age&quot;:6},{&quot;id&quot;:10,&quot;age&quot;:9},{&quot;id&quot;:10,&quot;age&quot;:2}] 自定义比较函数，天空才是你的极限 类似的：运用好返回值，我们可以写出任意符合自己需求的比较函数 var array = [{name:&apos;Koro1&apos;},{name:&apos;Koro1&apos;},{name:&apos;OB&apos;},{name:&apos;Koro1&apos;},{name:&apos;OB&apos;},{name:&apos;OB&apos;}]; array.sort(function(a,b){ if(a.name === &apos;Koro1&apos;){// 如果name是&apos;Koro1&apos; 返回-1 ，-1&lt;0 a排在b的前面 return -1 }else{ // 如果不是的话，a排在b的后面 return 1 } }) // [{&quot;name&quot;:&quot;Koro1&quot;},{&quot;name&quot;:&quot;Koro1&quot;},{&quot;name&quot;:&quot;Koro1&quot;},{&quot;name&quot;:&quot;OB&quot;},{&quot;name&quot;:&quot;OB&quot;},{&quot;name&quot;:&quot;OB&quot;}] ES6: copyWithin() 指定位置的成员复制到其他位置定义: 在当前数组内部，将指定位置的成员复制到其他位置,并返回这个数组。 语法: array.copyWithin(target, start = 0, end = this.length) 参数: 三个参数都是数值，如果不是，会自动转为数值. target（必需）：从该位置开始替换数据。如果为负值，表示倒数。 start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。 end（可选）：到该位置前停止读取数据，默认等于数组长度。使用负数可从数组结尾处规定位置。 浏览器兼容(MDN): chrome 45,Edge 12,Firefox32,Opera 32,Safari 9, IE 不支持 eg: // -2相当于3号位，-1相当于4号位 [1, 2, 3, 4, 5].copyWithin(0, -2, -1) // [4, 2, 3, 4, 5] var a=[&apos;OB1&apos;,&apos;Koro1&apos;,&apos;OB2&apos;,&apos;Koro2&apos;,&apos;OB3&apos;,&apos;Koro3&apos;,&apos;OB4&apos;,&apos;Koro4&apos;,&apos;OB5&apos;,&apos;Koro5&apos;] // 2位置开始被替换,3位置开始读取要替换的 5位置前面停止替换 a.copyWithin(2,3,5) // [&quot;OB1&quot;,&quot;Koro1&quot;,&quot;Koro2&quot;,&quot;OB3&quot;,&quot;OB3&quot;,&quot;Koro3&quot;,&quot;OB4&quot;,&quot;Koro4&quot;,&quot;OB5&quot;,&quot;Koro5&quot;] 从上述栗子: 第一个参数是开始被替换的元素位置 要替换数据的位置范围:从第二个参数是开始读取的元素，在第三个参数前面一个元素停止读取 数组的长度不会改变 读了几个元素就从开始被替换的地方替换几个元素 ES6: fill() 填充数组定义: 使用给定值，填充一个数组。 参数: 第一个元素(必须): 要填充数组的值 第二个元素(可选): 填充的开始位置,默认值为0 第三个元素(可选)：填充的结束位置，默认是为this.length MDN浏览器兼容 [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7) // [7, 7, 7] [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7, 1, 2) // [&apos;a&apos;, 7, &apos;c&apos;] 不改变原数组的方法(8个):ES5： join、toLocateString、toStrigin、slice、cancat、indexOf、lastIndexOf、 ES7： includes join() 数组转字符串定义: join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。 语法: array.join(str) 参数: str(可选): 指定要使用的分隔符，默认使用逗号作为分隔符。 let a= [&apos;hello&apos;,&apos;world&apos;]; let str=a.join(); // &apos;hello,world&apos; let str2=a.join(&apos;+&apos;); // &apos;hello+world&apos; 使用join方法或者下文说到的toString方法时，当数组中的元素也是数组或者是对象时会出现什么情况？ let a= [[&apos;OBKoro1&apos;,&apos;23&apos;],&apos;test&apos;]; let str1=a.join(); // OBKoro1,23,test let b= [{name:&apos;OBKoro1&apos;,age:&apos;23&apos;},&apos;test&apos;]; let str2 = b.join(); // [object Object],test // 对象转字符串推荐JSON.stringify(obj); 所以，join()/toString()方法在数组元素是数组的时候，会将里面的数组也调用join()/toString(),如果是对象的话，对象会被转为[object Object]字符串。 toLocaleString() 数组转字符串定义: 返回一个表示数组元素的字符串。该字符串由数组中的每个元素的 toLocaleString() 返回值经调用 join() 方法连接（由逗号隔开）组成。 语法: array.toLocaleString() 参数：无。 let a=[{name:&apos;OBKoro1&apos;},23,&apos;abcd&apos;,new Date()]; let str=a.toLocaleString(); // [object Object],23,abcd,2018/5/28 下午1:52:20 如上述栗子：调用数组的toLocaleString方法，数组中的每个元素都会调用自身的toLocaleString方法，对象调用对象的toLocaleString,Date调用Date的toLocaleString。 toString() 数组转字符串 不推荐定义: toString() 方法可把数组转换为由逗号链接起来的字符串。 语法: array.toString() 参数: 无。 该方法的效果和join方法一样，都是用于数组转字符串的，但是与join方法相比没有优势，也不能自定义字符串的分隔符，因此不推荐使用。 值得注意的是：当数组和字符串操作的时候，js 会调用这个方法将数组自动转换成字符串 let b= [ &apos;toString&apos;,&apos;演示&apos;].toString(); // toString,演示 let a= [&apos;调用toString&apos;,&apos;连接在我后面&apos;]+&apos;啦啦啦&apos;; // 调用toString,连接在我后面啦啦啦 slice() 浅拷贝数组的元素定义： 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。 注意：字符串也有一个slice() 方法是用来提取字符串的，不要弄混了。 语法: array.slice(begin, end); 参数: begin(可选): 索引数值,接受负值，从该索引处开始提取原数组中的元素,默认值为0。 end(可选):索引数值(不包括),接受负值，在该索引处前结束提取原数组元素，默认值为数组末尾(包括最后一个元素)。 let a= [&apos;hello&apos;,&apos;world&apos;]; let b=a.slice(0,1); // [&apos;hello&apos;] a[0]=&apos;改变原数组&apos;; console.log(a,b); // [&apos;改变原数组&apos;,&apos;world&apos;] [&apos;hello&apos;] b[0]=&apos;改变拷贝的数组&apos;; console.log(a,b); // [&apos;改变原数组&apos;,&apos;world&apos;] [&apos;改变拷贝的数组&apos;] 如上：新数组是浅拷贝的，元素是简单数据类型，改变之后不会互相干扰。 如果是复杂数据类型(对象,数组)的话，改变其中一个，另外一个也会改变。 let a= [{name:&apos;OBKoro1&apos;}]; let b=a.slice(); console.log(b,a); // [{&quot;name&quot;:&quot;OBKoro1&quot;}] [{&quot;name&quot;:&quot;OBKoro1&quot;}] // a[0].name=&apos;改变原数组&apos;; // console.log(b,a); // [{&quot;name&quot;:&quot;改变原数组&quot;}] [{&quot;name&quot;:&quot;改变原数组&quot;}] // b[0].name=&apos;改变拷贝数组&apos;,b[0].koro=&apos;改变拷贝数组&apos;; // [{&quot;name&quot;:&quot;改变拷贝数组&quot;,&quot;koro&quot;:&quot;改变拷贝数组&quot;}] [{&quot;name&quot;:&quot;改变拷贝数组&quot;,&quot;koro&quot;:&quot;改变拷贝数组&quot;}] 原因在定义上面说过了的：slice()是浅拷贝，对于复杂的数据类型浅拷贝，拷贝的只是指向原数组的指针，所以无论改变原数组，还是浅拷贝的数组，都是改变原数组的数据。 cancat定义： 方法用于合并两个或多个数组，返回一个新数组。 语法： var newArr =oldArray.concat(arrayX,arrayX,......,arrayX) 参数： arrayX（必须）：该参数可以是具体的值，也可以是数组对象。可以是任意多个。 eg1: let a = [1, 2, 3]; let b = [4, 5, 6]; //连接两个数组 let newVal=a.concat(b); // [1,2,3,4,5,6] // 连接三个数组 let c = [7, 8, 9] let newVal2 = a.concat(b, c); // [1,2,3,4,5,6,7,8,9] // 添加元素 let newVal3 = a.concat(&apos;添加元素&apos;,b, c,&apos;再加一个&apos;); // [1,2,3,&quot;添加元素&quot;,4,5,6,7,8,9,&quot;再加一个&quot;] // 合并嵌套数组 会浅拷贝嵌套数组 let d = [1,2 ]; let f = [3,[4]]; let newVal4 = d.concat(f); // [1,2,3,[4]] ES6扩展运算符...合并数组： 因为ES6的语法更简洁易懂，所以现在合并数组我大部分采用...来处理，...运算符可以实现cancat的每个栗子，且更简洁和具有高度自定义数组元素位置的效果。 let a = [2, 3, 4, 5] let b = [ 4,...a, 4, 4] console.log(a,b); // [2, 3, 4, 5] [4,2,3,4,5,4,4] 更多关于扩展符的详细内容移步阮一峰大神的ECMAScript 6 入门 indexOf() 查找数组是否存在某个元素，返回下标定义: 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 语法: array.indexOf(searchElement,fromIndex) 参数: searchElement(必须):被查找的元素 fromIndex(可选):开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为0。 严格相等的搜索: 数组的indexOf搜索跟字符串的indexOf不一样,数组的indexOf使用严格相等===搜索元素，即数组元素要完全匹配才能搜索成功。 注意：indexOf()不能识别NaN eg: let a=[&apos;啦啦&apos;,2,4,24,NaN] console.log(a.indexOf(&apos;啦&apos;)); // -1 console.log(a.indexOf(&apos;NaN&apos;)); // -1 console.log(a.indexOf(&apos;啦啦&apos;)); // 0 使用场景： 数组去重 根据获取的数组下标执行操作，改变数组中的值等。 判断是否存在，执行操作。 lastIndexOf() 查找指定元素在数组中的最后一个位置定义: 方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找） 语法: arr.lastIndexOf(searchElement,fromIndex) 参数: searchElement(必须): 被查找的元素 fromIndex(可选): 逆向查找开始位置，默认值数组的长度-1，即查找整个数组。 关于fromIndex有三个规则: 正值。如果该值大于或等于数组的长度，则整个数组会被查找。 负值。将其视为从数组末尾向前的偏移。(比如-2，从数组最后第二个元素开始往前查找) 负值。其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。 let a=[&apos;OB&apos;,4,&apos;Koro1&apos;,1,2,&apos;Koro1&apos;,3,4,5,&apos;Koro1&apos;]; // 数组长度为10 // let b=a.lastIndexOf(&apos;Koro1&apos;,4); // 从下标4开始往前找 返回下标2 // let b=a.lastIndexOf(&apos;Koro1&apos;,100); // 大于或数组的长度 查找整个数组 返回9 // let b=a.lastIndexOf(&apos;Koro1&apos;,-11); // -1 数组不会被查找 let b=a.lastIndexOf(&apos;Koro1&apos;,-9); // 从第二个元素4往前查找，没有找到 返回-1 ES7 includes() 查找数组是否包含某个元素 返回布尔定义： 返回一个布尔值，表示某个数组是否包含给定的值 语法： array.includes(searchElement,fromIndex=0) 参数： searchElement(必须):被查找的元素 fromIndex(可选):默认值为0，参数表示搜索的起始位置，接受负值。正值超过数组长度，数组不会被搜索，返回false。负值绝对值超过长数组度，重置从0开始搜索。 includes方法是为了弥补indexOf方法的缺陷而出现的: indexOf方法不能识别NaN indexOf方法检查是否包含某个值不够语义化，需要判断是否不等于-1，表达不够直观 eg: let a=[&apos;OB&apos;,&apos;Koro1&apos;,1,NaN]; // let b=a.includes(NaN); // true 识别NaN // let b=a.includes(&apos;Koro1&apos;,100); // false 超过数组长度 不搜索 // let b=a.includes(&apos;Koro1&apos;,-3); // true 从倒数第三个元素开始搜索 // let b=a.includes(&apos;Koro1&apos;,-100); // true 负值绝对值超过数组长度，搜索整个数组 兼容性(MDN): chrome47, Firefox 43,Edge 14,Opera 34, Safari 9,IE 未实现。 遍历方法(12个):js中遍历数组并不会改变原始数组的方法总共有12个: ES5： forEach、every 、some、 fliter、map、reduce、reduceRight、 ES6： find、findIndex、keys、values、entries 关于遍历： 关于遍历的效率，可以看一下这篇详解JS遍历 尽量不要在遍历的时候，修改后面要遍历的值 尽量不要在遍历的时候修改数组的长度（删除/添加） forEach定义: 按升序为数组中含有效值的每一项执行一次回调函数。 语法： array.forEach(function(currentValue, index, arr), thisValue) 参数: function(必须): 数组中每个元素需要调用的函数。 // 回调函数的参数 1. currentValue(必须),数组当前元素的值 2. index(可选), 当前元素的索引值 3. arr(可选),数组对象本身 thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为undefined 关于forEach()你要知道： 无法中途退出循环，只能用return退出本次回调，进行下一次回调。 它总是返回 undefined值,即使你return了一个值。 下面类似语法同样适用这些规则1. 对于空数组是不会执行回调函数的 2. 对于已在迭代过程中删除的元素，或者空元素会跳过回调函数 3. 遍历次数再第一次循环前就会确定，再添加到数组中的元素不会被遍历。 4. 如果已经存在的值被改变，则传递给 callback 的值是遍历到他们那一刻的值。 eg: let a = [1, 2, ,3]; // 最后第二个元素是空的，不会遍历(undefined、null会遍历) let obj = { name: &apos;OBKoro1&apos; }; let result = a.forEach(function (value, index, array) { a[3] = &apos;改变元素&apos;; a.push(&apos;添加到尾端，不会被遍历&apos;) console.log(value, &apos;forEach传递的第一个参数&apos;); // 分别打印 1 ,2 ,改变元素 console.log(this.name); // OBKoro1 打印三次 this绑定在obj对象上 // break; // break会报错 return value; // return只能结束本次回调 会执行下次回调 console.log(&apos;不会执行，因为return 会执行下一次循环回调&apos;) }, obj); console.log(result); // 即使return了一个值,也还是返回undefined // 回调函数也接受接头函数写法 every 检测数组所有元素是否都符合判断条件定义: 方法用于检测数组所有元素是否都符合函数定义的条件 语法： array.every(function(currentValue, index, arr), thisValue) 参数:(这几个方法的参数，语法都类似) function(必须): 数组中每个元素需要调用的函数。 // 回调函数的参数 1. currentValue(必须),数组当前元素的值 2. index(可选), 当前元素的索引值 3. arr(可选),数组对象本身 thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为undefined 方法返回值规则: 如果数组中检测到有一个元素不满足，则整个表达式返回 false，且剩余的元素不会再进行检测。 如果所有元素都满足条件，则返回 true。= eg: function isBigEnough(element, index, array) { return element &gt;= 10; // 判断数组中的所有元素是否都大于10 } let result = [12, 5, 8, 130, 44].every(isBigEnough); // false let result = [12, 54, 18, 130, 44].every(isBigEnough); // true // 接受箭头函数写法 [12, 5, 8, 130, 44].every(x =&gt; x &gt;= 10); // false [12, 54, 18, 130, 44].every(x =&gt; x &gt;= 10); // true some 数组中的是否有满足判断条件的元素定义：数组中的是否有满足判断条件的元素 语法： array.some(function(currentValue, index, arr), thisValue) 参数:(这几个方法的参数，语法都类似) function(必须): 数组中每个元素需要调用的函数。 // 回调函数的参数 1. currentValue(必须),数组当前元素的值 2. index(可选), 当前元素的索引值 3. arr(可选),数组对象本身 thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为undefined 方法返回值规则： 如果有一个元素满足条件，则表达式返回true, 剩余的元素不会再执行检测。 如果没有满足条件的元素，则返回false。 function isBigEnough(element, index, array) { return (element &gt;= 10); //数组中是否有一个元素大于 10 } let result = [2, 5, 8, 1, 4].some(isBigEnough); // false let result = [12, 5, 8, 1, 4].some(isBigEnough); // true filter 过滤原始数组，返回新数组定义: 返回一个新数组, 其包含通过所提供函数实现的测试的所有元素。 语法： let new_array = arr.filter(function(currentValue, index, arr), thisArg) 参数:(这几个方法的参数，语法都类似) function(必须): 数组中每个元素需要调用的函数。 // 回调函数的参数 1. currentValue(必须),数组当前元素的值 2. index(可选), 当前元素的索引值 3. arr(可选),数组对象本身 thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为undefined eg: let a = [32, 33, 16, 40]; let result = a.filter(function (value, index, array) { return value &gt;= 18; // 返回a数组中所有大于18的元素 }); console.log(result,a);// [32,33,40] [32,33,16,40] map 对数组中的每个元素进行处理，返回新的数组定义：创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 语法： let new_array = arr.map(function(currentValue, index, arr), thisArg) 参数:(这几个方法的参数，语法都类似) function(必须): 数组中每个元素需要调用的函数。 // 回调函数的参数 1. currentValue(必须),数组当前元素的值 2. index(可选), 当前元素的索引值 3. arr(可选),数组对象本身 thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为undefined eg: let a = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;]; let result = a.map(function (value, index, array) { return value + &apos;新数组的新元素&apos; }); console.log(result, a); // [&quot;1新数组的新元素&quot;,&quot;2新数组的新元素&quot;,&quot;3新数组的新元素&quot;,&quot;4新数组的新元素&quot;] [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;] reduce 为数组提供累加器，合并为一个值定义：reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，最终合并为一个值。 语法： array.reduce(function(total, currentValue, currentIndex, arr), initialValue) 参数： function(必须): 数组中每个元素需要调用的函数。 // 回调函数的参数 1. total(必须)，初始值, 或者上一次调用回调返回的值 2. currentValue(必须),数组当前元素的值 3. index(可选), 当前元素的索引值 4. arr(可选),数组对象本身 initialValue(可选): 指定第一次回调 的第一个参数。 回调第一次执行时: 如果 initialValue 在调用 reduce 时被提供，那么第一个 total 将等于 initialValue，此时 currentValue 等于数组中的第一个值； 如果 initialValue 未被提供，那么 total 等于数组中的第一个值，currentValue 等于数组中的第二个值。此时如果数组为空，那么将抛出 TypeError。 如果数组仅有一个元素，并且没有提供 initialValue，或提供了 initialValue 但数组为空，那么回调不会被执行，数组的唯一值将被返回。 eg: // 数组求和 let sum = [0, 1, 2, 3].reduce(function (a, b) { return a + b; }, 0); // 6 // 将二维数组转化为一维 将数组元素展开 let flattened = [[0, 1], [2, 3], [4, 5]].reduce( (a, b) =&gt; a.concat(b), [] ); // [0, 1, 2, 3, 4, 5] reduceRight 从右至左累加这个方法除了与reduce执行方向相反外，其他完全与其一致，请参考上述 reduce 方法介绍。 ES6：find()&amp; findIndex() 根据条件找到数组成员find()定义：用于找出第一个符合条件的数组成员，并返回该成员，如果没有符合条件的成员，则返回undefined。 findIndex()定义：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 这两个方法 语法： let new_array = arr.find(function(currentValue, index, arr), thisArg) let new_array = arr.findIndex(function(currentValue, index, arr), thisArg) 参数:(这几个方法的参数，语法都类似) function(必须): 数组中每个元素需要调用的函数。 // 回调函数的参数 1. currentValue(必须),数组当前元素的值 2. index(可选), 当前元素的索引值 3. arr(可选),数组对象本身 thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为undefined 这两个方法都可以识别NaN,弥补了indexOf的不足. eg: // find let a = [1, 4, -5, 10].find((n) =&gt; n &lt; 0); // 返回元素-5 let b = [1, 4, -5, 10,NaN].find((n) =&gt; Object.is(NaN, n)); // 返回元素NaN // findIndex let a = [1, 4, -5, 10].findIndex((n) =&gt; n &lt; 0); // 返回索引2 let b = [1, 4, -5, 10,NaN].findIndex((n) =&gt; Object.is(NaN, n)); // 返回索引4 浏览器兼容(MDN):Chrome 45,Firefox 25,Opera 32, Safari 8, Edge yes, ES6 keys()&amp;values()&amp;entries() 遍历键名、遍历键值、遍历键名+键值定义：三个方法都返回一个新的 Array Iterator 对象，对象根据方法不同包含不同的值。 语法： array.keys() array.values() array.entries() 参数：无。 遍历栗子(摘自ECMAScript 6 入门)： for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) { console.log(index); } // 0 // 1 for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) { console.log(elem); } // &apos;a&apos; // &apos;b&apos; for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) { console.log(index, elem); } // 0 &quot;a&quot; // 1 &quot;b&quot; 在for..of中如果遍历中途要退出，可以使用break退出循环。 如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历: let letter = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]; let entries = letter.entries(); console.log(entries.next().value); // [0, &apos;a&apos;] console.log(entries.next().value); // [1, &apos;b&apos;] console.log(entries.next().value); // [2, &apos;c&apos;] entries()浏览器兼容性(MDN):Chrome 38, Firefox 28,Opera 25,Safari 7.1 keys()浏览器兼容性(MDN):Chrome 38, Firefox 28,Opera 25,Safari 8, 注意:目前只有Safari 9支持,，其他浏览器未实现，babel转码器也还未实现 结语呼~终于写好了，断断续续，上班也偷偷划水的写了几天，虽说很辛苦，但是现在对数组操作方法，整体清晰了很多，各个API也理解的更好一点了，收获颇多，文章如有不正确的地方欢迎各位大佬鞭策！希望大家看完可以有所收获，喜欢的话，赶紧点波订阅关注/喜欢。 希望看完的朋友可以点个喜欢/关注，您的支持是对我最大的鼓励。个人blog and 掘金个人主页，如需转载，请放上原文链接并署名。码字不易，感谢支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。 如果喜欢本文的话，欢迎关注我的订阅号，漫漫技术路，期待未来共同学习成长。 以上2018.5.30 参考资料：ECMAScript6 入门 数组的扩展 JavaScript Array数组相关汇总 深入了解javascript的sort方法 【深度长文】JavaScript数组所有API全解密 详解JS遍历 判断一个变量是否为数组 在 JavaScript 中，如何求出两个数组的交集和差集？]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你对CSS权重真的足够了解吗？]]></title>
    <url>%2F2018%2F05%2F20%2F%E4%BD%A0%E5%AF%B9CSS%E6%9D%83%E9%87%8D%E7%9C%9F%E7%9A%84%E8%B6%B3%E5%A4%9F%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[前言css权重很多人都听过，也了解一些，但是很多人对具体的规则或者说再深如一些关于css权重的问题，可能会不那么清楚。日常开发中，或多或少都会遇到css规则不生效的问题，为了让我们能够减少调试css规则的时间，深刻理解css权重，就十分关键了。如果喜欢的话可以点波赞/关注，支持一下，希望大家看完本文可以有所收获。 个人博客了解一下：obkoro1.com 权重规则总结: !important 优先级最高，但也会被权重高的important所覆盖 行内样式总会覆盖外部样式表的任何样式(除了!important) 单独使用一个选择器的时候，不能跨等级使css规则生效 如果两个权重不同的选择器作用在同一元素上，权重值高的css规则生效 如果两个相同权重的选择器作用在同一元素上：以后面出现的选择器为最后规则. 权重相同时，与元素距离近的选择器生效 css权重优先级用来干嘛？在同一个元素使用不同的方式，声明了相同的一条或多条css规则，浏览器会通过权重来判断哪一种方式的声明，与这个元素最为相关，从而在该元素上应用这个声明方式声明的所有css规则。 权重的五个等级及其权重 !important; 行内样式; ID选择器, 权重:100; class,属性选择器和伪类选择器，权重:10; 属性选择器指的是:根据元素的属性及属性值来选择元素，比如button的type属性等。 伪类选择器: :active :focus等选项. 标签选择器和伪元素选择器，权重:1; 伪元素选择器： :before :after 等级关系:!important&gt;行内样式&gt;ID选择器 &gt; 类选择器 | 属性选择器 | 伪类选择器 &gt; 元素选择器 权重规则：1.不推荐使用!important不推荐使用!important，因为!important根本没有结构与上下文可言，并且很多时候权重的问题，就是因为不知道在哪里定义了一个!important而导致的。 覆盖important:虽然我们应该尽量避免使用!important，但你应该知道如何覆盖important，加点权重就可以实现，codepen的demo //!important 优先级最高，但也会被权重高的important所覆盖 &lt;button id=&quot;a&quot; class=&quot;a&quot;&gt;aaa&lt;/button&gt; #a{ background: blue !important; /* id的important覆盖class的important*/ } .a{ background: red !important; } 2.行内样式总会覆盖外部样式表的任何样式,会被!important覆盖3.单独使用一个选择器的时候，不能跨等级使css规则生效无论多少个class组成的选择器，都没有一个ID选择器权重高。类似的，无论多少个元素组成的选择器，都没有一个class选择器权重高、无论多少个ID组成的选择器，都没有行内样式权重高。 codepen的demo; 在demo中使用了11个class组成一个选择器，最后还是一个ID选择器，设置的样式生效。 可以想象在玄幻小说的那种等级制度，没有突破那个等级，就没有可比性。所以权重是在双方处于同一等级的情况下，才开始对比。 4.如果两个权重不同的选择器作用在同一元素上，权重值高的css规则生效选择器可能会包含一个或者多个与权重相关的计算点，若经过权重值计算得到的权重值越大，则认为这个选择器的权重高。举一个简单的栗子: .test #test{ } // id 100+class 10=110; .test #test span{} // id 100+class 10+span 1=111; .test #test .sonClass{} // id 100+class 10+class 10=120; //生效 5.如果两个相同权重的选择器作用在同一元素上：以后面出现的选择器为最后规则.demo &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;test&quot; id=&quot;test&quot;&gt; &lt;span &gt;啦啦啦&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; #test span{ color:blue; } #app span{ // 生效 因为后面出现 color: red; } 6.权重相同时，与元素距离近的选择器生效比如不同的style表，head头部等,来看下面的栗子： #content h1 { // css样式表中 padding: 5px; } &lt;style type=&quot;text/css&quot;&gt; #content h1 { // html头部 因为html头部离元素更近一点，所以生效 padding: 10px; } &lt;/style&gt; 建议： 避免使用!important; 利用id增加选择器权重; 减少选择器的个数（避免层层嵌套）; 结语以上就是本文关于css权重的内容了，如有不对的地方欢迎指正！希望大家看完可以有所收获，喜欢的话，赶紧点波订阅关注/喜欢。 希望看完的朋友可以点个喜欢/关注，您的支持是对我最大的鼓励。个人blog and 掘金个人主页，如需转载，请放上原文链接并署名。码字不易，感谢支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。 如果喜欢本文的话，可以关注一下我的订阅号，漫漫技术路，期待未来共同学习成长。 以上2018.5.19 参考资料：你应该知道的一些事情——CSS权重 深入CSS优先级 css优先级]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于input的一些问题解决方法分享]]></title>
    <url>%2F2018%2F05%2F12%2F%E5%85%B3%E4%BA%8Einput%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[前言input是我们接受来自用户的数据常用标签，在前端开发中，相信每个人都会用到这个标签，所以在开发过程中也时候也会遇到一些问题，本文的内容是我在跟input相爱相杀过程中产生的，在此记录分享一下。如果喜欢的话可以点波赞/关注，支持一下，希望大家看完本文可以有所收获。 本文内容包括： 移动端底部input被弹出的键盘遮挡。 控制input显/隐密码。 在input中输入emoji表情导致请求失败。 input多行输入显示换行。 输入框首尾清除空格-trim() 在input中监听键盘事件 移动端底部input被弹出的键盘遮挡input输入框是通过position:fixed一直放在页面底部，当点击input进行输入的时候，就会出现如下图片情况（有的机型会遮挡一些）。 当时这个问题是去年在ios中遇到的，在最新版的ios系统中，貌似解决了这个bug，但是为了向下兼容以及防止其他其他机型也出现这个问题，大家可以稍微记一下这个解决方法。 在解决这个问题的时候，有试过下面这种方法: 在input的focus事件中，开启一个定时器，然后每隔300毫秒进行一次document.body.scrollTop=document.body.scrollHeight的调整，运行3次即可。 当时还以为解决了，但是当你底部评论区还有很多内容，你每次点击input，想要输入的时候，整个页面通过scrollTop就会不断的向下滚动，这个体验不用说自己也知道是相当失败的，然后就再去找解决方法，结果就有了下面这个。 Element.scrollIntoView()Element.scrollIntoView():方法让当前的元素滚动到浏览器窗口的可视区域内。 document.querySelector(&apos;#inputId&apos;).scrollIntoView(); //只要在input的点击事件，或者获取焦点的事件中，加入这个api就好了 这个api还可以设置对齐方法，选择将input放在屏幕的上方/下方，类似的api还有:Element.scrollIntoViewIfNeeded()，这两个是解决同一个问题的，选择一个用就可以了。 控制input显/隐密码这个就很简单了，只需更改input的type属性值就可以了。可以看一下codepen的demo //点击函数，获取dom，判断更改属性。 show(){ let input=document.getElementById(&quot;inputId&quot;); if(input.type==&quot;password&quot;){ input.type=&apos;text&apos;; }else{ input.type=&apos;password&apos;; } } 在input中输入emoji表情导致请求失败现在用户输入emoji简直已经成为了习惯，如果前后端没有对emoji表情进行处理，那么用户在上传的时候，就会请求失败。 通常这个问题是后端那边处理比较合适的，前端是做不了这件事的，或者说很难做这件事。 之前看过一篇文章，这个文章里面讲了怎么在上传和拿数据下来的时候不会报错，但是不能在显示的时候转换为表情。 ps:之前拿微信用户名的时候，有些人可能在微信昵称上面就会包含表情，如果后端没对表情处理转换，那么普通请求也会出错。 之所以说这个，当表单请求错误的时候各位如果实在找不到问题可以往这方面考虑一下，我真的被坑过的o(╥﹏╥)o。 textarea多行回车换行，显示的时候换行设置：在使用textarea标签输入多行文本的时候，如果没有对多行文本显示处理，会导致没有换行的情况,就比如下面这种情况，用户在textarea是有换行的。 Css属性:white-spacewhite-space 属性用于设置如何处理元素内的空白，其中包括空白符和换行符。 只要在显示内容的地方将该属性设置为white-space: pre-line或者white-space:pre-wrap，多行文本就可以换行了。 设置之后，显示效果： 输入框首尾清除空格-trim()输入框清除首尾空格是input较为常见的需求，通常在上传的时候将首尾空格去除掉。一般使用:字符串的原生方法trim() 从一个字符串的两端删除空白字符。 trim() 方法并不影响原字符串本身，它返回的是一个新的字符串。 原生清除方法://原生方法获取值，清除首尾空格上传str2 var str2 = document.getElementById(&quot;inputId&quot;).trim(); Vue清除方法：Vue提供了修饰符删除首尾空格， 加了修饰符.trim会自动过滤用户输入的首尾空白字符 &lt;input v-model.trim=&quot;msg&quot;&gt; 貌似angular也提供了类似过滤的方法，感兴趣的可以自己去查一下。 在input中监听键盘事件在用户登录或者搜索框的时候，一般都会监听键盘事件绑定回车按键，来执行登录/搜索 等操作。 原生绑定:&lt;input onkeydown=&quot;keydownMsg(event)&quot; type=&quot;text&quot; /&gt; function keydownMsg(key) { keyCode = key.keyCode; //获取按键代码 if (keyCode == 13) { //判断按下的是否为回车键 // 在input上监听到回车 do something } } Vue按键修饰符Vue为监听键盘事件，提供了按键修饰符，并且为常用的按键提供了别名，使用方法如下:当回车按键在input中被按下的时候，会触发里面的函数。 &lt;input @keyup.enter=&quot;enterActive&quot;&gt; 结语上述内容就是我遇到的一些input问题的解决方式以及跟input相关的一些东西，如果有什么错误，欢迎指正！希望大家看完可以有所收获，喜欢的话，赶紧点波订阅关注/喜欢，方便以后查找复制粘贴，233。 希望看完的朋友可以点个喜欢/关注，您的支持是对我最大的鼓励。个人blog and 掘金个人主页，如需转载，请放上原文链接并署名。码字不易，感谢支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。 如果喜欢本文的话，可以关注一下我刚开的订阅号，漫漫技术路，期待未来共同学习成长。 以上2018.5.12 参考资料：Element.scrollIntoView() 移动前端手机输入法自带emoji表情字符处理 white-space String.prototype.trim() Vue按键修饰符 keyCode键码值表]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Vue</tag>
        <tag>CSS</tag>
        <tag>键盘事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何判断用户浏览器以及一些前端常用的正则表单验证]]></title>
    <url>%2F2018%2F05%2F05%2F%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%94%A8%E6%88%B7%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[前言在我们做用户授权登录(微信,qq授权)，以及根据对应浏览器做对应的操作的时候，经常会遇到需要判断用户使用的浏览器的需求，以及在需要用户输入信息的时候，有需要验证的一些正则。如果喜欢的话可以点波赞/关注，支持一下，希望大家看完本文可以有所收获。 个人博客了解一下：obkoro1.com 判断用户浏览器navigator.userAgent判断用户所使用的浏览器主要用到的api是navigator.userAgent，这是一个只读的字符串，声明了浏览器用于 HTTP 请求的用户代理头的值，不同浏览器的userAgent值都不相同，所以我们可以根据这个字符串来判断用户是从哪个浏览器进入的。 判断方式：下面两个是刚做的demo获取的值，仔细观察下面两个字符串，会发现有些值是不一样的，并且浏览器特有的，依据这个我们就可以作为不同浏览器的判断条件。 QQ内置浏览器的userAgent值：mozilla/5.0 (iphone; cpu iphone os 11_1_2 like mac os x) applewebkit/604.3.5 (khtml, like gecko) mobile/15b202 qq/7.5.8.422 v1_iph_sq_7.5.8_1_app_a pixel/1080 core/uiwebview device/apple(iphone 8plus) nettype/wifi qbwebviewtype/1 微信内置浏览器的userAgent值：mozilla/5.0 (iphone; cpu iphone os 11_1_2 like mac os x) applewebkit/604.3.5 (khtml, like gecko) mobile/15b202 micromessenger/6.6.6 nettype/wifi language/zh_cn 示例使用方式，直接使用这个api读取值，然后根据事先观察userAgent字符串的不同之处来判断： let url = navigator.userAgent.toLowerCase(); //使用toLowerCase将字符串全部转为小写 方便我们判断使用 if (url.indexOf(&quot;15b202 qq&quot;) &gt; -1) { //单独判断QQ内置浏览器 alert(&quot;QQ APP 内置浏览器，做你想做的操作&quot;); } if (url.indexOf(&quot;micromessenger&quot;) &gt; -1) { //单独判断微信内置浏览器 alert(&apos;微信内置浏览器，做你想做的操作&apos;); } if (url.indexOf(&quot;15b202&quot;) &gt; -1) { //判断微信内置浏览器，QQ内置浏览器 alert(&quot;QQ和微信内置浏览器，做你想做的操作&quot;); } 上面判断了微信和QQ的内置浏览器，如果有更多不同的需求的话，可以按照上面的方式，先获取userAgent的字符串，然后再根据观察，使用indexOf判断是否含有指定的字符，来对不同浏览器进行不同的操作。 一部分正则判断用户输入信息为了避免用户胡乱输入就通过验证，很多时候我们都会采用正则表达式来验证一下用户输入的信息是否符合规范。这部分的内容基本上是在网上收集来的，这里跟大家一起分享一下，有需要的可以记在自己的有道云里面。 如何验证？验证的方式当然是很多了，这里推荐采用test()方法来验证。 let isTrue=RegExpObject.test(string);// RegExpObject为正则 string是要检测的字符串 // 如果字符串 string 中含有与 RegExpObject 匹配的文本，则返回 true，否则返回 false。 if (isTrue){ //验证成功 do something }elseP{ //验证失败 } 身份证号码正则表达式： 第一代身份证只有15位数，第二代身份证有18位数，各位按照需求来选择表达式。 //第二代身份证号码正则 let isTrue = /^[1-9]\d{5}(18|19|20)\d{2}((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/; //第一代身份证正则表达式(15位) let isTrue=/^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$/; 手机号码正则表达式：时间截止为：2018年1月11日 移动号段：134 135 136 137 138 139 147 148 150 151 152 157 158 159 172 178 182 183 184 187 188 198 联通号段：130 131 132 145 146 155 156 166 171 175 176 185 186 电信号段：133 149 153 173 174 177 180 181 189 199 虚拟运营商：170 let isTrue = /^(13[0-9]|14[5-9]|15[012356789]|166|17[0-8]|18[0-9]|19[8-9])[0-9]{8}$/; 邮箱正则表达式：let isTrue =/^([A-Za-z0-9_\-\.\u4e00-\u9fa5])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]{2,8})$/; 用户名正则:////用户名正则，4到16位（字母，数字，下划线，减号） let isTrue = /^[a-zA-Z0-9_-]{4,16}$/; 密码正则:密码正则，以字母开头，长度在6~18之间，只能包含字母、数字和下划线 let isTrue =^[a-zA-Z]\w{5,17}$; 强密码正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符 let isTrue = /^.*(?=.{6,})(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&amp;*? ]).*$/; QQ号码正则:let isTrue = /^[1-9][0-9]{4,10}$/; 微信号码正则://微信号正则，6至20位，以字母开头，字母，数字，减号，下划线 let isTrue = /^[a-zA-Z]([-_a-zA-Z0-9]{5,19})+$/; 特殊字符检测正则:let isTrue= /[&quot;&apos;&lt;&gt;%;)(&amp;+]+-!！@#$~/; 域名正则:let isTrue=[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?; 车牌号码正则:let isTrue = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/; 包含中文正则:let isTrue = /[\u4E00-\u9FA5]/; //这个可以用于验证用户的真实姓名。 护照正则:let isTrue=/^(P\d{7}|G\d{7,8}|TH\d{7,8}|S\d{7,8}|A\d{7,8}|L\d{7,8}|\d{9}|D\d+|1[4,5]\d{7})$/; 固定电话正则：let isTrue=(\(\d{3,4}\)|\d{3,4}-|\s)?\d{8}; IP地址正则:let isTrue=\d+\.\d+\.\d+\.\d+; 邮政编码正则:let isTrue=[1-9]{1}(\d+){5}; 经纬度正则//经度正则 let isTrue=/^(\-|\+)?(((\d|[1-9]\d|1[0-7]\d|0{1,3})\.\d{0,6})|(\d|[1-9]\d|1[0-7]\d|0{1,3})|180\.0{0,6}|180)$/; //纬度正则 let isTrue=/^(\-|\+)?([0-8]?\d{1}\.\d{0,6}|90\.0{0,6}|[0-8]?\d{1}|90)$/; 常用的正则表达式大概就是上面这些了，如果大家还有其他干货的话，欢迎在评论区留言分享一下。 结语以上就是本文的内容了，希望大家看完可以有所收获，喜欢的话，赶紧点波订阅关注/喜欢，以后方便查找复制粘贴，233。 希望看完的朋友可以点个喜欢/关注，您的支持是对我最大的鼓励。最后：如需转载，请放上原文链接并署名。码字不易，感谢支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。 个人blog and 掘金个人主页 如果喜欢本文的话，可以关注一下我刚开的订阅号，共同学习成长。 以上2018.5.5 参考资料：HTML DOM userAgent 属性 JavaScript test() 方法 2018最新手机号码正则表达式 身份证号码的正则表达式 JavaScript手机号码格式验证方法 邮箱/邮件地址的正则表达式及分析 前端表单验证常用的15个JS正则表达式 前端开发中的 正则表达式 及常用正则表达式大全 密码强度的正则表达式]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端将数据转化为弹幕效果的实现方式]]></title>
    <url>%2F2018%2F04%2F30%2F%E5%89%8D%E7%AB%AF%E5%B0%86%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%BC%B9%E5%B9%95%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言这个需求如题，大体上是将文章的评论数据，在文章的首图上面以弹幕的形式出现。当时在做这个需求的时候，花了挺多精力的，踩了很多坑，现将弹幕的实现思路写出来，如果喜欢的话可以点波赞/关注，支持一下，希望大家看完本文可以有所收获。 个人博客了解一下：obkoro1.com 实现效果： 实现原理：实现弹幕的原理，并不算太复杂，耗费一些时间，怼一怼应该都可以做出来。 获取弹幕数据。 将弹幕设置为四个通道，每个通道最多只能出现两条弹幕。 使用setInterval动态设置dom的left属性。 使用dom的offsetWidth和屏幕的宽度判断元素是否滚动超出屏幕，然后移除dom。 实现步骤：1. 首先看一下html的结构。&lt;div class=&quot;detailImg&quot;&gt; &lt;img src=&quot;url&quot;/&gt; &lt;div id=&quot;barrageDiv&quot;&gt; &lt;div id=&quot;barrageLayer1&quot;&gt;&lt;/div&gt; &lt;div id=&quot;barrageLayer2&quot;&gt;&lt;/div&gt; &lt;div id=&quot;barrageLayer3&quot;&gt;&lt;/div&gt; &lt;div id=&quot;barrageLayer4&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--detailImg 设置relative， barrageDiv设置z-index在图片上面，以及图片的位置--&gt; &lt;!---barrageLayer1~4 主要设置了一个top属性让四个div在各自的水平线上，形成四个通道-&gt; 关于这里的css样式，关键点都在上面说了，就注意一下上面通道是怎样形成的，就可以了。具体的样式也就不贴出来了，就根据各自的需求来吧。 2.获取弹幕所需要的数据。要实现弹幕效果肯定需要有数据，这里就是发请求了。 获取数据时，要考虑数据量，一次不可能全部都获取，可以一次获取一部分，当数据要加载完的时候，再次请求数据。 这里要记录数据数据是否全部请求完成，如果请求完成，就可以不再发送数据，直接用之前获取的全部数据就可以了。 3.执行弹幕的函数。弹幕数据获取后，就执行弹幕运行的函数，因为我在写弹幕函数的时候，设置了很多数据状态，这里就大概讲一下实现思路和关键部分代码。 弹幕函数包括的功能： 定时获取数据(判断数据是否加载完毕) 定时发射弹幕(判断通道是否闲置),传入弹幕所需要的内容，用户头像等。 创建dom内容，根据传参生成弹幕div，设置style属性，根据控制弹幕数据数组的下标将div插入对应的dom中。 采用定时器移动dom，这里是根据内容长度定义弹幕的移动速度。 移动弹幕的过程中判断四个通道是否处于闲置状态，当dom移动出了屏幕，移动dom并且清除定时器。 function barrage(){ //第一部分先判断数据是否加载完成 这里是一个定时器，设置为15秒。 //如果数据还未加载完毕，就再次运行请求数据的接口，请求的页数可以 数组/每次请求的条数+1 //数据加载完毕就清除定时器。（我将定时器都保存在vue 组件的data里面） 清除的时候clearInterval(this.data); //定时发射 _this.barrageStatus.divStatus.intervalid=setInterval( selfTime,1100); function selfTime() { if(_this.dataNum&gt;=_this.barrageStatus.data.length){ //当dataNum大于等于数组的数量时，弹幕从头再来一遍 _this.dataNum=0; } //设置四个通道的变量，当这几个变量为false的时候，才可发射 if(divStatus.div1===false){ //这里只演示其中一个变量 divStatus.div1=true; _this.dataNum++; return barrageOut(_this.barrageStatus.data[_this.dataNum-1].content,_this.barrageStatus.data[_this.dataNum-1].commentator.headImgUrl,_this.dataNum); } }; // 创建弹幕内容，自定义弹幕移动速度 function barrageOut(text,imgUrl,num) { //text：弹幕的内容,imgUrl:用户的头像,num:数组的第几个 if(num%4==1){ //根据数组下标 创建对应通道的节点 这里也演示其中一个 barrageLayer=document.getElementById(&apos;barrageLayer1&apos;); } // 创建dom内容 定义dom style样式 let divBox = document.createElement(&apos;div&apos;); let divBoxImg=document.createElement(&apos;span&apos;); let divBoxText=document.createElement(&apos;span&apos;); divBox.setAttribute(&apos;class&apos;,&apos;barrageDivClass&apos;); divBoxText.innerHTML=text; divBox.appendChild(divBoxImg); divBoxImg.setAttribute(&apos;class&apos;,&apos;barrageDivClass_img&apos;); divBoxImg.style.backgroundImage=`url(${imgUrl})`; divBox.appendChild(divBoxText); divBox.style.left=document.body.clientWidth+2000+&apos;px&apos;;// 初始化left位置,一开始在屏幕的右侧 barrageLayer.appendChild(divBox); // 定时器移动dom，形成弹幕 let time,l=0; time= setInterval(function(){ if(text.length&lt;15){ // 这里可以根据需求自定义弹幕加载的速度 l=l-1; }else{ l=l-2; } //通过减少left属性移动这个div 从右往左移动 divBox.style.left = document.body.clientWidth+l+&apos;px&apos;; let delDiv=()=&gt;{ if(num%4==1){ //在移动弹幕的过程中判断四个通道是否处于闲置状态 这里只演示其中一个 barrageLayer=document.getElementById(&apos;barrageLayer1&apos;); if(barrageLayer.childNodes.length&lt;2){ //判断弹幕数量，如果小于2，设为false，上面的定时器可以继续发射弹幕 divStatus.div1=false; }else{ divStatus.div1=true; } } } } if( l &lt;= (0-divBox.offsetWidth-120) ){ if(_this.barrageStatus.divStatus.switch==true){ //弹幕开关 delDiv(); if(l &lt;= (0-divBox.offsetWidth-document.body.clientWidth) ){ //不断减少left属性，当小于这个内容的宽度,并且滚了120的时候 barrageLayer.removeChild(divBox); //移除dom clearInterval(time);//清除这个div的定时器 } }else{ clearInterval(time);//清除这个div的定时器 } } },20) } } 结语这个弹幕需求，我是如上这么实现的，回头看看实现，发现还是有不少地方可以优化和拆分的，如果有更好的实现思路和本文有哪些错误，欢迎在评论区下面留言。 希望看完的朋友可以点个喜欢/关注，您的支持是对我最大的鼓励。最后：如需转载，请放上原文链接并署名。码字不易，感谢支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。 个人blog and 掘金个人主页 关注我的订阅号，来一起学习成长。 以上2018.4.29 参考资料：纯js 实现弹幕效果]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Vue</tag>
        <tag>Css</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论如何用Vue实现一个弹窗-一个简单的组件实现]]></title>
    <url>%2F2018%2F04%2F22%2F%E8%AE%BA%E5%A6%82%E4%BD%95%E7%94%A8Vue%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%B9%E7%AA%97-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前言最近在使用element-ui框架，用到了Dialog对话框组件，大致实现的效果，跟我之前自己在移动端项目里面弄的一个弹窗组件差不太多。然后就想着把这种弹窗组件的实现方式与大家分享一下，下面本文会带着大家手摸手实现一个弹窗组件。 本文主要内容会涉及到弹窗遮罩的实现，slot插槽的使用方式，props、$emit传参，具体组件代码也传上去了。如果喜欢的话可以点波赞/关注，支持一下，希望大家看完本文可以有所收获。 个人博客了解一下：obkoro1.com 组件最后实现的效果 实现步骤 先搭建组件的html和css样式，遮罩层和内容层。 定制弹窗内容：弹窗组件通过slot插槽接受从父组件那里传过来弹窗内容。 定制弹窗样式：弹窗组件通过props接收从父组件传过来的弹窗宽度，上下左右的位置。 组件开关：通过父组件传进来的props控制组件的显示与隐藏，子组件关闭时通过事件$emit触发父组件改变值。 1.搭建组件的html和css样式。html结构：一层遮罩层，一层内容层，内容层里面又有一个头部title和主体内容和一个关闭按钮。 下面是组件中的html结构，里面有一些后面才要加进去的东西，如果看不懂的话可以先跳过， &lt;template&gt; &lt;div class=&quot;dialog&quot;&gt; &lt;!--外层的遮罩 点击事件用来关闭弹窗，isShow控制弹窗显示 隐藏的props--&gt; &lt;div class=&quot;dialog-cover back&quot; v-if=&quot;isShow&quot; @click=&quot;closeMyself&quot;&gt;&lt;/div&gt; &lt;!-- transition 这里可以加一些简单的动画效果 --&gt; &lt;transition name=&quot;drop&quot;&gt; &lt;!--style 通过props 控制内容的样式 --&gt; &lt;div class=&quot;dialog-content&quot; :style=&quot;{top:topDistance+&apos;%&apos;,width:widNum+&apos;%&apos;,left:leftSite+&apos;%&apos;}&quot; v-if=&quot;isShow&quot;&gt; &lt;div class=&quot;dialog_head back&quot;&gt; &lt;!--弹窗头部 title--&gt; &lt;slot name=&quot;header&quot;&gt;提示信息&lt;/slot&gt; &lt;/div&gt; &lt;div class=&quot;dialog_main&quot; :style=&quot;{paddingTop:pdt+&apos;px&apos;,paddingBottom:pdb+&apos;px&apos;}&quot;&gt; &lt;!--弹窗的内容--&gt; &lt;slot name=&quot;main&quot;&gt;弹窗内容&lt;/slot&gt; &lt;/div&gt; &lt;!--弹窗关闭按钮--&gt; &lt;div class=&quot;foot_close&quot; @click=&quot;closeMyself&quot;&gt; &lt;div class=&quot;close_img back&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/template&gt; 下面是组件中的主要的css样式，里面都做了充分的注释，主要通过z-index和background达到遮罩的效果，具体内容的css可以根据自己的需求来设置。 &lt;style lang=&quot;scss&quot; scoped&gt; // 最外层 设置position定位 .dialog { position: relative; color: #2e2c2d; font-size: 16px; } // 遮罩 设置背景层，z-index值要足够大确保能覆盖，高度 宽度设置满 做到全屏遮罩 .dialog-cover { background: rgba(0,0,0, 0.8); position: fixed; z-index: 200; top: 0; left: 0; width: 100%; height: 100%; } // 内容层 z-index要比遮罩大，否则会被遮盖， .dialog-content{ position: fixed; top: 35%; // 移动端使用felx布局 display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 300; } &lt;/style&gt; 2. 通过slot定制弹窗内容这一步，只要理解了slot的作用以及用法，就没有问题了。 单个插槽：&lt;slot&gt;这是在没有slot传进来的时候，才显示的弹窗内容&lt;/slot&gt; 上面是单个插槽也叫默认插槽，在父组件中使用插槽的正确姿势： &lt;my-component&gt; &lt;!--在my-component里面的所有内容片段都将插入到slot所在的DOM位置，并且会替换掉slot标签--&gt; &lt;!--这两个p标签，将替换整个slot标签里面的内容--&gt; &lt;p&gt;这是一些初始内容&lt;/p&gt; &lt;p&gt;这是更多的初始内容&lt;/p&gt; &lt;/my-component&gt; ps:如果子组件里面包含slot插槽，那么上面的p标签的内容将会被丢弃。 具名插槽： 所谓的具名插槽，即为slot标签赋一个name属性，具名插槽可以父组件中不同的内容片段放到子组件的不同地方，具名插槽还是可以拥有一个默认插槽。下面可以看一下弹窗组件插槽的使用方式： &lt;div class=&quot;dialog_head back &quot;&gt; &lt;!--弹窗头部 title--&gt; &lt;slot name=&quot;header&quot;&gt;提示信息&lt;/slot&gt; &lt;/div&gt; &lt;div class=&quot;dialog_main &quot; :style=&quot;{paddingTop:pdt+&apos;px&apos;,paddingBottom:pdb+&apos;px&apos;}&quot;&gt; &lt;!--弹窗的内容--&gt; &lt;slot name=&quot;main&quot;&gt;弹窗内容&lt;/slot&gt; &lt;/div&gt; 在父组件中的使用方式： 将弹窗组件引入要使用的组件中，并通过components注册成为组件。 父组件中弹窗组件插槽的使用方法如下。 &lt;dialogComponent&gt; &lt;div slot=&quot;header&quot;&gt;插入到name为header的slot标签里面&lt;/div&gt; &lt;div class=&quot;dialog_publish_main&quot; slot=&quot;main&quot;&gt; 这里是内容插入到子组件的slot的name为main里面，可以在父组件中添加class定义样式，事件类型等各种操作 &lt;/div&gt; &lt;/dialogComponent&gt; 关于组件中用到的插槽的介绍就到这里了，插槽在弹窗组件中的应用是一个典型的栗子，可以看到插槽作用相当强大，而插槽本身的使用并不难，同学们爱上插槽了没有？ 3.通过props控制弹窗显隐&amp;&amp;定制弹窗style psops是Vue中父组件向子组件传递数据的一种方式，不熟悉的小伙伴们可以看一下props文档。 因为弹窗组件都是引到别的组件里面去用的，为了适合不同组件场景中的弹窗，所以弹窗组件必须具备一定的可定制性，否则这样的组件将毫无意义,下面介绍一下props的使用方式，以弹窗组件为例： 首先需要在被传入的组件中定义props的一些特性，验证之类的。 然后在父组件中绑定props数据。 &lt;script&gt; export default { props: { isShow: { //弹窗组件是否显示 默认不显示 type: Boolean, default: false, required:true, //必须 }, //下面这些属性会绑定到div上面 详情参照上面的html结构 // 如： :style=&quot;{top:topDistance+&apos;%&apos;,width:widNum+&apos;%&apos;}&quot; widNum:{ //内容宽度 type: Number, default:86.5 }, leftSite:{ // 左定位 type: Number, default:6.5 }, topDistance: { //top上边距 type: Number, default:35 }, pdt:{ //上padding type: Number, default:22 }, pdb:{ //下padding type: Number, default:47 } }, } &lt;/script&gt; 父组件中使用方式： &lt;dialogComponent :is-show=&quot;status.isShowPublish&quot; :top-distance=&quot;status.topNum&quot;&gt; &lt;/dialogComponent&gt; ps：props传递数据不是双向绑定的，而是单向数据流，父组件的数据变化时，也会传递到子组件中，这就意外着我们不应该在子组件中修改props。所以我们在关闭弹窗的时候就需要通过$emit来修改父组件的数据，然后数据会自动传到子组件中。 现在基本上弹窗组件都已实现的差不多了，还差一个弹窗的关闭事件，这里就涉及到子组件往父组件传参了。 4.$emit触发父组件事件修改数据，关闭弹窗Vue中在子组件往父组件传参，很多都是通过$emit来触发父组件的事件来修改数据。 在子组件中，在点击关闭，或者遮罩层的时候触发下面这个方法： methods: { closeMyself() { this.$emit(&quot;on-close&quot;); //如果需要传参的话，可以在&quot;on-close&quot;后面再加参数，然后在父组件的函数里接收就可以了。 } } 父组件中的写法： &lt;dialogComponent :is-show=&quot;status.isShowPublish&quot; :top-distance=&quot;status.topNum&quot; @on-close=&quot;closeDialog&quot;&gt; &lt;/dialogComponent&gt; //&quot;on-close是监听子组件的时间有没有触发，触发的时候执行closeDialog函数 methods:{ closeDialog(){ // this.status.isShowPublish=false; //把绑定的弹窗数组 设为false即可关闭弹窗 }, } 可以用弹窗组件实现下列这种信息展示，或者事件交互： 弹窗组件代码上面是把弹窗的每个步骤拆分开来，一步步解析的，每一步都说的比较清楚了，具体连起来的话，可以看看代码，再结合文章就能理的很清楚了。 小结：这个弹窗组件，实现起来一点都不难，我这里主要是提供了一个实现方式，当项目中有需要的话，大家也可以自己撸一个出来，以上就是本文的内容了，希望同学们看完能有所收获。 希望看完的朋友可以点个喜欢，也可以关注一下我，您的支持是对我最大的鼓励。最后：如需转载，请放上原文链接并署名。码字不易，感谢支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。 个人blog and 掘金个人主页 以上2018.4.21 参考资料：Vue文档-插槽]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Vue</tag>
        <tag>css</tag>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端笔试题面试题记录（下）]]></title>
    <url>%2F2018%2F04%2F07%2F%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AF%95%E9%A2%98%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言接上篇前端笔试题面试题记录（上）。趁清明小长假，把上篇剩下的部分也写一下，因为最近比较忙这篇已经拖了很久了。现在刚刚开始银四了，应该还是有些小伙伴在找工作，时间还不算太晚，希望本篇可以帮到这些小伙伴。 个人博客了解一下：obkoro1.com 本文主要目录如下： 面试题QA 面试遇到的一些小问题 Vue系列问题 面试题QAQ：了解ES6的let和const变量声明吗？跟ES5的var有哪些区别？let 在同一个作用域里面：var可以重复声明变量，let不能重复声明同一个变量。 es5是函数作用域，即一个函数里面才是一个作用域，es6是块级作用域（花括号’{这里面是一个作用域}’），如：if、for花括号里面都是一个作用域。 var有变量提升，可以在变量声明之前使用，let不存在变量提升，在变量之前使用会报错。 let 有暂时性死区，阮一峰大佬es6入门文档解释如下： const const的很多特性跟let的特性一样，都有：不可重复声明，不存在变量提升，有暂时性死区，都是块级作用域。 还有一些跟let命令不一样的地方：const必须在声明的时候赋值，不然就会报错。const声明的常量不能更改。 这里的常量指的是：数值、字符串、布尔值，对于引用类型（数组和对象），const只能保证指针是固定的，至于数组和对象内部有没有改变就是const不能控制的地方 Q：Css的优先级。这类也通常出现在笔试题中，具体的题目记不太清了。 权重优先级： !important&gt;style(1000)&gt;id(100)&gt;class(10) !important是优先级最高的不管权重多少，始终采取important。 如果两个选择器作用在同一元素上，计算权重值，相加。权重高者属性生效。 （笔试题就出现过层叠的class id选择器，作用在同一个标签上，然后问最后哪个css属性生效） 找到一篇很好的写css权重的文章，有兴趣的可以看一下。你应该知道的一些事情——CSS权重 Q：继承函数对象的实例方法、原型的继承。函数对象的继承，在面试的时候，一般出现在笔试题那边，也碰到过几次，下面给出一个答案。 function father(name){//父函数 this.name=name|&apos;koro1&apos;; this.code=function(){ //父类的实例方法 console.log(this.name+&apos;coding&apos;); } }; father.prototype.add=function(food){ //父类的原型方法 console.log(this.name+&apos;eat&apos;+food); } function son(name){ //子函数 father.call(this); //将this绑定到子类，绑定父类的实例方法code（原型方法add还未绑定） this.name=name|| &apos;OBKoro1&apos;; } son.prototype = new father();//把父类的原型方法绑定到子类，实现继承 var sonVar= new son(&apos;faker&apos;);//这里也可以传参name son.prototype.constructor = son;//修复构造函数的指向 console.log(sonVar.code()); console.log(sonVar.add());//可以调用父类的方法了 Q:通过reduce函数来实现简单的数组求和，示例数组[3,4,8,0,9];这是一个简单的笔试题，下面写了两种方法，一种是常见遍历的方法，还有一种是使用eval()方法。 let reduce=(arr)=&gt;{ //第一种常规遍历。 let num=0; for(let [index,value] of arr.entries()){ num+=value; } return num; } let reduce=(arr)=&gt;eval(arr.join(&quot;+&quot;)); //第二种 //join() 方法把数组元素放入字符串 上面的栗子： arr.join(&quot;+&quot;)得到字符串:&apos;3+4+8+0+9&apos;; // eval() 函数计算字符串 ,并执行其中的的 JavaScript 代码 //经提醒：原来有一个reduce()数组求和的方法，把这个方法加上去 let result=[3,4,8,0,9].reduce((total,value)=&gt;{ //这两个参数是默认参数不用设置的 return total+value }); Q：call()和apply()有什么区别？call()和apply()第一个参数将用作函数内 this 的值,用于改变函数的this指向。call和apply的区别在于call()方法接受逗号分隔的参数作为后面的参数，apply()接受一个参数数组作为后面的参数。 从别的博客那边看到一个简单的记忆方法：从call中的 C 联想到逗号分隔（comma-separated），从apply中的 A 联想到数组（array）。 Q：position有哪些值？有什么作用？ static。默认值，不脱离文档流，top，right，bottom，left等属性不生效。 relative。不脱离文档流，依据自身位置进行偏离，当子元素设置absolute，将依据它进行偏离。 absolute。脱离文档流，依据top，right，bottom，left等属性在正常文档流中偏移位置。 fixed。通过浏览器窗口进行定位，出现滚动条的时候，不会随之滚动。 Q:如何实现一个闭包？闭包的作用有哪些？在一个函数里面嵌套另一个函数，被嵌套的那个函数的作用域是一个闭包。 作用：创建私有变量，减少全局变量，防止变量名污染。可以操作外部作用域的变量，变量不会被浏览器回收，保存变量的值。 Q:请从2017-05-15T09:10:23 Europe/Paris提取出结果[&quot;2017&quot;,&quot;05&quot;,&quot;15&quot;,&quot;09&quot;,&quot;10&quot;,&quot;23&quot;]这是一道笔试题，正则相关的，看他们要的内容就可以知道，要把所有的数字都提取出来，可以写一个只获取数字的正则表达式。 let str = &apos;2017-05-15T09:10:23 Europe/Paris&apos;; let arr = str.match( /\d{1,}/g); //match会返回一个数组， // \d 查找数字 // {1,} 表示至少重复几次 // /g表示全局搜索 Q:请描述一下Promise的使用场景，’Promise’它所解决的问题以及现在对于异步操作的解决方案。这是一道笔试题，这是我当时的回答。 Promise的使用场景：ajax请求，回调函数，复杂操作判断。 Promise是ES6为了解决异步编程所诞生的。 异步操作解决方案：Promise、Generator、定时器（不知道算不算）、还有ES7的async 面试遇到的一些小问题：这里主要是面试中遇到的一些小的问题，一两句话就可以说清的东西，大家可以稍微看一看。 函数参数变量提升 function aa(val){ //函数参数的变量也会提升 console.log(val);//&apos;函数传参&apos; var val=&apos;变量声明&apos;; console.log(val);//&apos;变量声明&apos; } aa(&apos;函数传参&apos;); js有哪些方法定义对象？var obj=new Object();//new 一个对象 var obj={name:&quot;OBKoro1&quot;} //对象字面量写法 字符串数字转换运算的问题console.log(1+&apos;2&apos;+&apos;2&apos;); //122 console.log(+&apos;1&apos;+-&apos;2&apos;+&apos;2&apos;);//-12 console.log(&apos;A&apos;+&apos;B&apos;+&apos;2&apos;);//AB2 console.log(&apos;A&apos;-&apos;B&apos;+2);//NaN //两个都是数字才能相加，否则都是以字符串形式拼接。 //相减只能两个都是数字，字符串也会转成数字，如果不能转换，值就为NaN split()、join()的区别？split()是将字符分割成一个数组,join()将数组转为一个字符串 pop()push()unshift()shift()的作用？pop()删除并返回数组的最后一个元素。 push()可向数组的末尾添加一个或多个元素，并返回新的长度。 unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。 shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。 判断一个数是否是整数function isIntefer(x){ return x%1===0; //返回布尔 } 如何将字符串转为数字，如：12.3b？var num=parseFloat(&apos;12.3b&apos;) 什么是外边距合并？当两个垂直外边距相遇时，它们将形成一个外边距，合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。 Q:你常用的git/svn 命令行有哪些？行内元素有哪些，块状元素有哪些？css有哪些选择器？自行谷歌，类似的还有css3新增的属性，H5新增的属性之类的，有空的话，稍微背一背，都碰到过。 Vue系列问题：我在面试过程中很少被问到框架，很多是在笔试题中碰到的，在介绍自己项目的时候，有时候自己会解释这里用到了Vue的什么技术，这个时候面试官可能就会顺着问一问Vue，总的来说问的也不会太深。 以下是笔试真题： vue-router怎么定义动态路由？怎么获取传过来的动态参数？ 定义：path:&apos;a/:value&apos; 获取：this.$route.params.value。 说出至少4中vue当中的指令和它的用法。vue文档显示13个指令 vue如何绑定事件。@click=&quot;事件名&quot; v-show和v-if指令的共同点和不同点？ 1.v-if是删除/添加Dom标签，不占据文档位置,v-show切换css的display属性，控制显示隐藏，还会占据文档位置。 2.v-if会删除dom标签所以v-if性能消耗会高一些，需要频繁切换的话，使用v-show会好一点。 &lt;keep-alive&gt;&lt;/keep-alice&gt;的作用的是什么？ `&lt;keep-alive&gt;`是Vue的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM。 列举三个Vue常用的生命周期钩子函数？Vue文档 分别写出webpack打包给服务器和本地开发预览的命令代码: npm run build npm run dev 我都觉得很弱智。。 vue 父子组件是怎么进行传参的？ 父组件传参给子组件通过props，子组件传参给父组件是用事件传递的。细节见文档。 v-model是用来做什么的，怎么使用。 用来为input输入框或者单选框、select选择框这类的东西做双向绑定的。 使用栗子：&lt;input v-model=&quot;inputData&quot;/&gt; Vuex的工作流程，以及它的作用，使用场景。 vuex的工作流程： 在vue组件里面，通过dispatch来触发actions提交修改数据的操作。 然后再通过actions的commit来触发mutations来修改数据。 mutations接收到commit的请求，就会自动通过Mutate来修改state（数据中心里面的数据状态）里面的数据。 最后由store触发每一个调用它的组件的更新 Vuex的作用：项目数据状态的集中管理，复杂组件(如兄弟组件、远房亲戚组件)的数据通信问题。 vue的服务端渲染 vue的双向绑定 两个问题都不会... 看完了？点赞支持一下呗，这儿还有一篇，有空可以看看哈：前端笔试题面试题记录（上）。 小结各位大佬们，找工作也是可以发现自己的薄弱点，然后加强它，白天的时候被某些问题给虐了，然后在晚上的时候，一定要把这些问题弄清楚，不要每次都被同样的问题给虐，这样就不好了。 最后：如需转载，请放上原文链接并署名。码字不易，感谢支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。然后就是希望看完的朋友点个喜欢，也可以关注一下我。个人blog and 掘金个人主页 以上2018.4.7 参考链接：let 和 const 命令]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>css</tag>
        <tag>html</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端笔试题面试题记录（上）]]></title>
    <url>%2F2018%2F03%2F18%2F%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AF%95%E9%A2%98%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言过完元宵，就到上海找了波工作，现在已经入职好了，本文的题目都是中小公司的笔试面试题，里面大部分是我碰到比较频繁或者印象深刻的，在此做波记录，如果喜欢的话可以点波赞，或者关注一下，希望大家看完本文可以有所收获。 本文首发于我的个人blog：obkoro1.com Q：什么情况下会碰到跨域问题？有哪些解决方法？ 跨域问题是这是浏览器为了安全实施的同源策略导致的，同源策略限制了来自不同源的document、脚本，同源的意思就是两个URL的域名、协议、端口要完全相同。 script标签jsonp跨域、nginx反向代理、node.js中间件代理跨域、后端在头部信息设置安全域名、后端在服务器上设置cors。 Q：如何判断一个变量是对象还是数组？判断数组和对象分别都有好几种方法，其中用prototype.toString.call()兼容性最好。 function isObjArr(variable){ if (Object.prototype.toString.call(value) === &quot;[object Array]&quot;) { console.log(&apos;value是数组&apos;); }else if(Object.prototype.toString.call(value)===&apos;[object Object]&apos;){//这个方法兼容性好一点 console.log(&apos;value是对象&apos;); }else{ console.log(&apos;value不是数组也不是对象&apos;) } } ps：千万不能使用typeof来判断对象和数组，因为这两种类型都会返回”object”。 Q：定时器的执行顺序或机制。这个问题还是挺经常被问到的，有一些会直接问定时器的机制，有一些是通过笔试题的方式问执行顺序然后问我为什么是这样。 长话短说，我们需要记住的是：因为js是单线程的，浏览器遇到setTimeout或者setInterval会先执行完当前的代码块，在此之前会把定时器推入浏览器的待执行事件队列里面，等到浏览器执行完当前代码之后会看一下事件队列里面有没有任务，有的话才执行定时器的代码。 所以即使把定时器的时间设置为0还是会先执行当前的一些代码。 上面是我写的一个栗子，如果还不清楚的话，大家可以找一篇关于定时器机制的详解文章来看看。 Q：html中title属性和alt属性的区别？这个问题被问了一次，当时我只记得，alt属性是用于img标签的，当图片失效的时候会出现alt属性里面的内容，title用来标记页面的title，当时面试官问我还有没有其他的区别。我。。。 然后我就找了一篇文章来看，涨了点姿势： 1.&lt;img src=&quot;#&quot; alt=&quot;alt信息&quot; /&gt; //1.当图片不输出信息的时候，会显示alt信息 鼠标放上去没有信息，当图片正常读取，不会出现alt信息 2.&lt;img src=&quot;#&quot; alt=&quot;alt信息&quot; title=&quot;title信息&quot; /&gt; // 2.当图片不输出信息的时候，会显示alt信息 鼠标放上去会出现title信息 //当图片正常输出的时候，不会出现alt信息，鼠标放上去会出现title信息 另外还有一些关于title属性的知识： title属性可以用在除了base，basefont，head，html，meta，param，script和title之外的所有标签 title属性的功能是提示。额外的说明信息和非本质的信息请使用title属性。title属性值可以比alt属性值设置的更长 title属性有一个很好的用途，即为链接添加描述性文字，特别是当连接本身并不是十分清楚的表达了链接的目的。 Q：标准盒子模型与IE怪异盒子模型这个问题主要会出现在笔试题上面，比如： &lt;div style=&quot;width:100px;height=&quot;100px;border:10px;padding:10px;&quot;&gt;&lt;/div&gt; 这个盒子在w3c标准盒子模型和IE的怪异盒子模型下面它的宽度分别是多少？ 标准盒子模型：总宽度=content100px+border 10px*2+padding 10px*2 //140px 怪异盒子模型: 总宽度=content60px+ border 10px*2+padding 10px*2 //100px ps： box-sizing： content-box || border-box；//css3 box-sizing设置为border-box将使用怪异盒子模型 当怪异盒子的宽度小于border+padding的宽度的时候，content width将变为0，盒子的宽度会被border和padding的总宽度撑开 ES5的继承和ES6的继承有什么区别？ES5的继承时通过prototype或构造函数机制来实现。ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.apply(this)）。 ES6的继承机制完全不同，实质上是先创建父类的实例对象this（所以必须先调用父类的super()方法），然后再用子类的构造函数修改this。 具体的：ES6通过class关键字定义类，里面有构造方法，类之间通过extends关键字实现继承。子类必须在constructor方法中调用super方法，否则新建实例报错。因为子类没有自己的this对象，而是继承了父类的this对象，然后对其进行加工。如果不调用super方法，子类得不到this对象。 ps：super关键字指代父类的实例，即父类的this对象。在子类构造函数中，调用super后，才可使用this关键字，否则报错。 Q：CSS3有哪些新增的属性？这里可以分为边框、背景，渐变，阴影、2D转换 3D转换等之类的来说。 比如：边框(border-radius、border-shadow、border-image)之类的 。 具体的可以参见菜鸟教程：链接。类似的镜像问题还有HTML5的新增属性，可以自己谷歌一下。 Q：你知道哪些http状态码？1xx：1开头的是信息状态码 2xx：2开头的是请求成功 3xx：3开头的是重定向 4xx：4开头的是客户端错误 5xx：5开头的是服务器错误 这个问题并不难，在笔试面试都有碰到过，巧的是之前我就总结过一篇类似的文章。 Q:如何对一个数组去重？这个问题出现了好几次，而且很多面试官不满足你只给出一两种方法。 1、Set结构去重。 这是ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 let unique= [...new Set(array)]; //es6 Set数据结构类似于数组，成员值是唯一的，有重复的值会自动去重。 //Set内部使用===来判断是否相等，类似&apos;1&apos;和1会两个都保存，NaN和NaN只会保存一个 2、遍历，将值添加到新数组，用indexOf()判断值是否存在，已存在就不添加，达到去重效果。 let a = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,1,NaN,NaN,undefined,undefined,null,null, &apos;a&apos;,&apos;b&apos;,&apos;b&apos;]; let unique= arr =&gt;{ let newA=[]; arr.forEach(key =&gt; { if( newA.indexOf(key)&lt;0 ){ //遍历newA是否存在key，如果存在key会大于0就跳过push的那一步 newA.push(key); } }); return newA; } console.log(unique(a)) ;//[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, 1, NaN, NaN, undefined, null, &quot;a&quot;, &quot;b&quot;] //ps:这个方法不能分辨NaN,会出现两个NaN。是有问题的，下面那个方法好一点。 3、遍历，将数组的值添加到一个对象的属性名里，并给属性赋值，对象不能添加相同属性名，以这个为依据可以实现数组去重，然后用Object.keys(对象)返回这个对象可枚举属性组成的数组，这个数组就是去重后的数组。 let a = [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, 1,NaN,NaN,undefined,undefined,null,null, &apos;a&apos;, &apos;b&apos;, &apos;b&apos;]; const unique = arr =&gt; { var obj = {} arr.forEach(value =&gt; { obj[value] = 0;//这步新添加一个属性，并赋值，如果不赋值的话，属性会添加不上去 }) return Object.keys(obj);//`Object.keys(对象)`返回这个对象可枚举属性组成的数组，这个数组就是去重后的数组 } console.log(unique(a));//[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;NaN&quot;, &quot;undefined&quot;, &quot;null&quot;, &quot;a&quot;, &quot;b&quot;] 注意：这个方法会将 number,NaN,undefined,null，变为字符串形式，因为对象的属性名就是一个字符串，根据需求来吧，想想还是Set去重最简单也最有效。 Q：垂直居中有哪些方法？ 单行文本的话可以使用height和line-height设置同一高度。 position+margin：设置父元素:position: relative;，子元素height: 100px; position:absolute;top: 50%; margin: -50px 0 0 0;（定高） position+transform：设置父元素position:relative,子元素：position: absolute;top: 50%;transform: translate(0, -50%);（不定高） 百搭flex布局(ie10+)，设置父元素display:flex;align-items: center;（不定高） 类似的还有很多，实际应用中，可能就会使用一两种方法，有兴趣的可以看下这篇文章 Q：翻转一个字符串这个问题主要在笔试题碰到的多，思路就是先将字符串转成一个数组，然后用数组的reverse()+join()方法。 let a=&quot;hello word&quot;; let b=[...str].reverse().join(&quot;&quot;);//drow olleh 小结我想说的是：在找工作期间，肯定有自己发挥不好，或者不会的问题，一定要在晚上的时候自己再学习总结一下，在一个问题上面尽量不要栽倒两次，学到了的才是自己的。 以上就是近期面试遇到的一些问题记录总结，实际上还是有一些问题没有写出来，许久没有写文章了，写的很慢，有点累。先给自己立一个flag，下周再写一篇出来。希望各位大佬看了本文，能有所收获，感谢阅读。 最后：如需转载，请放上原文链接并署名。码字不易，感谢支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。然后就是希望看完的朋友点个喜欢，也可以关注一下我。个人blog and 掘金个人主页 以上2018.3.18 参考链接：title与alt的区别 CSS-标准盒模型 &amp; 怪异盒模型 常见的js算法面试题收集，es6实现 CSS垂直居中的11种实现方式]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>css</tag>
        <tag>html</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue实践过程中的几个问题]]></title>
    <url>%2F2018%2F01%2F17%2FVue%E5%AE%9E%E8%B7%B5%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言本篇是我在使用vue过程中，遇到的几个小问题和之前不了解的东西，记录下来，希望能够帮助各位踩坑。如果喜欢的话可以点波赞，或者关注一下，希望本文可以帮到大家。 本文首发于我的个人blog：obkoro1.com 本篇记录个人遇到的问题如下: 路由变化页面数据不刷新问题 setTimeout/setInterval this指向改变，无法用this访问VUe实例 setInterval路由跳转继续运行并没有销毁 vue 滚动行为(浏览器回退记忆位置)用法 vue路由拦截浏览器后退实现草稿保存类似需求 v-once 只渲染元素和组件一次，优化更新渲染性能 vue框架风格指南推荐 路由变化页面数据不刷新问题 场景：比如文章详情数据，依赖路由的params参数获取的(ajax写在created生命周期里面)，因为路由懒加载的关系，退出页面再进入另一个文章页面并不会运行created组件生命周期，导致文章数据还是上一个文章的数据。 解决方法：watch监听路由是否变化 watch: { &apos;$route&apos; (to, from) { //监听路由是否变化 if(this.$route.params.articleId){//是否有文章id //获取文章数据 } } } setTimeout/setInterval this指向改变，无法用this访问VUe实例场景：mounted(){ setTimeout(function () { //setInterval同理 console.log(this);//此时this指向Window对象 },1000); } 解决方法：使用箭头函数或者//箭头函数访问this实例 因为箭头函数本身没有绑定this setTimeout(() =&gt; { console.log(this); }, 500); //使用变量访问this实例 let self=this; setTimeout(function () { console.log(self);//使用self变量访问this实例 },1000); setInterval路由跳转继续运行并没有销毁场景：比如一些弹幕，走马灯文字，这类需要定时调用的，路由跳转之后，因为组件已经销毁了，但是setInterval还没有销毁，还在继续后台调用，控制台会不断报错，如果运算量大的话，无法及时清除，会导致严重的页面卡顿。 解决办法：在组件生命周期beforeDestroy停止setInterval组件销毁前执行的钩子函数，跟其他生命周期钩子函数的用法相同。 beforeDestroy(){ //我通常是把setInterval()定时器赋值给this实例，然后就可以像下面这么暂停。 clearInterval(this.intervalid); }, vue 滚动行为(浏览器回退记忆位置)用法这个我当时做的时候以为很难，后来做好了才发现就是一个设置而已（前提是要开启路由的History 模式），下面做一个简单的分享。 路由设置 要使用这一功能，首先需要开启vue-router的 history模式 如果之前一直使用的是hash模式(默认模式)，项目已经开发了一段时间，然后转history模式很可能会遇到：这些问题 滚动行为具体设置如下： const router = new VueRouter({ mode: &apos;history&apos;, scrollBehavior (to, from, savedPosition) { if (savedPosition) { //如果savedPosition存在，滚动条会自动跳到记录的值的地方 return savedPosition } else { return { x: 0, y: 0 }//savedPosition也是一个记录x轴和y轴位置的对象 } }， routes: [...] }) vue滚动行为文档，可以进到这里看看更详细的信息。 vue路由拦截浏览器后退实现草稿保存类似需求场景：为了防止用户突然离开，没有保存已输入的信息。 用法：//在路由组件中： mounted(){ }, beforeRouteLeave (to, from, next) { if(用户已经输入信息){ //出现弹窗提醒保存草稿，或者自动后台为其保存 }else{ next(true);//用户离开 } 类似的还有beforeEach、beforeRouteUpdate，也分为全局钩子和组件钩子，见路由文档。 v-once 只渲染元素和组件一次，优化更新渲染性能觉得v-once这个api蛮6的，应该很多小伙伴都没有注意到这个api。 文档介绍： 这个api在我看来主要用于那些一次性渲染，并且不会再有操作更改这些渲染的值，这样就可以优化双向绑定的更新性能。 文档推荐：对低开销的静态组件使用 v-once尽管在 Vue 中渲染 HTML 很快，不过当组件中包含大量静态内容时，可以考虑使用 v-once 将渲染结果缓存起来，就像这样： Vue.component(&apos;terms-of-service&apos;, { template: &apos;\ &lt;div v-once&gt;\ &lt;h1&gt;Terms of Service&lt;/h1&gt;\ ...很多静态内容...\ &lt;/div&gt;\ &apos; }) vue风格指南推荐：写到这里想到vue框架还有一个风格指南推荐，如下图所示，大家也可以学习一波。 小结上面就是我分享的几个小问题，希望大家看了能够有所收获！另：明年准备去上海，如果小伙伴的公司有坑，可以联系一下我。 最后：如需转载，请放上原文链接并署名。码字不易，感谢支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。然后就是希望看完的朋友点个喜欢，也可以关注一下我。个人blog and 掘金个人主页 以上2018.1.17]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>实践</tag>
        <tag>Vue-router</tag>
        <tag>定时器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【读书笔记】《高性能JavaScript》]]></title>
    <url>%2F2018%2F01%2F09%2F%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDJavaScript%E3%80%8B%2F</url>
    <content type="text"><![CDATA[缺陷这本书是2010年出版的，这本书谈性能是有时效性的，现在马上就2018年了，这几年前端发展的速度是飞快的，书里面还有一些内容考虑IE6、7、8的东西，殊不知现在这些都已经不再考虑了，所以不可避免的有一些知识是比较老的。有些解决方法现在已经不是最好的解决方式，比如工具那一章。 前言总的来说，这本书整体给出的性能优化建议，以及作者耐心的实践，对我们开发优化的启发和帮助还是很大的，因为它里边的很多知识，都是作者通过实践总结出来的，都是经验的积累，这在一般的教科书上是学不到的。特别是对于js基础比较差一点的，里面有很多知识点尽管在现在还是非常有必要的。 下面我就将各章节的一些重要的知识点总结写出来，争取将干货都提取出来。 本文首发于我的个人blog：obkoro1.com 正文 第一章-加载和执行 js的阻塞特性： 当浏览器在执行js代码的时候，不能同时做其他事情。（界面ui线程和js线程用的是同一进程，所以js执行越久，网页的响应时间越长。） 脚本的位置 如果把脚本&lt;script&gt;放在&lt;head&gt;中，页面会等js文件全部下载并执行完成后才开始渲染，在这些文件下载和执行的过程中：会导致访问网站的时候有明显的延迟，表现为：页面空白。 性能提升：推荐将所有的&lt;script&gt;标签尽可能的放到&lt;body&gt;标签的底部，优先渲染页面，减少页面空白时间。 组件脚本。 每个&lt;script&gt;标签初始下载的时候都会阻塞页面的渲染。性能提升做法：减少内嵌脚本：减少内嵌的&lt;script&gt;标签，将代码写在一个标签中。 合并外链的js文件：http请求会带来额外的性能开销，栗子：下载一个100KB的js文件比下载4个25kb的js文件更快。具体操作方法自行搜索。 无阻塞脚本的方法 script标签的aync属性： async 属性规定一旦脚本可用，则会异步执行。async 属性仅适用于外部脚本（只有在使用 src 属性时）。如果 async=”async”：脚本相对于页面的其余部分异步地执行（当页面继续进行解析时，脚本将被执行） script标签的defer属性： js文件在页面解析到script标签的时候开始下载，但并不会执行，dom加载完成执行。这两个属性的区别在于执行时机。 动态脚本元素。 js操作dom创建&lt;script&gt;标签，自定义生成标签的type、src属性。文件会在该元素被添加到页面的时候开始下载。ps：如果文件顺序很重要的话，最好按照顺序合成一个文件。然后再添加到页面中。这样：无论何时启动下载。文件的下载和执行过程不会阻塞页面的其他进程。 3. XHR ajax脚本注入、用get请求一个文件，请求好了。然后创建动态脚本，最后添加进去。缺陷：文件要再请求页面的同一个域。不能从cdn下载 第一章加载和执行小结： 把文件放在body标签签名， 合并脚本，减少&lt;script&gt;标签。 采用无阻塞下载js。使用script的defer和async属性 异步下载。动态创建script标签和执行代码。 第二章-数据存取 js四种基本的数据存取位置。1、字面量：字符串、数字、布尔、对象、数组、函数、正则、null、undefined，字面量只代表自身，没有存储位置。 2、局部变量。 let var 声明的变量。3、数组元素。4、对象成员。 性能：访问字面量和局部变量的速度是最快的，访问数组和对象成员相对较慢 变量标识符解析过程： 搜索执行环境的作用域链，查找同名标识符。搜索过程从作用域链头部开始，也就是当前运行函数的活动对象。如果找到，就使用这个标识符，对应的变量；如果没有找到，继续搜索下面的对象。搜索过程会持续进行，直到找到标识符，若无法搜索到匹配的对象，那么标识符被视为未定义、 性能问题：一个标识符所在的位置越深，它的读写速度也就越慢。因此，函数中读写局部变量总是最快的，而读写全局变量通常是最慢的。 建议：将全局变量存储到局部变量，加快读写速度。 闭包，原型，嵌套对象。 优化建议：将常用的跨作用域变量存储到局部变量，然后直接访问局部变量。理由如上，变量标识符解析过程。 第二章数据存取小结： 访问字面量和局部变量的速度最快，相反，访问数组元素和对象成员相对较慢。 由于局部变量存在于作用域链的起始位置，因为访问局部变量比访问跨作用域变量更快。这个道理同样适用于数组，对象，跨作用域变量。 把常用的对象，数组，跨域变量保存在局部变量可以改善js性能，局部变量访问速度更快。 第三章DOM编程小结： dom操作天生就慢，尽量减少dom操作，减少访问dom的次数。 使用document.querySelect来做选择器，比其他方式快。 需要多次访问某个dom节点，使用局部变量存储。 html集合，把集合长度缓存到一个变量中，然后遍历使用这个变量，如果经常操作集合，建议拷到一个数组中。 要留意浏览器的重绘和重排；批量修改样式的时候，‘离线’操作DOM树，使用缓存，并减少访问布局信息的次数。重绘和重排是DOM编程优化的一个相当重要概念：重绘和重排。 动画中使用绝对定义，使用拖放处理。 使用事件委托来减少事件处理器的数量。 第四章算法和流程控制小结： for、while和do-while循环性能差不多，for-in循环速度只有前面几种类型的1/7，所以尽量避免使用for-in循环，除非你需要遍历一个属性数量未知的对象。 forEach比for慢，如果运行速度要求严格，不建议使用。 改善循环性能的最佳方式是减少每次迭代的工作量和减少循环迭代的次数。 减少迭代工作量：减少属性查找和倒序循环，循环次数越多，性能优化越明显。 for(var i=0;i&lt;items.length;i++){代码}//正序循环 for(var i=items.length;i--){代码}//倒序循环 //减少属性查找：查找一次属性，把值存在局部变量，在控制条件里面使用这个变量 倒序循环在i&gt;0的时候会自动转换为true，等于0的时候为false。 //倒序循环：控制条件从（迭代数少于总数吗？它是否为true？）变为（它是否为true） 减少迭代的次数：”Duff’s Device”循环体展开技术，有兴趣的可以看一下，迭代工作量大于1000的时候适用。 if-else与switch：条件数量越大，越倾向于使用switch。 优化if-else： 1、把最可能出现的条件放在首位。2、使用二分法把值域分成一系列的区间。 浏览器的调用栈大小限制了递归算法在js中的应用；栈溢出错误会导致其他代码中断运行。 小心使用递归，现在es6递归可以尾递归，在es6中只要使用尾递归就不会发生栈溢出，相对节省性能。 第五章字符串和正则表达式小结： 字符串合并的时候使用简单的’+’和’+=’操作符。 str+=&apos;abc&apos;+&apos;efg;//2个以上的字符串拼接，会产生临时字符串 str=str+&apos;abc&apos;+&apos;efg&apos;;//推荐，提速10%~40% 书里面讲的正则原理和回溯原理，这个很重要，找个篇博客：跟书里面讲的差不多，但还是建议大家可以去找找PDF好好看看正则表达式这节。 提高正则表达式效率的方法： 1、最重要的是：具体化正则表达式！具体化正则表达式！具体化正则表达式！ 2、关注如何让匹配更快失败，找出一些必需，特殊的字符 3、正则表达式以简单的、必需的字元开始。 4、使用量词模式，使它们后面的字元互斥。 5、较少分支数量，缩小分支范围 6、使用合适的量词 7、把正则表达式赋值给变量并重用 8、将复杂的正则拆分为简单的片段 //事实上，书里面讲的方法不止这么几个，而且每一个都有详细的解析 大佬们 还是去看看这一章节吧 正则表达式并不总是最好的解决方案，当你只是搜索字面字符串或者你事先知道字符串的哪一部分将要被查找时： 使用indexOf()和lastIndexOf()更适合查找特定字符串的位置或者判断它们是否存在 //例如：判断当前浏览器之类。 第六章快速响应的用户界面小结：js和用户界面更新在同一个进程中运行，因此一次只能处理一件事情。高效的管理UI线程就是要确保js不能运行太长时间，以免影响用户体验。 浏览器限制了js任务的运行时间，这种限制很有必要，它确保某些恶意代码不能通过永不停止的密集操作锁住用户的浏览器。此限制分为两种：调用栈的大小和长时间运行脚本。 任何js任务都不应当执行超过100毫秒。过长的运行时间会导致UI更新出现明显延迟，从而对用户体验造成负面影响。 定时器可用来安排代码延迟执行，它使得你可以把长时间运行脚本分解成一系列的小任务。 第七章 AJAX 小结这一章节貌似东西都比较老一点。。 post更适合发送大量数据到服务器。 get请求能够被浏览器缓存，Expires头信息设置浏览器缓存请求多久。可用于从不改变的图片或者其他静态数据集（js、css等） JSON是一种使用js对象和数组直接量编写的轻量级且易于解析的数据格式，它不仅传输尺寸小，而且解析速度快。JSON是高性能AJAX的基础，尤其在使用动态脚本注入时。 json应该是近几年一直在用的。。。 减少请求数，通过合并js和css文件。 缩短页面的加载时间，页面主要内容加载完成后，用AJAX获取那些次要的文件。 第八章编程实践小结 避免双重求值：避免使用eval()和 function()构造器来避免双重求值带来的性能消耗，同样的，给setTimeout()和setInterval()传递函数而不是字符串作为参数。 //双重求值：就是在js代码中执行另一段js代码，不建议使用下面这些方式 eval(&apos;代码&apos;) function构造函数--new function(&apos;代码&apos;) setTimeout(‘代码’,100)和setInterval(‘代码’,100) 尽量使用直接量创建对象和数组。直接量的创建和初始化都比非直接量形式要快。 避免做重复工作，能节省的步骤就节省。 js原生方法总会比你写的任何代码都要快。 第九章 构建并部署高性能js应用小结构建和部署的过程对基于js的web应用的性能有着巨大影响。这个过程中最重要的步骤有： 合并、压缩js文件。可使用Gzip压缩，能够减少约70%的体积！ 这些都是在构建过程中完成的工作，不要等到运行时去做，webpack也是在构建过程中，完成的工作。 通过正确设置HTTP响应头来缓存js文件，通过向文件名增加时间戳来避免缓存问题。 使用CDN提供js文件；CDN不仅可以提升性能，它也为你管理文件的压缩与缓存，。 第十章 工具 小结：当网页变慢时，分析从网络下载的资源以及分析的资源以及分析脚本的运行性能能让你专注于那些最需要优化的地方。 使用网络分析工具找出加载脚本和页面中其他资源的瓶颈，这会帮助你决定那些脚本需要延迟加载，或者需要进一步分析。 检查图片、样式表和脚本的加载过程，以及它们对页面整体加载和渲染的影响。从而针对性的做出优化 把脚本尽可能延迟加载，这样做可以加快页面渲染速度，给用户带来更好的体验。 确认脚本和其他资源文件的加载过程已经被优化 这里主要是说文件从服务器的下载速度，比如服务器那边的配置问题之类的。 栗子：我就被后端坑过。一个js文件就200k ，下载下来需要50秒钟！ 后面发现原来是后端那边nginx没有开启加速配置什么的，导致出现的问题，找问题找半天。 测试脚本的运行时间,用一个Date实例减去另一个Date实例，得到的时间差就是脚本运行消耗的时间。 let start=new Date(); //你的代码 let time=newDate()-start; chrome ,火狐 等主流浏览器的控制面板，已经能够反映很多性能问题。仔细分析就能找出很多问题。例如：资源加载，断点等 后话事实上，自认为这本书最宝贵的就是一些提到的细节，比如： 1、字符串合并的时候使用简单的’+’和’+=’操作符。 str+=&apos;abc&apos;+&apos;efg;//2个以上的字符串拼接，会产生临时字符串 str=str+&apos;abc&apos;+&apos;efg&apos;;//推荐，提速10%~40% 2、避免双重求值：避免使用eval()和 function()构造器来避免双重求值带来的性能消耗，同样的，给setTimeout()和setInterval()传递函数而不是字符串作为参数。 //双重求值：就是在js代码中执行另一段js代码，不建议使用下面这些方式 eval(&apos;代码&apos;) function构造函数--new function(&apos;代码&apos;) setTimeout(‘代码’,100)和setInterval(‘代码’,100) 这些东西可以让我们知道什么是更好的实践，什么样的代码可以跑得更快，让我们养成更好的开发习惯。书不太厚，如果对里面的内容感兴趣，还是建议买一本回家看一看。 以上2017.1.9]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>性能</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 简单的推箱子小游戏步骤解析--大家都玩过的]]></title>
    <url>%2F2018%2F01%2F07%2Fjs-%E7%AE%80%E5%8D%95%E7%9A%84%E6%8E%A8%E7%AE%B1%E5%AD%90%E5%B0%8F%E6%B8%B8%E6%88%8F%E6%AD%A5%E9%AA%A4%E8%A7%A3%E6%9E%90-%E5%A4%A7%E5%AE%B6%E9%83%BD%E7%8E%A9%E8%BF%87%E7%9A%84%2F</url>
    <content type="text"><![CDATA[前言推箱子小游戏大家肯定都玩过，之所以写这篇文章，是觉得这个小游戏足够简单好理解，大家看完文章之后，自己也能花上半天功夫敲出一个推箱子小游戏来，如果喜欢的话可以点波赞，或者关注一下，希望本文可以帮到大家。 本文首发于我的个人blog：obkoro1.com demo：推箱子小游戏步骤解析：本文代码已经放在了github上面了,里面也进行了很详细的代码注释，可以copy下来，在本地运行一下看看。 1. 渲染地图 html结构： html结构十分简单，只要弄一堆div，来放置地图的class就可以了，我这里初始化了12*9个div，地图里最多九行高度。 这些div都是同样大小，地图渲染出来区别的只是颜色的不同。 地图函数： var box=$(‘.box div’); //地图使用的div集合 function create(){ //创建地图函数 box.each(function(index){ //index的数量是固定的，是box div下面div的数量 // 每次创建地图初始化div box.eq(index).removeClass(); }); box.each(function(index,element){ //循环整个div的数量 二维数组里数量不够的 默认为空白 //level为关卡数 根据关卡渲染地图 builder为二维数组，为地图关卡 if(builder[level][index]){ //过滤0 box.eq(index).addClass(&apos;type&apos;+builder[level][index]); } }); box.eq(origin[level]).addClass(“pusher”); //推箱人 皮卡丘位置 } //第一关的地图长这样（下面只是栗子，不是代码），0代表不可抵达区域，1代表目标（要被推到的地方）， //2代表普通路径（可以走的），3代表墙，4代表箱子 [0,0,0,0,3,3,3,0,0,0,0,0, 0,0,0,0,3,1,3,0,0,0,0,0, 0,0,0,0,3,2,3,3,3,3,0,0, 0,0,3,3,3,4,2,4,1,3,0,0, 0,0,3,1,2,4,2,3,3,3,0,0, 0,0,3,3,3,3,4,3,0,0,0,0, 0,0,0,0,0,3,1,3,0,0,0,0, 0,0,0,0,0,3,3,3,0,0,0,0] 2. 捕获键盘事件,判断是否可以移动使用$(document).keydown()jqery事件，捕获键盘事件。 捕获键盘事件，上下左右以及wsad。 $(document).keydown(function (e) { var key=e.which; switch(key){ //col 的值为12，上下移动要12个div为一个周期 //方向键上或者w case 87: case 38: move(-col);//判断移动函数 break; //方向键下或者s case 83: case 40: move(col); break; //方向键左或者a case 65: case 37: move(-1); break; //方向键右或者d case 68: case 39: move(1); break; } setTimeout(win,500); //按键之后调判断是否过关 }); 判断是否可以移动。 分为两个判断条件：一个是推箱子，一个是不推箱子 自然移动，否则不移动皮卡丘。 function move(step){ //是否移动判断 // 分为两个判断条件一个是推箱子，一个是不推箱子 自然移动。 否则不移动皮卡丘 //step 上下是12个div一个周期，左右是1个div positin是皮卡丘的原来位置 var pikaqiu1=box.eq(position);//皮卡丘现在的地方 var pikaqiu2=box.eq(position+step);//皮卡丘要去的下一个地方 var pushBox=box.eq(position+step*2);//箱子要去的下一个地方 if(!pikaqiu2.hasClass(&apos;type4&apos;)&amp;&amp;( pikaqiu2.hasClass(&apos;type1&apos;)||pikaqiu2.hasClass(&apos;type2&apos;))){ //自然移动 //判断：如果下一个div的class不包含type4(箱子)，并且 下一个div含有type1(目标位置)，或者type2(普通路径) //这一步和下一步判断是否有type4的原因是普通路径会变成有type4的路径，这时候就会出现问题 pikaqiu1.removeClass(&quot;pusher&quot;); //移除当前皮卡丘 pikaqiu2.addClass(&quot;pusher&quot;);//移动皮卡丘到下一个位置 position=position+step;//增加position值 } else if((pikaqiu2.hasClass(&apos;type4&apos;))&amp;&amp;(!pushBox.hasClass(&apos;type4&apos;))&amp;&amp;(pushBox.hasClass(&apos;type1&apos;)|| pushBox.hasClass(&apos;type2&apos;)) ) { //推箱子 //如果下一个div的class包含type4(箱子)并且 不包含重叠type4(箱子) 并且 包含class type1（目标位置）或者 包含type2(空路) pikaqiu2.removeClass(&apos;type4&apos;);//移除当前箱子 pikaqiu1.removeClass(&quot;pusher&quot;);//移除当前皮卡丘 pushBox.addClass(&apos;type4&apos;);//移动箱子到下一个位置 pikaqiu2.addClass(&quot;pusher&quot;).addClass(&quot;type2&quot;);// //本来是type4 移除之后，这里没有class了，要变成普通路径 position=position+step;//增加position值 } } 3.胜利判断：每次移动都要调用这个胜利判断。 function win(){ //胜利条件判断 if($(&quot;.type1.type4&quot;).length===goal){ //推的箱子与关卡设置通过箱子的数量对比 if(level&lt;9) { alert(&quot;666，挑战下一关吧--OBKoro1&quot;); level++; //关卡+1 goal = goalList[level]; position = origin[level]; create(); }else { alert(&quot;厉害啊 大佬 通关了都&quot;); } } } 代码地址、demo地址结语本文到这里就结束了，喜欢的话，赶紧自己去敲一个出来，希望本文可以帮助大家发散思维。 最后：如需转载，请放上原文链接并署名。码字不易，感谢支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。然后就是希望看完的朋友点个喜欢，也可以关注一下我。个人blog and 掘金个人主页 以上2018.1.7]]></content>
      <categories>
        <category>小demo</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>jq</tag>
        <tag>小demo</tag>
        <tag>H5小游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue先hash 模式部署项目，然后开启histroy模式 ，引发的几个问题以及histroy模式的开启方式、优点]]></title>
    <url>%2F2017%2F12%2F25%2Fvue%E5%85%88hash-%E6%A8%A1%E5%BC%8F%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%EF%BC%8C%E7%84%B6%E5%90%8E%E5%BC%80%E5%90%AFhistroy%E6%A8%A1%E5%BC%8F-%EF%BC%8C%E5%BC%95%E5%8F%91%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8Ahistroy%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BC%80%E5%90%AF%E6%96%B9%E5%BC%8F%E3%80%81%E4%BC%98%E7%82%B9%2F</url>
    <content type="text"><![CDATA[前言：vue路由有一个HTML5 History 模式,这个模式要在路由里面另外开启的，很多人在刚使用路由的时候之前不知道这个模式，所以并没有启用，然后就把项目部署上去了，因为这个模式还是有挺多优点的，最后还是会开启这个模式。 然而因为之前使用hash模式再改为histroy模式还是有些问题的，我已经踩过坑了，然后把这几个问题写出来。有需要的朋友可以做一下参考，喜欢的可以点波赞，或者关注一下，希望可以帮到大家。 本文首发于我的个人blog：obkoro1.com 开启history模式：如果不开启的话，路由默认是hash模式，开启这个模式前端的工作也很简单，如下： mode: &apos;history&apos; //在路由那里配置一下这个 最后需要后端的做一些配置配合，这里可以参考一下文档给的栗子。 history模式的优点: url变成真正的url，url看上去更好看。 http://yoursite.com/#/a/b //hash模式 http://yoursite.com/a/b //history模式 可以使用vue-router的滚动行为，这个用来记忆进入其他页面之前的位置非常好用，配置一下就可以直接使用了，前提是开启histroy模式。 类似项目引入微信js-sdk的时候，一些操作是对url是有要求，url不能带上’#’，如果没有开启histroy模式，很可能会导致问题。 像vue-cli的配置，都是以路由开启history模式的标准来配置的（下面会讲到一个栗子），没有开启的话，自己要另外配置。 先hash模式，后histroy模式就像开头说的，这里的问题指的是：先用hash模式部署项目到线上，然后再开启histroy模式，由此引发的一些问题。 1.找不到资源问题：在hash模式下面，直接打包的话，会导致找不到css、js和图片资源，然后经过百度之后，做出了如下截图的配置操作，更改assetsPublicPath：&#39;/&#39;为 assetsPublicPath：&#39;./&#39; 在hash模式下，像上面那么配置就没有问题了。当时我还以为vue-cli配置有问题，实际上，人家才没有问题呢，是我们自己没有开启history模式的问题。 然后开启了histroy模式之后，因为我们之前更改了assetsPublicPath属性，所以要把那个.给去掉，改回来：assetsPublicPath：&#39;/&#39; 2.请求带上路由，导致请求失败正确的请求是：http:www.xxx.com/api/接口 //api是我通过proxyTable转发地址的代理名字 开启histroy模式之后：在二层的路由里面会出现这种情况： 路由是：http:www.xxx.com/a/b http:www.xxx.com/api/a/接口 //这就导致了请求失败，要把a也去掉才是正确的 解决方式是： 因为我用的是axios，所以可以在全局请求中设置一个baseURL，这个baseURL就是项目的网站地址（http:www.xxx.com）,然后二层的路由也会自动去掉前面的a和b。 3.cookie问题这个实际上不是个问题，完全是自己作的，我把项目分为两层。所以从a登录，b那边刷新就会出现没有cookie的情况。 两层路由 http://yoursite.com/a http://yoursite.com/b 这里是因为cookie能否拿到跟存储的路由位置是有关的，之前使用hash模式因为hash模式的urlhttp://yoursite.com/#/a/b，会统一存在http://yoursite.com下面。 而history模式cookie就会存在http://yoursite.com/a或者http://yoursite.com/b下面，另外一边就会没有cookiie。 解决办法： 不要分为两层，统一所有的路由都在一个路由地址下面。 在项目的路由的根地址path:&#39;/&#39;里面存cookie。 使用sessionStorage存信息，我就是用这个方法，使用方法。 sessionStorage只要在http://yoursite.com都可以访问的到，不管是存在a上面还是b上面。 后话以上就是本文的所有内容，建议项目一开始还是直接跟后端说一下，开启histroy模式，省得后面的种种坑。上面的内容都是本人亲自踩坑之后的血泪教训，希望可以帮助到需要的朋友，然后祝大家圣诞节快乐。 最后：如需转载，请放上原文链接并署名。码字不易，感谢支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。然后就是希望看完的朋友点个喜欢，也可以关注一下我。个人blog and 掘金个人主页 以上2017.12.25]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue-router</tag>
        <tag>Vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 项目如何引入微信sdk，使用微信分享接口]]></title>
    <url>%2F2017%2F12%2F16%2Fvue-%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E5%BC%95%E5%85%A5%E5%BE%AE%E4%BF%A1sdk%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%BE%AE%E4%BF%A1%E5%88%86%E4%BA%AB%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[写在前面：做微信的网页基本上都要接入微信的sdk，我在做的时候，也颇费了一番功夫，然后就想记录一下，供自己日后翻阅，以及让有需要的朋友可以做一下参考，如果喜欢的可以点波赞，或者关注一下，希望可以帮到大家。 本文首发于我的个人blog：obkoro1.com 安装sdknpm install weixin-js-sdk --save 开始之前大家可以先读一读微信公众号的 接入文档，vue是单页面项目，比如你想要接入微信分享功能，分享功能在每个路由地址都要有，因为每个路由的url是不一样的，搜易就需要在每个路由地址都引入一遍。 整体步骤： vue引入sdk的话，就是在路由组件里面的，组件生命周期的：creatd()和mounted()里面放代码。 用伪代码，熟悉一下整体的流程，要做哪些事情： //wx是引入的微信sdk wx.config(&apos;这里有一些参数&apos;);//通过config接口注入权限验证配置 wx.ready(function() { //通过ready接口处理成功验证 // config信息验证成功后会执行ready方法 wx.onMenuShareAppMessage({ // 分享给朋友 ,在config里面填写需要使用的JS接口列表，然后这个方法才可以用 title: &apos;这里是标题&apos;, // 分享标题 desc: &apos;This is a test!&apos;, // 分享描述 link: &apos;链接&apos;, // 分享链接 imgUrl: &apos;图片&apos;, // 分享图标 type: &apos;&apos;, // 分享类型,music、video或link，不填默认为link dataUrl: &apos;&apos;, // 如果type是music或video，则要提供数据链接，默认为空 success: function() { // 用户确认分享后执行的回调函数 }, cancel: function() { // 用户取消分享后执行的回调函数 } }); wx.onMenuShareTimeline({ //分享朋友圈 title: &apos;标题&apos;, // 分享标题 link: &apos;链接&apos;, imgUrl: &apos;图片&apos;, // 分享图标 success: function() { // 用户确认分享后执行的回调函数 }, cancel: function() { // 用户取消分享后执行的回调函数 } }); }); wxx.error(function(res){//通过error接口处理失败验证 // config信息验证失败会执行error函数 }); 上面的流程多看几遍，对整个流程有个概念，其中最重要的一步就是下面这个借口注入权限。 config接口注入权限接入微信接口的最主要也是最重要一步步就是填写下面这些信息，填完这些信息之后，基本就好了。下面这些信息通常是通过后端接口来获取的。 wx.config({ debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。 appId: &apos;&apos;, // 必填，公众号的唯一标识 timestamp: , // 必填，生成签名的时间戳 nonceStr: &apos;&apos;, // 必填，生成签名的随机串 signature: &apos;&apos;,// 必填，签名，见附录1 jsApiList: [] // 必填，需要使用的JS接口列表，所有JS接口列表见附录2 }); 获取config配置信息：前端要获取上面那些信息，不用做太多东西，只要调后端接口就可以了。后端会把那些信息处理好，然后通过一个接口返给你这些参数。你要给后端传一个当前路由页面的完整url，后端就会返回上述的那些信息给你，后面就可以根据自己的需求调用相应的接口，自定义里面的东西。 坑点：url这里要注意的就是url的问题，如果url没有正确传递，后端也会返回信息，但是签名信息会是错误的。 上面提到的完整url指的是：’http(s)://‘部分，以及’？’后面的GET参数部分,但不包括’#’hash后面的部分。可以通过location.href来获取。 注意： 如果你的vue项目，路由没有开启history 模式,也就是你的url上面包含“#”，这个时候要从后端正确获取签名，就需要去掉url上#后面的字符。（url去掉’#’hash部分，可用location.href.split(&#39;#&#39;)[0]） 封装调用sdk注入：因为要在每个路由页面都注入sdk，这个肯定要复用的，不然那么多代码，看着就头大。 我是这么做的： 因为我把axios包了一层，然后把axios接口，在main.js里面挂载到Vue实例。 然后在全局函数里面调用这个接口，然后在每个路由页面的相应组件里面调用这个函数，把当前页面的url以及其他标题、图片什么的传进去。 里面的具体步骤就不说了，最重要的是参考上面的那个流程，函数里面的东西也都是基于那个流程的。 签名校验：当你反复确认步骤都没有问题，微信sdk注入还是签名失败的时候，这个时候你就要考虑是不是后端那边的算法有问题，可以把后端返回的签名和微信提供的JS 接口签名校验工具生成的签名对比一下，或许是后端那边算法的问题也不一定。 后话实不相瞒，当时我做的时候就是被url这个坑了，第一次做这个东西，没有经验，折腾了好久。引入sdk并不难，重要的是那个配置信息要填写正确，然后其他的就根据实际需求来做了。 最后：如需转载，请放上原文链接并署名。码字不易，感谢支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。然后就是希望看完的朋友点个喜欢，也可以关注一下我。个人blog and 掘金个人主页 以上2017.12.16]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[江湖再见]]></title>
    <url>%2F2017%2F12%2F13%2F%E6%B1%9F%E6%B9%96%E5%86%8D%E8%A7%81%2F</url>
    <content type="text"><![CDATA[事件：http://mp.weixin.qq.com/s/Lg2JgZuJ3JBFUnz-6NOHDQ 用脚投票饱醉豚骂程序员，一竿子打翻一船的人，简叔还为之站队，深深感受到了简书的恶意。人微言轻决定用脚投票，删了所有文章，再也不来简书，可能程序员根本不是简书的用户群体吧，那么江湖再见。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[手摸手教你在vue-cli里面使用vuex，以及vuex简介]]></title>
    <url>%2F2017%2F12%2F09%2F%E6%89%8B%E6%91%B8%E6%89%8B%E6%95%99%E4%BD%A0%E5%9C%A8vue-cli%E9%87%8C%E9%9D%A2%E4%BD%BF%E7%94%A8vuex%EF%BC%8C%E4%BB%A5%E5%8F%8Avuex%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[写在前面：这篇文章是在vue-cli里面使用vuex的一个极简demo，附带一些vuex的简单介绍。有需要的朋友可以做一下参考，喜欢的可以点波赞，或者关注一下，希望可以帮到大家。 本文首发于我的个人blog：obkoro1.com 引入步骤我创建了一个新的vue-cli里面什么东西都没有，只引用了vuex，这里是码云地址,可以下载下来，然后npm install、npm run dev试试看，里面vuex的使用地方也全都注释了一遍。 安装npm install vuex --save 在src目录下创建文件夹vuex 该文件夹包含以上文件，创建好了之后，我们一个一个文件来说里面都有什么东西。 vuex/index.jsimport Vue from &apos;vue&apos;; import Vuex from &apos;vuex&apos;; import status from &apos;./modules/status/index&apos;;//引进模块 Vue.use(Vuex); export default new Vuex.Store({ modules: { //Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action dataStatus:status,//访问这里面数据的时候要使用&apos;dataStatus&apos; }, }); 这是vuex的主文件store，这个例子是把state、mutation、action分割成模块，然后再将每个模块引用进这个index.js文件里面，等我们整个文件夹的文件都搭好之后，还要把文件引入到main.js里面、 vuex/modules/status/index.jsimport actions from &apos;./actions&apos;; import mutations from &apos;./mutations&apos;; //引入action和mutations export default { state:{ //这里面是要读取或者写入数据的地方 msg:&apos;默认状态&apos;, }, //state actions mutations顺序不能乱 actions: actions, mutations: mutations, } 这是一个模块里面的主文件，模块内部拥有自己的state、actions、mutions，是从上到下进行分割的。 vuex/modules/status/mutation_type.js//这个js文件里面只是一些变量，把action和mutation文件里面相同变量名的链接起来 export const VUEX_TEST = &apos;VUEX_TEST&apos;; // 一般使用的是大写来命名变量，因为尤大也是这么做 2333 vuex/modules/status/actions.jsimport * as types from &apos;./mutation_type&apos;; //引入变量 export default { actionFn({commit},data){ //actionFn是在组件通过dispatch触发的函数名 可以理解成组件和actions的连接 commit(types.VUEX_TEST,data); //types.VUEX_TEST 是要commit到mutation的哪个位置 变量的作用 //data 是传过来的参数 } }; vuex/modules/status/mutations.jsimport * as types from &apos;./mutation_type&apos;;//引入变量 export default { //types.VUEX_TEST 代表接受哪个actions的commit 也就是上面引入变量的作用 [types.VUEX_TEST](state,data){ //第一个参数state是这个模块的state 第二个参数是传进来的数据 if(data.status==1){ //根据传进来的参数做各种操作 //这里就是操作state了，赋值之后，各个组件上面引用该数据的地方会自动更新 state.msg=data.text; }else if(data.status==2){ state.msg=&apos;奕迅&apos;; } //这里是随便写的一个栗子 console.log(state.mg,data,&apos;mutation&apos;); } }; 这两个文件里面有注释，解释的蛮清楚的。当把所有文件创建好了之后，再回过头来看看每个文件之间都有联系,多想想或许就懂点什么东西了 emmm vuex文件夹，文件目录以及下载引入main.js 上面的vuex文件夹只是搭建一个store，但是这样还不够，我们还要在项目里面使用这个。引用到main.js，如图所示。 组件中如何使用。 使用的话就是像上面那么使用，本文只是一个简单的示例，还有更多骚操作，等大家上手之后再慢慢摸索咯。 git地址感觉写的蛮乱的，大家如果看不太懂的话，可以到码云去下载文件，然后自己跑一跑，多看看，试一试就应该没问题了。 vuex简介通常我是希望大家先学会用，然后再了解后面的机制，每次我看博文的时候，一大段原理贴上来，都给我弄懵逼了。。 vuex主要是用来复杂项目之间的组件通信功能，简单的项目不要用这套复杂的事件以及状态管理机制。项目如果不够复杂的话推荐我之前写的：在vue项目中 如何定义全局变量 全局函数，使用全局变量的形式的也可以实现需求。 vuex实现的作用：数据共享机制通过统一的数据中心store维护状态数据，每个组件进行更新的时候，通知数据中心store。再由stroe将共享的状态，触发每一个调用它的组件的更新。 vuex的工作流程大家先仔细看看下面这张图，理解他的工作机制。 在vue组件里面，通过dispatch来触发actions提交修改数据的操作。 然后再通过actions的commit来触发mutations来修改数据。 mutations接收到commit的请求，就会自动通过Mutate来修改state（数据中心里面的数据状态）里面的数据。 最后由store触发每一个调用它的组件的更新 注意：这套模型是单向流动的后话以上就是本文的所有内容了，希望可以帮到大家。 最后：如需转载，请放上原文链接并署名。码字不易，感谢支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。然后就是希望看完的朋友点个喜欢，也可以关注一下我。个人blog and 掘金个人主页 以上2017.12.9]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue-cli</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie、localStorage和sessionStorage 三者之间的区别以及存储、获取、删除等使用方式]]></title>
    <url>%2F2017%2F11%2F25%2Fcookie%E3%80%81localStorage%E5%92%8CsessionStorage%20%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%AD%98%E5%82%A8%E3%80%81%E8%8E%B7%E5%8F%96%E3%80%81%E5%88%A0%E9%99%A4%E7%AD%89%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[写在前面：前端开发的时候，在网页刷新的时候，所有数据都会被清空，这时候就要用到本地存储的技术，前端本地存储的方式有三种，分别是cookie，localstorage和sessionStorage ，这是大家都知道的。本文的主要内容就是针对这三者的存放、获取，区别、应用场景。有需要的朋友可以做一下参考，喜欢的可以点波赞，或者关注一下，希望可以帮到大家。 本文首发于我的个人blog：obkoro1.com 使用方式：很多文档都是说了一大堆，后面用法都没有说，先要学会怎么用，不然后面的都是扯淡，所以这里我先把使用方式弄出来。 cookie:保存cookie值： var dataCookie=&apos;110&apos;; document.cookie = &apos;token&apos; + &quot;=&quot; +dataCookie; 获取指定名称的cookie值 function getCookie(name) { //获取指定名称的cookie值 // (^| )name=([^;]*)(;|$),match[0]为与整个正则表达式匹配的字符串，match[i]为正则表达式捕获数组相匹配的数组； var arr = document.cookie.match(new RegExp(&quot;(^| )&quot;+name+&quot;=([^;]*)(;|$)&quot;)); if(arr != null) { console.log(arr); return unescape(arr[2]); } return null; } var cookieData=getCookie(&apos;token&apos;); //cookie赋值给变量。 先贴这两个最基础的方法，文末有个demo里面还有如何设置cookie过期时间，以及删除cookie的、 localStorage和sessionStorage:localStorage和sessionStorage所使用的方法是一样的，下面以sessionStorage为栗子： var name=&apos;sessionData&apos;; var num=120; sessionStorage.setItem(name,num);//存储数据 sessionStorage.setItem(&apos;value2&apos;,119); let dataAll=sessionStorage.valueOf();//获取全部数据 console.log(dataAll,&apos;获取全部数据&apos;); var dataSession=sessionStorage.getItem(name);//获取指定键名数据 var dataSession2=sessionStorage.sessionData;//sessionStorage是js对象，也可以使用key的方式来获取值 console.log(dataSession,dataSession2,&apos;获取指定键名数据&apos;); sessionStorage.removeItem(name); //删除指定键名数据 console.log(dataAll,&apos;获取全部数据1&apos;); sessionStorage.clear();//清空缓存数据：localStorage.clear(); console.log(dataAll,&apos;获取全部数据2&apos;); 使用方式，基本上就上面这些，其实也是比较简单的。大家可以把这个copy到自己的编译器里面，或者文末有个demo，可以点开看看。 三者的异同：上面的使用方式说好了，下面就唠唠三者之间的区别，这个问题其实很多大厂面试的时候也都会问到，所以可以注意一下这几个之间的区别。 生命周期：cookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效 localStorage：除非被手动清除，否则将会永久保存。 sessionStorage： 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除。 存放数据大小：cookie：4KB左右 localStorage和sessionStorage：可以保存5MB的信息。 http请求：cookie：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 localStorage和sessionStorage：仅在客户端（即浏览器）中保存，不参与和服务器的通信 易用性：cookie：需要程序员自己封装，源生的Cookie接口不友好 localStorage和sessionStorage：源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 应用场景：从安全性来说，因为每次http请求都会携带cookie信息，这样无形中浪费了带宽，所以cookie应该尽可能少的使用，另外cookie还需要指定作用域，不可以跨域调用，限制比较多。但是用来识别用户登录来说，cookie还是比stprage更好用的。其他情况下，可以使用storage，就用storage。 storage在存储数据的大小上面秒杀了cookie，现在基本上很少使用cookie了，因为更大总是更好的，哈哈哈你们懂得。 localStorage和sessionStorage唯一的差别一个是永久保存在浏览器里面，一个是关闭网页就清除了信息。localStorage可以用来夸页面传递参数，sessionStorage用来保存一些临时的数据，防止用户刷新页面之后丢失了一些参数。 浏览器支持情况：localStorage和sessionStorage是html5才应用的新特性，可能有些浏览器并不支持，这里要注意。 cookie的浏览器支持没有找到，可以通过下面这段代码来判断所使用的浏览器是否支持cookie： if(navigator.cookieEnabled) { alert(&quot;你的浏览器支持cookie功能&quot;);//提示浏览器支持cookie } else { alert(&quot;你的浏览器不支持cookie&quot;);//提示浏览器不支持cookie } 数据存放处： 番外：各浏览器Cookie大小、个数限制。cookie 使用起来还是需要小心一点，有兴趣的可以看一下这个链接。 demo链接把上面的demo代码，上传到github上面了，有需要的小伙伴们，可以看一下。传送门 后话最后要说的是：不要把什么数据都放在 Cookie、localStorage 和 sessionStorage中，毕竟前端的安全性这么低。只要打开控制台就可以任意的修改 Cookie、localStorage 和 sessionStorage的数据了。涉及到金钱或者其他比较重要的信息，还是要存在后台比较好。 最后：如需转载，请放上原文链接并署名。码字不易，感谢支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。然后就是希望看完的朋友点个喜欢，也可以关注一下我。blog网站 and 掘金个人主页 以上2017.11.25 参考链接：HTML 5 Web 存储localStorage和sessionStorage详解详说 Cookie, LocalStorage 与 SessionStorage]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>-js - html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue router 使用params query传参，以及有什么区别]]></title>
    <url>%2F2017%2F11%2F12%2Fvue-router-%E4%BD%BF%E7%94%A8params-query%E4%BC%A0%E5%8F%82%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[写在前面：传参是前端经常需要用的一个操作，很多场景都会需要用到上个页面的参数，本文将会详细介绍vue router 是如何进行传参的，以及一些小细节问题。有需要的朋友可以做一下参考，喜欢的可以点波赞，或者关注一下，希望可以帮到大家。 本文首发于我的个人blog：obkoro1.com Vue router如何传参params、query是什么？ params：/router1/:id ，/router1/123，/router1/789 ,这里的id叫做params query：/router1?id=123 ,/router1?id=456 ,这里的id叫做query。 路由界面：router.js: 路由设置这里，当你使用params方法传参的时候，要在路由后面加参数名，并且传参的时候，参数名要跟路由后面设置的参数名对应。使用query方法，就没有这种限制，直接在跳转里面用就可以。 注意：如果路由上面不写参数，也是可以传过去的，但不会在url上面显示出你的参数，并且当你跳到别的页面或者刷新页面的时候参数会丢失（如下图所示），那依赖这个参数的http请求或者其他操作就会失败。 注意看上面的路由参数，id这个参数是我们有设置在路由上面的，id2我没有设置在路由里面，所以刷新之后id2就不见了，在项目中，我们总不可能要求用户不能刷新吧。 组件1：&lt;template&gt; &lt;div class=&quot;app_page&quot;&gt; &lt;h1&gt;从这个路由传参到别的路由&lt;/h1&gt; &lt;router-link :to=&quot;{ name:&apos;router1&apos;,params: { id: status ,id2: status3},query: { queryId: status2 }}&quot; &gt; router-link跳转router1 &lt;/router-link&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &apos;app_page&apos;, data () { return { status:110, status2:120, status3:119 } }, } &lt;/script&gt; 编程式导航跳转：上面的router-link传参，也可以使用router文档里面的编程式导航来跳转传参。 this.$router.push({ name:&apos;router1&apos;,params: { id: status ,id2: status3},query: { queryId: status2 }}); //编程跳转写在一个函数里面，通过click等方法来触发 这两种传参效果是一模一样的，编程式导航，可以用来做判断跳转，比如是否授权，是否登录，等等状态，对此不太了解的小伙伴们，可以跳过这个编程式导航，以后再来看。 组件2：&lt;template&gt; &lt;div class=&quot;router1&quot;&gt; &lt;h1&gt;接收参数的路由&lt;/h1&gt; &lt;h1&gt; params.id：{{ $route.params }}&lt;/h1&gt; &lt;h1&gt;query.status:{{ $route.query.queryId }}&lt;/h1&gt; &lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;/div&gt; &lt;/template&gt; 传参还是比较简单的，按着上面组件的使用方法就可以成功传过去了。 提示：获取路由上面的参数，用的是$route，后面没有r。 params传参和query传参有什么区别： 1、params是路由的一部分,必须要有。query是拼接在url后面的参数，没有也没关系。 params一旦设置在路由，params就是路由的一部分，如果这个路由有params传参，但是在跳转的时候没有传这个参数，会导致跳转失败或者页面会没有内容。 比如：跳转/router1/:id &lt;router-link :to=&quot;{ name:&apos;router1&apos;,params: { id: status}}&quot; &gt;正确&lt;/router-link&gt; &lt;router-link :to=&quot;{ name:&apos;router1&apos;,params: { id2: status}}&quot;&gt;错误&lt;/router-link&gt; 2、params、query不设置也可以传参，params不设置的时候，刷新页面或者返回参数会丢失，这一点的在上面说过了 后话：本文到这里就结束了，写的不好的地方，请各位大佬们见谅。 最后：如需转载，请放上原文链接并署名。码字不易，感谢支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。然后就是希望看完的朋友点个喜欢，也可以关注一下我。blog网站 and 掘金个人主页 以上2017.11.12]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>传参</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Vue-cli里基于axios封装复用请求]]></title>
    <url>%2F2017%2F11%2F05%2F%E5%9C%A8Vue-cli%E9%87%8C%E5%9F%BA%E4%BA%8Eaxios%E5%B0%81%E8%A3%85%E5%A4%8D%E7%94%A8%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[写在前面：自从Vue2.0推荐大家使用 axios 开始，axios 被越来越多的人所了解。使用axios发起一个请求对大家来说是比较简单的事情，但是axios没有进行封装复用，项目越来越大，引起的代码冗余。就会非常麻烦的一件事。所以本文会详细的跟大家介绍，如何封装请求，并且在项目组件中复用请求。有需要的朋友可以做一下参考，喜欢的可以点波赞，或者关注一下，希望可以帮到大家。 本文首发于我的个人blog：obkoro1.com 安装只用安装一个axios就可以了。 npm install axios --save 接口代理设置为了请求可以正常发送，我们一般要进行一个接口代理的配置，这样可以避免请求跨域，项目打包之后，后端一般也要搭建一个nginx之类的东西进行转发请求，不然请求会因为跨域问题失败的。 //文件位置：config/index.js proxyTable: { &apos;/api&apos;: { target: &apos;http://47.95.xxx.246:8080&apos;, // 通过本地服务器将你的请求转发到这个地址 changeOrigin: true, // 设置这个参数可以避免跨域 pathRewrite: { &apos;/api&apos;: &apos;/&apos; } }, }, 设置好了之后，当你在项目中要调用http://47.95.xxx.246:8080这个服务器里面的接口，可以直接用/api代替服务器地址。 发起请求main.js入口文件中：import axios from &apos;axios&apos;;//引入文件 Vue.prototype.$http = axios;//将axios挂载到Vue实例中的$ajax上面,在项目中的任何位置通过this.$http使用 没有封装发起请求：//没有封装的时候，在组件中发起请求的方式： this.$ajax({ url:&apos;/api/articles&apos;,//api 代理到json文件地址，后面的后缀是文件中的对象或者是数组 method:&apos;get&apos;,//请求方式 //这里可以添加axios文档中的各种配置 }).then(function (res) { console.log(res,&apos;成功&apos;); }).catch(function (err) { console.log(err,&apos;错误&apos;); }) //还可以像下面这么简写 this.$ajax.get(&apos;api/publishContent&apos;).then((res) =&gt; { console.log(res,&apos;请求成功&apos;) },(err)=&gt;{ console.log(err,&apos;请求失败&apos;); }); 封装请求封装的时候，我通常喜欢把请求抽象成三个文件，文件位置放在src中，只要你能引用到，就没问题，如下图所示： 创建三个.js文件，里面我都很认真的注释了，我就直接贴图片了，在文末我把这三个文件的地址发出来，需要的小伙伴自取。 fetch.js： url.js: api.js 在组件里面如何使用接口： 封装axios文件地址在这里：传送门代码注释什么的，已经蛮多了，跟着文章一步一步走，实现封装axios请求，没毛病的。本文并没有把很多功能都完整的列出来，主要是追求一个上手，剩下的东西，各位小伙伴们可以自行研究。 最后：如需转载，请放上原文链接并署名。码字不易，感谢支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。然后就是希望看完的朋友点个喜欢，也可以关注一下我。blog网站 and 掘金个人主页 以上2017.11.5]]></content>
      <categories>
        <category>vue-cli</category>
      </categories>
      <tags>
        <tag>axios</tag>
        <tag>axios封装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-cli 使用json server在本地模拟请求数据]]></title>
    <url>%2F2017%2F11%2F01%2FVue-cli-%E4%BD%BF%E7%94%A8json-server%E5%9C%A8%E6%9C%AC%E5%9C%B0%E6%A8%A1%E6%8B%9F%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[写在前面：开发的时候，前后端不论是否分离，接口多半是滞后于页面开发的。所以建立一个REST风格的API接口，给前端页面提供虚拟的数据，是非常有必要的。json server 作为模拟工具，因为设置简单，容易上手。本文是做一个简单的上手介绍，有需要的朋友可以做一下参考，喜欢的可以点波赞，或者关注一下，希望可以帮到大家。 本文首发于我的个人blog：obkoro1.com json server 工具:在后台还没给接口之前，使用JSON-Server搭建一台JSON服务器，将接口要返回的数据放在json文件里面。然后请求这些数据，这样我们可以先做一些东西，等后台接口好了之后直接替换就可以了，不必一直傻傻的等后端的接口。 安装：npm install json-server --save //json server npm install axios --save //使用axios发送请求 json文件：创建一个json文件，起名叫db.json，文件放置在跟index.html平级的目录中，也可以放置在static文件夹中，db.json文件里面的内容，是一个对象。 设置：位置： build/dev-server.js //json-server 假数据 var jsonServer = require(&apos;json-server&apos;) //引入文件 var apiServer = jsonServer.create(); //创建服务器 var apiRouter = jsonServer.router(&apos;db.json&apos;) //引入json 文件 ，这里的地址就是你json文件的地址 var middlewares = jsonServer.defaults(); //返回JSON服务器使用的中间件。 apiServer.use(middlewares) apiServer.use(&apos;/json&apos;,apiRouter) apiServer.listen( port + 1,function(){ //json服务器端口:比如你使用8080,这里的json服务器就是8081端口 console.log(&apos;JSON Server is running&apos;) //json server成功运行会在git bash里面打印出&apos;JSON Server is running&apos; }) 如图所示： 请求接口代理：proxyTable: { &apos;/api&apos;: { target: &apos;http://localhost:8081/&apos;, // 通过本地服务器将你的请求转发到这个地址 changeOrigin: true, // 设置这个参数可以避免跨域 pathRewrite: { &apos;/api&apos;: &apos;/&apos; } }, }, 如下图所示： npm run dev启动项目可以访问到你的json文件：现在服务器已经成功启动，在地址栏输入 localhost:8081，就可以看到的json文件，加上相应后缀即可访问文件里面的数据。下面几张图片出自：biubiubiuzzz jsonserver服务器： json数据： axios请求json数据：光看到这些数据可不行，我们还需要发起请求，请求到这些数据，然后执行各种各样的骚操作。 main.js文件中：import axios from &apos;axios&apos;;//引入文件 Vue.prototype.$ajax = axios;//将axios挂载到Vue实例中的$ajax上面,在项目中的任何位置通过this.$ajax使用 在组件中的使用方式，比如： this.$ajax({ url:&apos;/api/articles&apos;,//api 代理到json文件地址，后面的后缀是文件中的对象或者是数组 method:&apos;get&apos;,//请求方式 //这里可以添加axios文档中的各种配置 }).then(function (res) { console.log(res,&apos;成功&apos;); }).catch(function (err) { console.log(err,&apos;错误&apos;); }) //还可以像下面这么简写 this.$ajax.get(&apos;api/publishContent&apos;).then((res) =&gt; { console.log(res,&apos;请求成功&apos;) },(err)=&gt;{ console.log(err,&apos;请求失败&apos;); }); JSON-Server只接受GET请求，GitHub上提到：If you make POST, PUT, PATCH or DELETE requests, changes will be automatically and safely saved to db.json using lowdb. lowdb介绍： http://www.jianshu.com/p/11d04a4c22af 文档：附上json server的github，和axios的中文文档，大家可以进去研究一下。 json server设置和使用起来还是蛮方便的，大家感兴趣的话，可以跟着文章设置一波。 最后：如需转载，请放上原文链接并署名。码字不易，感谢支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。然后就是希望看完的朋友点个喜欢，也可以关注一下我。blog网站 and 掘金个人主页 以上2017.11.1 参考资料:JSON-Server使用 vue-cli下配置json-server]]></content>
      <categories>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>vue-cli配置</tag>
        <tag>工具</tag>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在vue项目中 如何定义全局变量 全局函数]]></title>
    <url>%2F2017%2F10%2F23%2F%E5%9C%A8vue%E9%A1%B9%E7%9B%AE%E4%B8%AD-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F-%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[写在前面：如题，在项目中，经常有些函数和变量是需要复用，比如说网站服务器地址，从后台拿到的：用户的登录token,用户的地址信息等，这时候就需要设置一波全局变量和全局函数，这两个设置不太难，而且有一些共通之处，可能有一些朋友对此不太了解，所以随便写出来分享一波。有需要的朋友可以做一下参考，喜欢的可以点波赞，或者关注一下，希望可以帮到大家。 定义全局变量原理：设置一个专用的的全局变量模块文件，模块里面定义一些变量初始状态，用export default 暴露出去，在main.js里面使用Vue.prototype挂载到vue实例上面或者在其它地方需要使用时，引入该模块便可。 全局变量模块文件： Global.vue文件： &lt;script&gt; const serverSrc=&apos;www.baidu.com&apos;; const token=&apos;12345678&apos;; const hasEnter=false; const userSite=&quot;中国钓鱼岛&quot;; export default { userSite,//用户地址 token,//用户token身份 serverSrc,//服务器地址 hasEnter,//用户登录状态 } &lt;/script&gt; 使用方式1：在需要的地方引用进全局变量模块文件，然后通过文件里面的变量名字获取全局变量参数值。 在text1.vue组件中使用： &lt;template&gt; &lt;div&gt;{{ token }}&lt;/div&gt; &lt;/template&gt; &lt;script&gt; import global_ from &apos;../../components/Global&apos;//引用模块进来 export default { name: &apos;text&apos;, data () { return { token:global_.token,//将全局变量赋值到data里面，也可以直接使用global_.token } } } &lt;/script&gt; &lt;style lang=&quot;scss&quot; scoped&gt; &lt;/style&gt; 使用方式2：在程序入口的main.js文件里面，将上面那个Global.vue文件挂载到Vue.prototype。 import global_ from &apos;./components/Global&apos;//引用文件 Vue.prototype.GLOBAL = global_//挂载到Vue实例上面 接着在整个项目中不需要再通过引用Global.vue模块文件，直接通过this就可以直接访问Global文件里面定义的全局变量。 text2.vue： &lt;template&gt; &lt;div&gt;{{ token }}&lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &apos;text&apos;, data () { return { token:this.GLOBAL.token,//直接通过this访问全局变量。 } } } &lt;/script&gt; &lt;style lang=&quot;scss&quot; scoped&gt; &lt;/style&gt; Vuex也可以设置全局变量：通过vuex来存放全局变量，这里东西比较多，也相对复杂一些，有兴趣的小伙伴们，可自行查阅资料，折腾一波、 定义全局函数原理新建一个模块文件，然后在main.js里面通过Vue.prototype将函数挂载到Vue实例上面，通过this.函数名，来运行函数。 1. 在main.js里面直接写函数简单的函数可以直接在main.js里面直接写 Vue.prototype.changeData = function (){//changeData是函数名 alert(&apos;执行成功&apos;); } 组件中调用： this.changeData();//直接通过this运行函数 2. 写一个模块文件，挂载到main.js上面。base.js文件，文件位置可以放在跟main.js同一级，方便引用 exports.install = function (Vue, options) { Vue.prototype.text1 = function (){//全局函数1 alert(&apos;执行成功1&apos;); }; Vue.prototype.text2 = function (){//全局函数2 alert(&apos;执行成功2&apos;); }; }; main.js入口文件： import base from &apos;./base&apos;//引用 Vue.use(base);//将全局函数当做插件来进行注册 组件里面调用： this.text1(); this.text2(); 后话上面就是如何定义全局变量 全局函数的内容了，这里的全局变量全局函数可以不局限于vue项目，vue-cli是用了webpack做模块化，其他模块化开发，定义全局变量、函数的套路基本上是差不多。上文只是对全局变量，全局函数的希望看完本文能给大家一点帮助。 最后：如需转载，请放上原文链接并署名。码字不易，感谢支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。然后就是希望看完的朋友点个喜欢，也可以关注一下我。blog网站 and 掘金个人主页 以上2017.10.23 参考资料:详解VUE 定义全局变量的几种实现方式 Vue中如何定义全局函数Vue.use源码分析export default]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue-cli配置</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 计算两个时间的时间差]]></title>
    <url>%2F2017%2F10%2F15%2Fjs-%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AA%E6%97%B6%E9%97%B4%E7%9A%84%E6%97%B6%E9%97%B4%E5%B7%AE%2F</url>
    <content type="text"><![CDATA[写在前面：如题，就像题目说的需要计算出时间差，虽然不太难，但这个需求经常会在项目中遇到的，我在这边做一下整理，希望能够尽量全的整理出来。有需要的朋友可以做一下参考，喜欢的可以点波赞，或者关注一下，希望可以帮到大家。 计算时间差原理：getTime()方法方法定义： getTime() 方法可返回距 1970 年 1 月 1 日之间的毫秒数。 通常我们计算时间差都是通过获取两个时间数据，然后分别使用getTime（）方法返回与固定的1970 年 1 月 1 日的时间差，通过对返回毫秒数的差，换算成时间单位，得出两个时间的时间差。 开始操作：首先你会有一串初始的时间数据，然后通过 new Date(你的时间数据)，将你的数据转成Date对象的形式。 var t1=&quot;2017/08/28 04:56:38&quot;; //数据 var dateBegin = new Date(t1);//转化为Date对象的形式 //Mon Aug 28 2017 04:56:38 GMT+0800 (中国标准时间) 这里就是Date对象的数据形式 时间格式这里的话就要注意一下后端给的时间数据格式的问题，比如下面两种： 第一种：&quot;2017/08/28 04:56:38&quot;//这种格式不用再进行处理 第二种：&quot;2017-08-01 18:56:38&quot;//这种格式就要进行处理 因为new Date()方法不能处理第二种数据，所以我们这里需要将第二种数据格式转化为第一种数据的格式。 var t1=&quot;2017-05-12 00:13:53&quot;; var dateBegin = new Date(d1.replace(/-/g, &quot;/&quot;));//replace方法将-转为/ 不知道大家是什么情况，反正因为我们后端给我的数据就是第二种的，所以我会提一下这个东西（捂脸）。 另一个时间数据:既然是时间差的话，就肯定要有两个数据，不然怎么两相比较，一般两个数据中都会有一个当前时间的数据。 var dateEnd = new Date();//当前时间数据 完整计算时间差(天、小时、分钟、秒)的代码：先获取之间的毫秒差，通过毫秒差换算出你所需要的时间单位，然后时间单位之间的换算根据的是他们的倍数关系。 function timeFn(d1) {//di作为一个变量传进来 //如果时间格式是正确的，那下面这一步转化时间格式就可以不用了 var dateBegin = new Date(d1.replace(/-/g, &quot;/&quot;));//将-转化为/，使用new Date var dateEnd = new Date();//获取当前时间 var dateDiff = dateEnd.getTime() - dateBegin.getTime();//时间差的毫秒数 var dayDiff = Math.floor(dateDiff / (24 * 3600 * 1000));//计算出相差天数 var leave1=dateDiff%(24*3600*1000) //计算天数后剩余的毫秒数 var hours=Math.floor(leave1/(3600*1000))//计算出小时数 //计算相差分钟数 var leave2=leave1%(3600*1000) //计算小时数后剩余的毫秒数 var minutes=Math.floor(leave2/(60*1000))//计算相差分钟数 //计算相差秒数 var leave3=leave2%(60*1000) //计算分钟数后剩余的毫秒数 var seconds=Math.round(leave3/1000) console.log(&quot; 相差 &quot;+dayDiff+&quot;天 &quot;+hours+&quot;小时 &quot;+minutes+&quot; 分钟&quot;+seconds+&quot; 秒&quot;) console.log(dateDiff+&quot;时间差的毫秒数&quot;,dayDiff+&quot;计算出相差天数&quot;,leave1+&quot;计算天数后剩余的毫秒数&quot; ,hours+&quot;计算出小时数&quot;,minutes+&quot;计算相差分钟数&quot;,seconds+&quot;计算相差秒数&quot;); } var t3=&quot;2017-08-18 04:56:38&quot;; timeFn(t3); 不成熟的计算月、年://这里的dayDiff就是上文计算出的天数差 let monthDiff=Math.floor(dayDiff/30);//以30天为一个月不够精准严谨 //获取相差的月份 if (monthDiff&lt;12){ timeThis=monthDiff+&quot;个月前发布&quot;;//获取相差的月份 return } let yearDiff=Math.floor(monthDiff/12);//获取相差的年份 if(yearDiff&gt;=1){ timeThis=yearDiff+&quot;年前发布&quot;; return } 当天数相差较大的时候，单纯计算天数已经不能满足需求了，因为我们PM说的统一以30天为一个月的分界线，然后这里月份的计算情况感觉很复杂的样子没有继续研究下去。 获取当前月份的天数 function getDays() { //构造当前日期对象 var date = new Date(); var year = date.getFullYear();//获取年份 var mouth = date.getMonth() + 1;//获取当前月份 var days;//定义当月的天数； if (mouth == 2) {//当月份为二月时，根据闰年还是非闰年判断天数 days = year % 4 == 0 ? 29 : 28; } else if (mouth == 1 || mouth == 3 || mouth == 5 || mouth == 7 || mouth == 8 || mouth == 10 || mouth == 12) { //月份为：1,3,5,7,8,10,12 时，为大月.则天数为31； days = 31; } else { //其他月份，天数为：30. days = 30; } return days; } 网上找了个获取当前月份天数的函数，上面的注释也足够全，我就一起贴上来，连接在下面。 后话上面就是本文计算时间差的内容了，希望看完本文能给大家一点帮助。最后一个提示：一般需要处理的数据不会只有一两个，很可能会给一个数组，你需要处理每个数组元素的时间数据，这时候建议用forEach()函数遍历整个数组。 最后：如需转载，请放上原文链接并署名。码字不易，感谢支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。然后就是希望看完的朋友点个喜欢，也可以关注一下我。blog网站 and 掘金个人主页 以上2017.10.15 参考资料:Js 获取当前月的天数 Js计算时间差（天、小时、分钟、秒）]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>时间差</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli npm run build空白页的两个坑 webpack gzip文件压缩优化打包文件]]></title>
    <url>%2F2017%2F10%2F11%2Fvue-cli-npm-run-build%E7%A9%BA%E7%99%BD%E9%A1%B5%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9D%91-webpack-gzip%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%E4%BC%98%E5%8C%96%E6%89%93%E5%8C%85%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[写在前面：npm run build 是vue-cli用来打包项目的命令行，本文是关于vue-cli打包的一些常见的坑，会尽量详细的写每个步骤，大家可以一边看着文章，一边打包试试。有需要的朋友可以做一下参考，喜欢的可以点波赞，或者关注一下，希望可以帮到大家。 初始化一个项目：这里初始化一个项目，因为导致打包错误的原因多种多样，避免因为其他设置错误干扰，从头开始打包整体步骤也会更加清晰。 命令行：vue init webpack build1(项目名) //吧啦吧啦进行一波设置 //进入项目文件夹 npm install 如果还不清楚如何初始化运行一个项目，可以参考我之前写的一篇文章：传送门。 开始打包踩坑命令行：//直接打包 npm run build 打包出来的文件 第一个坑：文件引用路径现在项目我们什么都没动，是初始化之后直接打包的状态，打开dist/index.htmnl文件整个网页都是一片空白的。 打开调试，发现有一排报错说是：不能加载到资源，后面就发现路径的问题，仔细看上面再看上面加载的css的引用路径，这里是有问题的。 爬坑：文件位置：config文件夹/index.js文件 1.更改assetsPublicPath属性：文件里面有两个assetsPublicPath属性，更改第一个，也就是更改build里面的assetsPublicPath属性： assetsPublicPath:&apos;/&apos;//false assetsPublicPath:&apos;./&apos;//true assetsPublicPath属性作用是指定编译发布的根目录，‘/‘指的是项目的根目录 ，’./‘指的是当前目录。 2.改好设置之后，重新打包。打开打包文件： 错误原因： 打包出来所有的文件都会放在dist的static文件夹下面，index.html要加载文件，那么问题来了，’/‘指的是项目的根目录 ，’./‘指的是当前目录。要选哪个？当然选择原谅她了。 第二个坑：路由history模式。这个坑是当你使用了路由之后，在没有后端配合的情况下就手贱打开路由history模式的时候，打包出来的文件也会是一片空白的情况，很多人踩这个坑的时候花了很多时间，网上的教程基本上都是说的第一个坑，这个坑很少有人提起。 打包之前的样子：这里我弄了个示例，因为是刚创建的项目没有其他因素干扰，当你打开路由的history模式之后，开发的时候一切正常 打包之后的样子： 解决方式：// mode: &apos;history&apos;,//将这个模式关闭就好 这里并不是说不能打开这个模式，这个模式需要后端设置的配合，详情可以看：路由文档 Gzip 文件压缩顺带分享一个很6的优化打包的方法，用起来也简单的很，只要下载一个插件，然后打开一个设置就好了。 设置方法： 这里其实是webpack自带的一个优化打包的方法，打开这个配置后如果没有下载那个插件，会提示你下载，下载就好了。 然后在打包的时候，每个js和css文件会压缩一个gz后缀的文件夹，浏览器如果支持g-zip 会自动查找有没有gz文件 找到了就加载gz然后本地解压 执行。 打开这个配置会之后对整体的打包体积也就是dist文件夹并没有太大的变化。下图来看看他的压缩率以及对加载的提升，可以说是非常大且明显的，大家可以自己试一下就知道多好用了。 后话之前自己打包的时候连着踩了不少坑，可能是互相关联的，有时候你并不是错了一个地方，要想想自己其他地方是不是也是错的。上述的内容，算是自己踩坑的一些经验，希望可以帮到大家。 最后：如需转载，请放上原文链接并署名。码字不易，感谢支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。然后就是希望看完的朋友点个喜欢，也可以关注一下我。掘金个人主页 以上2017.10.10]]></content>
      <categories>
        <category>vue-cli</category>
      </categories>
      <tags>
        <tag>build空白页</tag>
        <tag>gzip文件压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli 自定义路径别名 assets和static文件夹的区别 --save-dev和--save的区别]]></title>
    <url>%2F2017%2F10%2F11%2Fvue-cli-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E5%BE%84%E5%88%AB%E5%90%8D-assets%E5%92%8Cstatic%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E5%8C%BA%E5%88%AB-save-dev%E5%92%8C-save%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[写在前面：这是一篇vue-cli的几个小知识点简单介绍，适用于刚接触vue-cli脚手架以及对此方面并不太了解的同学，大佬们绕道。有需要的朋友可以做一下参考，喜欢的可以点波赞，或者关注一下，希望可以帮到大家。 静态资源处理：assets和static文件夹的区别相信有很多人知道vue-cli有两个放置静态资源的地方，分别是src/assets文件夹和static文件夹,这两者的区别很多人可能不太清楚。 assets目录中的文件会被webpack处理解析为模块依赖，只支持相对路径形式。例如，在 &lt;img src=&quot;./logo.png&quot;&gt;和 background: url(./logo.png)中，”./logo.png” 是相对的资源路径，将由Webpack解析为模块依赖。 static/ 目录下的文件并不会被Webpack处理：它们会直接被复制到最终的打包目录（默认是dist/static）下。必须使用绝对路径引用这些文件，这是通过在 config.js 文件中的 build.assetsPublicPath 和 build.assetsSubDirectory 连接来确定的。 任何放在 static/ 中文件需要以绝对路径的形式引用：/static/[filename]。 在我们实际的开发中，总的来说：static放不会变动的文件 assets放可能会变动的文件。 在js数据中如何引用图片因为webpack会将图片当做模块来引用，所以在js中需要使用require将图片引用进来，不能直接以字符串的形式。 js部分： data () { return { imgUrl: &apos;图片地址&apos;,//错误写法 imgUrl: require(&apos;图片地址&apos;)//正确的写法 } } template部分： img标签形式： &lt;img :src=&quot;img&quot; /&gt; 或者div背景图形式： &lt;div :style=&quot;{backgroundImage: &apos;url(&apos; + img + &apos;)&apos;}&quot;&gt;&lt;/div&gt; 说了图片就正好再提一下vue-cli的一个图片有关的配置，下图这个配置的意思是：在10000b 的图片以下进行base64转换，所以如果项目中有些比较小的icon就不用再进行图片精灵的处理了 webpack+vue自定义路径别名vue-cli 用的是webpack，也可以使用webpack自定义别名这个功能，自定义别名这个功能当你在多层文件夹嵌套的时候不必一层一层找路径，直接使用自定义别名就可以找到文件的位置。 设置方法：设置地址：build文件夹下面的webpack.base.conf.js文件具体设置： resolve: { extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;], alias: { &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;, &apos;@&apos;: resolve(&apos;src&apos;), &apos;static&apos;:path.resolve(__dirname, &apos;../static&apos;),//增加这一行代码 } }, 使用方式： 使用的时候要像下方截图的B处一样前面要加上一个’~’，这里的webstorm虽然提示报错，我们可以不用管，代码运行是正常的。 解读： 这里给’static’赋予了一个地址，那么在程序中引入路径的时候’~static’就直接可以代替路径’../static’，亲测，这里就算多层嵌套也可以成功找到路径。 清理项目中没用的插件很多人像我一样，刚开始的会安装很多插件，然后最后在项目中并没有用到。那之前安装的插件太多了，连自己都忘记了安装了哪些插件？ package.json 在上图所示位置，我们项目安装的所有的模块依赖都在这个pageage.json文件中，当我们需要整理一波自己的依赖的时候，可以在这个文件里面找有没有现在已经没用的依赖，可以使用命令行npm remove 模块名字来删除没用的模块。 –save-dev和–save的区别上面的这些依赖有些只在开发环境里面使用的模块，有的在项目上线之后还是要继续依赖的模块。他们之间的区别就在于我们平时安装模块依赖时的：--save-dev和 --save 当你使用--save-dev安装依赖的时候就会放在package.json的devDependencies对象下面，相反的，当你使用--save安装依赖的时候就会出现在dependencies对象下面。 总结： –save-dev 是你开发时候依赖的东西，–save 是你发布之后还依赖的东西。 关于vue-cli配置之前也写过两篇文章，需要的同学可以看一下：手摸手教你使用vue-cli脚手架 在 vue-cli 脚手架中引用 jQuery、bootstrap 以及使用 sass、less 编写 css 后话以上就是这篇文章的内容了，是自己一段时间实践项目的一些小积累，后续还有一些内容，因为项目比较紧，可能会晚点和大家见面。 最后：如需转载，请放上原文链接并署名。码字不易，感谢支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。然后就是希望看完的朋友点个喜欢，也可以关注一下我。掘金个人主页 以上2017.9.18]]></content>
      <categories>
        <category>vue-cli</category>
      </categories>
      <tags>
        <tag>vue-cli解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 vue-cli 脚手架中引用 jQuery、bootstrap 以及使用 sass、less 编写 css [vue-cli配置入门]]]></title>
    <url>%2F2017%2F10%2F11%2F%E5%9C%A8-vue-cli-%E8%84%9A%E6%89%8B%E6%9E%B6%E4%B8%AD%E5%BC%95%E7%94%A8-jQuery%E3%80%81bootstrap-%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8-sass%E3%80%81less-%E7%BC%96%E5%86%99-css-vue-cli%E9%85%8D%E7%BD%AE%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[写在前面：本文是vue-手摸手教你使用vue-cli脚手架-详细步骤图文解析之后，又一篇关于vue-cli脚手架配置相关的文章，因为有些文章步骤不够清晰，当时我引入JQuery、bootstrap的时候颇费了一番功夫，所以本文的步骤会尽量详细一点。有需要的朋友可以做一下参考，喜欢的可以点波赞，或者关注一下，希望可以帮到大家。 引入bootstrap1. 下载所需要的bootstrap文件。将要使用的bootstrap文件放入src目录下的assets文件夹中。 2. 在入口文件src/main.js中引入bootstrapimport &apos;./assets/bootstrap-3.3.7-dist/css/bootstrap.min.css&apos; import &apos;./assets/bootstrap-3.3.7-dist/js/bootstrap.min&apos;//根据自己文件夹路径选择路径 这样就可以在vue项目中使用bootstrap的样式了，直接在class中使用即可，如下图按钮样式。 引入jquery1. 下载jquery依赖。npm install jquery --save 本来我下载的jQuery依赖包，但是出现了一个警告：这里出现了一个警告，意思是说弃用jQuery@1.7.4,请使用“jquery”(全小写)。，然后我就换成全小写的jquery。 2. 修改配置 位置：build文件夹下的webpack.base.conf.js文件。 加入webpack对象：var webpack = require(&quot;webpack&quot;); 位置：build文件夹下的webpack.base.conf.js文件（原来的位置），在下方module.exports对象里面加入。 plugins: [// 3. 配置全局使用 jquery new webpack.ProvidePlugin({ $: &quot;jquery&quot;, jQuery: &quot;jquery&quot;, jquery: &quot;jquery&quot;, &quot;window.jQuery&quot;: &quot;jquery&quot; })], 没有第三步，现在已经可以直接在组件中使用jquery的方法了，不用在其他位置引用jquery，就是这么轻松加愉快。 3. 使用JQ插件关于这一点查阅了很多资料，几乎没什么文献清楚的说明jq插件的使用方式，以至于很多使用vue很久的大佬们，也不知道jq的插件竟然可以直接在vue-cli中使用。。这一步虽然是简单的，但这里还是提一下，为各位提供一些参考。 使用方式：jq插件只需要将插件所需要的文件下载到本地src/assets或者最外层的static文件夹中，然后将插件的文件引用进组件，根据插件封装的方法来进行调用就行了，跟直接使用jq的插件基本上是一毛一样的。 下面是一个引用jq插件的demo示例： 关于css的部分在vue-cli中使用sass、less来编写css样式，步骤十分简洁，因为vue-cli已经配置好了sass、less，我们要使用sass或者less直接下载两个模块，然后webpack会根据 lang 属性自动用适当的加载器去处理。 css 直接上手写样式即可，使用css规则。 引用外部css文件的写法。&lt;style lang=&quot;css&quot;&gt; @import &apos;./index.css&apos; &lt;/style&gt; 或者 &lt;style lang=&quot;css&quot; src=&quot;./index.css&quot;&gt;&lt;/style&gt; 如果需要使用sass 安装sass模块npm install node-sass --save-dev npm install sass-loader --save-dev 在组件的style部分使用内联写法&lt;template&gt;&lt;/template&gt; &lt;script&gt;&lt;/script&gt; &lt;style lang=&quot;scss&quot; scoped&gt;//在这个部分添加lang=&quot;scss&quot; //sass样式 &lt;/style&gt; 引用sass外部文件的写法。&lt;style lang=&quot;scss&quot; src=&quot;./index.scss&quot;&gt;&lt;/style&gt; 如果需要使用less 安装less模块npm install less --save-dev npm install less-loader --save-dev 在组件的style部分使用内联写法&lt;template&gt;&lt;/template&gt; &lt;script&gt;&lt;/script&gt; &lt;style lang=&quot;less&quot; scoped&gt;//在这个部分添加lang=&quot;less&quot; //less样式 &lt;/style&gt; 引用less外部文件的写法。&lt;style lang=&quot;less&quot; src=&quot;./index.less&quot;&gt;&lt;/style&gt; 结语：仔细阅读，按步骤来基本上可以配置成功。如果有哪个地方写的不够清楚的，欢迎指正。本文面向小白，写着玩，大手请轻喷。 最后：如需转载，请放上原文链接并署名。码字不易，感谢支持！写文偏小白，写的不好之处，欢迎指点。然后就是希望看完的朋友点个喜欢，也可以关注一下我。掘金个人主页 参考资料： vue-cli快速构建项目以及引入bootstrap、jqvue中引入jQuery和BootstrapVue-cli单文件组件引入less、sass、css样式的不同方法 以上2017.8.10]]></content>
      <categories>
        <category>vue-cli</category>
      </categories>
      <tags>
        <tag>vue-cli配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手摸手教你使用vue-cli脚手架-详细步骤图文解析[vue入门]]]></title>
    <url>%2F2017%2F10%2F11%2F%E6%89%8B%E6%91%B8%E6%89%8B%E6%95%99%E4%BD%A0%E4%BD%BF%E7%94%A8vue-cli%E8%84%9A%E6%89%8B%E6%9E%B6-%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4%E5%9B%BE%E6%96%87%E8%A7%A3%E6%9E%90-vue%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[写在前面：使用 vue-cli 可以快速创建 vue 项目，vue-cli很好用，但是在最初搭建环境安装vue-cli及相关内容的时候，对一些人来说是很头疼的一件事情，本人在搭建vue-cli的项目环境的时候也是踩了相当多的坑，特此写了一篇搭建环境的教程，每一步尽量详细解析。需要的朋友可以过来参考下，喜欢的可以点波赞，或者关注一下本人，希望可以帮到大家。 vue-cli脚手架的优势： 有一套成熟的vue项目架构设计,能够快速初始化一个Vue项目. vue-cli是官方支持的一个脚手架，会随本版本进行迭代更新。 vue-cli提供了一套本地的node测试服务器，使用vue-cli自己提供的命令，就可以启动服务器。 集成打包上线方案。 还有一些优点，包括：模块化，转译，预处理，热加载，静态检测和自动化测试等，等大家深入使用下去就会发现vue-cli的强大之处。 本教程是基于windows系统。下面正式开始搭建vue-cli脚手架。 命令行工具命令行工具是我们操作npm的基础，这个必须要有的，很多教程没有写清楚，那些教程一上来就贴上一大堆命令，当初也不知道在哪里使用命令行工具。。。 git bash命令行工具 windows下本人推荐使用GitHub的桌面管理工具自带的git bash命令行工具，正常下载安装就可以。 下载地址，下图是下载安装完成之后，git bash的使用方法。 ps:当然如果想使用自带的终端cmd命令行工具也是可以，但是毕竟没有git bash来的好用方便。 安装node.js 在node.js中文官网正常下载安装node.js就可以，没有什么特别需要注意的点（傻瓜式安装）。 在官网下载安装node.js后，就已经自带npm（包管理工具），不需要另外再进行安装npm了。 注意下载node.js版本要在4.0以上，避免版本过低影响使用。 打开命令行工具（随便哪个文件夹），输入命令行 node -v，npm -v，如下图，如果出现相应的版本号，则说明安装成功。 安装淘宝镜像cnpm（淘宝镜像）相关： 这是一个完整 npmjs.org 镜像，是用来同步npm上面的模块。 cnpm的同步频率为 10分钟 （新发布的模块有滞后性，同步是需要时间的，等不及的可以使用npm）。 安装cnpm的原因：npm的服务器是外国的，所以有时候我们安装“模块”会很很慢很慢超级慢。 cnpm的作用：淘宝镜像将npm上面的模块同步到国内服务器，提高我们安装模块的时间。 安装完淘宝镜像之后，cnpm和npm命令行皆可使用，二者并不冲突 安装方法：打开命令行工具，输入命令行： $ npm install -g cnpm --registry=https://registry.npm.taobao.org cnpm使用方法: $ cnpm install [name] 安装模块的时候，将npm换成cnpm就行，国内很多coder都是使用cnpm的，个人建议大家都装一下，附上：淘宝镜像网址、 安装webpack安装方法：打开命令行工具，输入命令行： npm install webpack -g 安装成功后输入webpack -v,如果出现相应的版本号，则说明安装成功。 安装vue-cli脚手架构建工具安装方法：全局安装，随便一个文件夹，输入命令行： npm install vue-cli -g 安装完成之后，输入命令行vue -V查看版本号，出现相应得到版本号即为成功： 注：这里是大写的V通过vue-cli，初始化vue项目通过以上几步，将我们安装脚手架所需要的环境和工具都准备好好了，下面就可以使用vue-cli来初始化项目。 1。新建一个vuetext（项目名）文件夹来放置项目，在新建文件夹的上一级文件夹右键打开命令行工具，输入命令行： vue init webpack vuetext1(项目名) 注：项目名不能大写，不能使用中文解释一下这个命令，这个命令的意思是初始化一个vue项目，其中webpack是构建工具，也就是整个项目是基于webpack的。其中vuetext1是整个项目文件夹的名称，这个文件夹会自动生成在你指定的目录中。 2。以下是脚手架安装过程（安装步骤解析在图片下面） vue-cli初始化项目选项配置详细解析$ vue init webpack vuetext1--------------------- 安装vue-cli,初始化vue项目的命令 ? Target directory exists. Continue? (Y/n) y---------------------找到了vuetext1这个目录是否要继续 ? Target directory exists. Continue? Yes ? Project name (vuetext1)---------------------项目的名称（默认是文件夹的名称），ps：项目的名称不能有大写，不能有中文，否则会报错 ? Project name vuetext1 ? Project description (A Vue.js project)---------------------项目描述，可以自己写 ? Project description A Vue.js project ? Author (OBKoro1)---------------------项目创建者 ? Author OBKoro1 ? Vue build (Use arrow keys)--------------------选择打包方式，有两种方式（runtime和standalone），使用默认即可 ? Vue build standalone ? Install vue-router? (Y/n) y--------------------是否安装路由，一般都要安装 ? Install vue-router? Yes ? Use ESLint to lint your code? (Y/n) n---------------------是否启用eslint检测规则，这里个人建议选no，因为经常会各种代码报错，新手还是不安装好 ? Use ESLint to lint your code? No ? Setup unit tests with Karma + Mocha? (Y/n)--------------------是否安装单元测试 ? Setup unit tests with Karma + Mocha? Yes ? Setup e2e tests with Nightwatch? (Y/n) y)--------------------是否安装e2e测试 ? Setup e2e tests with Nightwatch? Yes vue-cli · Generated &quot;vuetext1&quot;. To get started:)--------------------如何开始 cd vuetext1)--------------------进入你安装的项目 npm install)--------------------安装项目依赖 npm run dev)--------------------运行项目 Documentation can be found at https://vuejs-templates.github.io/webpack)--------------------vue-cli官方文档 现在vuetext1项目已经初步初始化完成了，里面也有一些文件，但是现在还不能成功运行。 3.如何运行项目 进入你刚才创建在vuetext1项目的文件夹里面，在vuetext1项目的文件夹里面右键运行git bash 命令行工具。 安装项目依赖。命令行： npm install。前面在项目初始化的时候，已经存在了package.json文件，直接使用npm install 安装项目所需要的依赖，否则项目不能正确运行。 创建完成的“vuetext1”目录如下： 到这里，我们已经成功使用vue-cli初始化了一个vue项目。 启动项目：在vuetext1目录运行命令行npm run dev，启动服务，服务启动成功后浏览器会默认打开一个“欢迎页面”，如下图。 注意：这里是默认服务启动的是本地的8080端口，所以请确保你的8080端口不被别的程序所占用，当有其他vue项目运行的时候，可以使用ctrl+c来中断运行。 vue-cli配置相关:这是我写的另外一篇关于vue-cli配置相关的文章，有需要的朋友可以参考一下。在vue-cli脚手架中引用JQuery、bootstrap以及使用sass、less编写css[vue-cli配置入门] 结语：本文关于如何搭建vue-cli脚手架已经尽量详细了，仔细阅读，按步骤来基本上可以成功。如果有哪个地方写的不够清楚的，欢迎指正。本文面向小白，写着玩，大手请轻喷。 最后：如需转载，请放上原文链接并署名。码字不易，感谢支持！写文偏小白，写的不好之处，欢迎指点。然后就是希望看完的朋友点个喜欢，也可以关注一下我。掘金个人主页]]></content>
      <categories>
        <category>vue-cli</category>
      </categories>
      <tags>
        <tag>初始化vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular ui-router：简单的单页面嵌套路由的实现过程]]></title>
    <url>%2F2017%2F10%2F11%2Fangular-ui-router%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9A%84%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[写在前面：ui-router是angular的一个插件，因为angular前面几个版本自带的原生ng-router不能很好的满足开发需求，所以在实现angular单页面嵌套的时候，都是使用ui-router。本文是的内容关于angular ui-router实现过程，内含demo以及代码地址，需要的朋友可以过来参考下，喜欢的可以点波赞，或者关注一下本人，ui-router的实现过程并不复杂，希望通过本文大家能够学会ui-router的使用方法。 ui-router与ng-router：UI-Router是angular原生ng-route进化版，相较与ng-router有如下两条优点： 视图不能嵌套,这意味着$scope会发生不必要的重新载入。 同一URL下不支持多个视图。这一需求也是常见的：我们希望导航栏用一个视图（和相应的控制器）、内容部分用另一个视图（和相应的控制器）。 最终实现demo效果 AngularJS单页面实现原理：AngularJS 路由允许我们通过不同的 URL 访问不同的内容，通常我们的URL形式为http://runoob.com/first/page ，在单页Web应用中 AngularJS 通过 # + 标记 实现，例如： 123http://runoob.com/#/firsthttp://runoob.com/#/secondhttp://runoob.com/#/third 当我们访问这上面任意一个链接的时候，向服务端请求的都是同一个地址： http://runoob.com/ #号之后的内容在向服务端请求时会被浏览器忽略掉 路由就通过 # + 标记帮助我们区分不同的逻辑页面并将不同的页面绑定到对应的控制器上，如下图所示： demo地址 ui-router实现过程 1、创建页面：要实现上文那个demo效果，我们需要创建如下页面： app.js 这是路由的配置页面 index.html 通常叫做index.html是单页面的首页，里面导入了各种css样式、库，插件，框架之类的。 PageTab.html 进入index.html首先展示的视图页面，下面几个是PageTab下面的嵌套页面 Page-1.html Page-2.html Page-3.html 代码上传到github上面了，需要的朋友可以自行查看： 代码地址 注：angular用的是：1.4.6，ui-router用的是1.0 ps：现在angular4，自带的原生ng-router好像也已经支持了多层嵌套。但是因为还没流传开，市面上，大多还是1.4，所以还是需要用到ui-router。 2、在index.html里面导入js文件123&lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.bootcss.com/angular-ui-router/1.0.0-rc.1/angular-ui-router.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;App.js&quot;&gt;&lt;/script&gt; 1.angular文件，2.ui-router插件,3.路由js页面 注意：angular文件必须在ui-router前面，因为ui-router是依赖angular的插件。这几个文件是最基本的页面，如果是一个完整的angular单页面项目的话，index,html是这幅样子： 在单页面中，不管你从哪个视图查看网页代码，都是这样子，第一次看的都醉了！ 3.app.jsapp.js声明了AngularJS模块和路由配置。当页面加载的时候我们会在index.html中显示PageTab.html的内容。具体代码如下，每一个关键的地方都有相应的注释注释注释：12345678910111213141516171819202122232425var myApp = angular.module(&quot;myApp&quot;, [&quot;ui.router&quot;]);//这里叫做App模块，这将告诉HTML页面这是一个AngularJS作用的页面，并把ui-router注入AngularJS主模块，它的内容由AngularJS引擎来解释。myApp.config(function ($stateProvider, $urlRouterProvider) &#123; //这一行声明了把 $stateProvider 和 $urlRouteProvider 路由引擎作为函数参数传入，这样我们就可以为这个应用程序配置路由了. $urlRouterProvider.when(&quot;&quot;, &quot;/PageTab&quot;); //如果没有路由引擎能匹配当前的导航状态，默认将路径路由至 PageTab.html, 那它就像switch case语句中的default选项.就是一个默认的视图选项 $stateProvider //这一行定义了会在main.html页面第一个显示出来的状态（就是进入页面先加载的html），作为页面被加载好以后第一个被使用的路由. .state(&quot;PageTab&quot;, &#123;//导航用的名字 url: &quot;/PageTab&quot;,//#+标识符，这里就是url地址栏上面的标识符，通过标识符，进入不同的html页面 templateUrl: &quot;PageTab.html&quot;//这里是html的路径，这是跟标识符相对应的html页面 &#125;) .state(&quot;PageTab.Page1&quot;, &#123;//引号里面代表Page1是PageTab的子页面，用.隔开 url:&quot;/Page1&quot;, templateUrl: &quot;Page-1.html&quot; &#125;) .state(&quot;PageTab.Page2&quot;, &#123;//需要跳转页面的时候，就是用这双引号里面的地址 url:&quot;/Page2&quot;, templateUrl: &quot;Page-2.html&quot; &#125;) .state(&quot;PageTab.Page3&quot;, &#123; url:&quot;/Page3&quot;, templateUrl: &quot;Page3.html&quot; &#125;);&#125;); 现在已经成功把appjs实现出来，然后需要在html里面定义视图，以及视图跳转链接 4.html定义视图现在要把我们写好的html视图页面在页面中展示出来，我们来看看index.html里面的代码：123456&lt;body data-ng-app=&quot;myApp&quot;&gt;&lt;!--ui-router的html代码--&gt;&lt;div data-ui-view=&quot;&quot;&gt;&lt;/div&gt;&lt;!--这里要引入上面说的文件--&gt;&lt;/body&gt;&lt;html&gt; 在ui-view=””的双引号里面，ui-view展示的页面是根据app.js设置的url对应的html来展示的。嵌套页面跳转： 导航里面的名字必须是“父页面的名字.子页面的名字”比如： 12345678.state(&quot;PageTab&quot;, &#123;//这里是名字 url: &quot;/PageTab&quot;, templateUrl: &quot;PageTab.html&quot; &#125;) .state(&quot;PageTab.Page1&quot;, &#123;//意思是PageTab视图下面的Page1视图 url:&quot;/Page1&quot;, templateUrl: &quot;Page-1.html&quot; &#125;) 在html里面，用ui-sref进行跳转 demo代码栗子： 1234567891011&lt;div&gt; &lt;h1&gt;下面这几个按钮是在主页面下面再嵌套一层的页面&lt;/h1&gt; &lt;!--ui-sref跳转--&gt; &lt;span style=&quot;width:100px&quot; ui-sref=&quot;.Page1&quot;&gt;&lt;a href=&quot;&quot;&gt;Page-1&lt;/a&gt;&lt;/span&gt; &lt;span style=&quot;width:100px&quot; ui-sref=&quot;.Page2&quot;&gt;&lt;a href=&quot;&quot;&gt;Page-2&lt;/a&gt;&lt;/span&gt; &lt;span style=&quot;width:100px&quot; ui-sref=&quot;.Page3&quot;&gt;&lt;a href=&quot;&quot;&gt;Page-3&lt;/a&gt;&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;!--PageTap嵌套的视图html展示的地方--&gt; &lt;div ui-view=&quot;&quot;/&gt; &lt;/div&gt; 如果觉得不太明白可以点击下面的代码地址，将代码复制到本地，自己多试一试，应该就明白了：demo地址、demo代码地址 写在后面：现在只是一个最简单的使用方式，本来想在写一些深一点的使用方式（内容：路由的其他参数、路由懒加载引用文件、路由视图页面传递参数），写了好久，结果发现还是需要demo结合起来写，比较清楚，等我写好了在下面加个链接。 最后：如需转载，请放上原文链接并署名。码字不易，感谢支持！因为我经常看不懂别人写的分享，所以个人写文比较偏小白，写的不好之处，欢迎指点。然后就是希望看完的朋友点个喜欢，也可以关注一下我。ps：目前待业，城市：杭州/北京（纠结中），本人适应互联网快节奏，高强度的工作状态，认真，严谨，学习积极性强。中小公司大佬求带走，邮箱：obkoro1@foxmail.com。掘金个人主页 参考资料：AngularJS 路由,菜鸟教程深究AngularJS——ui-router详解\AngularJS ui-router (嵌套路由)]]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>angular ui-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小白来实现一个Ajax请求[Ajax使用方法及相关知识点详细解析——超级全]]]></title>
    <url>%2F2017%2F10%2F11%2F%E5%B0%8F%E7%99%BD%E6%9D%A5%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAAjax%E8%AF%B7%E6%B1%82-Ajax%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E8%B6%85%E7%BA%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[写在前面：本文主要总结整理Ajax使用方法背景知识点的详细解析，以及Ajax跨域的具体使用方式并且对栗子进行了讲解，需要的朋友可以过来参考下，喜欢的可以点波赞，或者关注一下本人，希望通过本文能够作为一个Ajax的查找资料，不懂Ajax？看这篇文章就可以了。 ajax简介： Ajax 的全称是Asynchronous JavaScript and XML，意思是：异步 JavaScript 和 XML Ajax是使用XMLHttpRequest对象与服务器端通信的脚本语言 可以发送及接收各种格式的信息，包括JSON、XML、HTML和文本文件。 AJAX可以无需刷新页面而与服务器端进行通信。 允许你根据用户事件来更新部分页面内容。 Ajax工作原理：Ajax的工作原理相当于在用户和服务器之间加了一个中间层(Ajax引擎),使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器,像—些数据验证(比如判断用户是否输入了数据)和数据处理(比如判断用户输入数据是否是数字)等都交给Ajax引擎自己来做, 只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。把这些交给了Ajax引擎，用户操作起来也就感觉更加流畅了。 Ajax的优点： 页面无刷新，用户体验好。 AJAX最大优点就是能在不刷新整个页面的前提下与服务器通信维护数据。这使得Web应用程序更为迅捷地响应用户交互，并避免了在网络上发送那些没有改变的信息，减少用户等待时间，带来非常好的用户体验。 异步通信，更加快的响应能力。 AJAX使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。优化了Browser和Server之间的沟通，减少不必要的数据传输、时间及降低网络上数据流量。 减少冗余请求，减轻了服务器负担 AJAX的原则是“按需取数据”，可以最大程度的减少冗余请求和响应对服务器造成的负担，提升站点性能。 基于标准化的并被广泛支持的技术，不需要下载插件或者小程序 AJAX基于标准化的并被广泛支持的技术，不需要下载浏览器插件或者小程序，但需要客户允许JavaScript在浏览器上执行。 界面与应用分离。 Ajax使WEB中的界面与应用分离（也可以说是数据与呈现分离），有利于分工合作、减少非技术人员对页面的修改造成的WEB应用程序错误、提高效率、也更加适用于现在的发布系统。 Ajax应用场景： 数据验证。用户的注册，登录功能，通过与后台交互数据，进行数据验证 按需取数据。按照需求，展示所需要的部分数据，而不是一股脑的将整个网页全都展示出来。 自动更新页面。栗子：百度搜索的提示,出现联想提示语，展示用户最有可能搜索的词汇。 自动更新页面。栗子：在线聊天室，设置一个定时器，每隔几秒向请求数据，实时更新页面信息。 同步执行和异步执行。javascript同步表示sync，指的就是：代码依次执行。javascript 异步表示async，指：代码执行不按顺序，可以这么理解：同步是在一条直线上的队列，异步不在一个队列上 各走各的。javascript所谓的“线程”，就是这样的一种概念。 虽然异步执行可以实现多任务并行执行，使执行的效率大大提高，但是异步执行也会占用浏览器的性能，不要胡乱的使用异步执行。 举个栗子：在负荷很重的客户/服务器系 统中，时间延迟频繁且漫长，在这种环境下就比较适宜宜采用异步执行模式。 关于同步和异步，大概只能说这些，有兴趣的朋友可以自己深入了解一下。 开始一个Ajax请求需要了解的背景知识：XMLHttpRequest对象:Ajax的核心是XMLHttpRequest对象，它是Ajax实现的关键，发送异步请求、接受响应以及执行回调都是通过它来完成，下面我们就来聊一聊XMLHttpRequest对象是什么鬼？拥有哪些属性、方法，这些都是用来干什么的，这对于我们系统性的了解Ajax请求是非常有帮助的。 XMLHttpRequest对象的属性： XMLHttpRequest对象的方法： 图片出处 XMLHttpRequest虽然目前还没有被W3C所采纳，但是它已经是一个事实的标准，因为所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均支持 XMLHttpRequest 对象。，XMLHttpRequest对象的使用方式极其简单，先不要懵逼。继续往下看。 Ajax的跨域请求由哪些部分组成的 HTTP请求的方法或动作，Ajax请求方式 (“POST” 或 “GET”)， 默认为 “GET”。注意：其它 HTTP 请求方法，如 PUT 和 DELETE 也可以使用，但仅部分浏览器支持。 你需要请求的URL,总得告诉服务器请求的地址是什么吧? 请求头,包含一些客户端环境信息,身份验证信息等 请求体,也就是请求正文,请求正文中可以包含客户端提交的查询字符串信息,表单信息等等. GET和POST两种请求方式对比： 在前后端分离的情况下，对于前端的小伙伴来说，一般是后端选择请求接口，请求方式，让我们去使用，所以请求方式的选择这点，稍微了解一下即可。 Ajax的跨域请的回复：http响应： 一个数字和文字组成的状态码,用来显示请求是成功还是失败 响应头,响应头和请求头一样包含许多有用的信息,例如服务器类型,日期时间,内容类型和长度等. 响应体,也就是响应正文. 服务器端返回的：常见的HTTP状态码 关于http的状态码还有非常多，不止上图这点这么简单，有兴趣的可以看本人之前写的一篇文章：http状态码详解。 如何使用Ajax本文中的栗子采用菜鸟教程ajax的栗子：ajax实例实现Ajax的四个步骤： 新建一个XMLHttpRequest对象。 open方法表示初始化请求，此时并没有发送。 定义数据返回后的回调函数，里面的代码在readystatechange值改变的时候执行。 发送请求。 使用Ajax的一个栗子，里面注释的也较为详细：1234567891011121314151617181920212223242526function loadXMLDoc()&#123;//点击事件 var xmlhttp; if (window.XMLHttpRequest) &#123; // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 xmlhttp=new XMLHttpRequest(); &#125; else &#123; // IE6, IE5 浏览器执行代码 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; //1、上面是创建XMLHttpRequest对象 xmlhttp.open(&quot;POST&quot;,&quot;/try/Ajax/demo_post2.php&quot;,true);// 2、open方法表示初始化请求，此时并没有发送。 xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); xmlhttp.send(&quot;fname=Henry&amp;lname=Ford&quot;);//4、发送请求 xmlhttp.onreadystatechange=function(); &#123;//3、当参数被传入服务器的时候，引用监听事件。 if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) //判断readyState四种状态，当执行四步完成之后，并且返回的是200（成功） &#123; document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText; &#125; &#125;&#125; 1、新建一个XMLHttpRequest对象：XMLHttpRequest对象在上文介绍了他的属性和方法，如上所述， Ajax的核心是XMLHttpRequest对象，这一步是必不可少的，下面就是它的使用语法。 1var xmlhttp = new XMLHttpRequest();//没看错，就是这么简单 Ajax兼容IE7以下：XMLHttpRequest对象是IE7才开始支持的，老版本IE5和IE6使用的是ActiveX 对象，使用方式是一样的，区别在于要创建不同的对象。IE7以上自带XMLHttpRequest对象，如果要兼容IE5和IE6只需判断浏览器中是否存在XMLHttpRequest对象。 1234567891011var xmlhttp; if (window.XMLHttpRequest)//检查是否有XMLHttpRequest对象 &#123; // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 xmlhttp=new XMLHttpRequest(); &#125; else &#123; // IE6, IE5 浏览器执行代码 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; 2、open方法表示初始化请求，此时并没有发送。open方法的语法open(method,url,async) 参数一：method——请求方式，get或者post。（默认为get） 参数二：url——请求路径,文件在服务器上的位置 参数三：async——true：异步请求。false:同步请求。（默认为true，异步请求。） 3.定义数据返回后的回调函数，里面的代码在readystatechange值改变的时候执行。触发Ajax的时候，XMLHttpRequest 的状态会不断变化，这个值就存在readyState属性中。 readyState属性：readyState只有5个值{0，1，2，3，4}，只读不能写。 0: XMLHttpRequest对象创建完成。————还没有调用open()方法 1: XMLHttpRequest对象初始化完成。————open() 方法已调用，但是 send()方法未调用。请求还没有被发送。 2: 请求已经发送。———Send() 方法已调用，HTTP 请求已发送到 Web 服务器。未接收到响应。 3: 服务器已经返回了数据（但是还没有被解析，可能只一段http报文）。————正在解析响应内容 4: 数据解析已经完成。————响应内容解析完成,可以在客户端调用了 数据解析完成之后会返回一个http的状态码，通过XMLHttpRequest.status获得该值，判断是否为200，判断是否请求成功。 onreadystatechange事件：每当readyState属性值改变时，就会触发 onreadystatechange 事件。——通过监听onreadystatechange事件,来判断请求的状态。 4、发送请求 send（）方法必须在open（）之后。 在使用GET方式请求时无需填写参数 在使用POST方式时需要使用setRequestHeader()来添加http头，然后在 send() 方法中规定您希望发送的数据 get:12xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/ajax_info.txt&quot;,true); xmlhttp.send(); post：123xmlhttp.open(&quot;POST&quot;,&quot;/try/ajax/demo_post2.php&quot;,true);xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);xmlhttp.send(&quot;fname=Henry&amp;lname=Ford&quot;); 菜鸟教程的栗子：get方式、post方式 写在后面：想到当初自己不会Ajax的时候，畏Ajax如洪水猛兽，希望小伙伴们，看了本文就能写出自己的第一个Ajax来，这也是我想写这篇文章的意义所在。十多天没写文了，这篇文章也准备了好几天，写的不好之后，欢迎指正，谢谢。 最后：如需转载，请放上原文链接并署名。码字不易，感谢支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。然后就是希望看完的朋友点个喜欢，也可以关注一下我。个人blog and 掘金个人主页 参考资料： Ajax与数据传输 Ajax入门（一）从0开始到一次成功的GET请求 Ajax 总结篇 菜鸟教程——AJAX 教程 以上。2017.6.1]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>小白实现ajax请求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js定时器用法详解——setTimeout()、setInterval()、clearTimeout()、clearInterval()]]></title>
    <url>%2F2017%2F10%2F11%2Fjs%E5%AE%9A%E6%97%B6%E5%99%A8%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3%E2%80%94%E2%80%94setTimeout-%E3%80%81setInterval-%E3%80%81clearTimeout-%E3%80%81clearInterval%2F</url>
    <content type="text"><![CDATA[写在前面：在js应用中，定时器的作用就是可以设定当到达一个时间来执行一个函数，或者每隔几秒重复执行某段函数。这里面涉及到了三个函数方法：setInterval()、setTimeout()、clearInterval()，本文将围绕这三种函数的用法，来实现定时器的功能，需要的朋友可以过来参考下，喜欢的可以点波赞，或者关注一下本人，希望对大家有所帮助。 定时器的应用需求：1.设定一个时间，当时间到达的时候执行函数————比如：倒计时跳转页面等等。 2.每隔一段时间重复执行某段函数————比如抢票软件，比如设定500毫秒就重复刷新一次页面等等。 倒计时跳转实现demo： js定时器：菜鸟教程中是这么说的——js 定时器有以下两个方法： setTimeout() ：在指定的毫秒数后调用函数或计算表达式。 setInterval() ：按照指定的周期（以毫秒计）来调用函数或计算表达式。方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。 使用语法：setTimeout（）：setTimeout(code,millisec) setInterval（）：setInterval(code,millisec[,”lang”]) 参数：code————要进行调用的函数或者要执行的代码串。millisec————时间（默认毫秒来计算），lang————可选。 JScript | VBScript | JavaScript（） 以上来自W3C：setTimeout() ,setInterval() 然而setTimeout()、setInterval()的区别在于setTimeout()：当方法执行完成定时器就立即停止(但是定时器还在,只不过没用了); setInterval()：当方法执行完成,定时器并没有停止,以后每隔[interval]这么长的时间都会重新的执行对应的方法[function],直到我们手动清除定时器为止; 意思就是：setTimeout()时间到了只会执行一次，setInterval()不会停止，会不间断的执行对应的函数，直到我们手动暂停或窗口被关闭。 文章下面有demo讲解： 那么如何暂停setTimeout()、setInterval():clearTimeout（）取消由setTimeout() 方法设置的 timeout。 clearInterval() ，这个函数只有一个作用，就是暂停setInterval()调用函数。 参数id_of_settimeout的意思是：clearTimeout是：使用clearTimeout()的函数名字，或者clearTimeout()调用的函数的名字。 setInterval是：使用setInterval()的函数名字，或者setInterval()调用的函数的名字。 提示：setTimeout、setInterval在设置定时器的时候有区别，然而他们在清除定时器的时候没有区别。 W3C资料:clearTimeout()，clearInterval() 倒计时跳转demo讲解：123456789101112131415//html相关部分： &lt;div class=&quot;time&quot;&gt;请等待&lt;span id=&quot;dd&quot;&gt;5&lt;/span&gt;秒&lt;/div&gt; //这里的5是初始5秒跳转。//js部分：function run()&#123; var s = document.getElementById(&quot;dd&quot;);//获取dd的dom if(s.innerHTML == 0)&#123;// 当dd==0的时候，跳转链接并且暂停函数 window.location.href = &quot;https://juejin.im/user/58714f0eb123db4a2eb95372/article&quot;; clearInterval(run());//取消由 setInterval() 设置的 timeout，，这里数字暂停在0这里，否则时间会继续往下减会出现负数。 //setInterval调用了run()，所以setInterval的返回ID值是run（） &#125; s.innerHTML = s.innerHTML -1;//从5秒开始，隔一秒跑一次run()然后减1 &#125; window.setInterval(&quot;run();&quot;, 1000); //这段代码的效果是一秒调用一次run()， //“run()”是要执行的代码块，1000是时间，默认单位是毫秒 上面这段代码主要是一个倒计时的效果，setInterval每隔一秒调用一次代码块run()，当时间被减到0的时候，暂停继续调用run()，否则会出现-1、-2的情况，然后跳转链接。具体的不懂的可以看代码注释，写的很详细。 如果还不知道的话，可以自己做个demo试试效果就知道了。 demo链接：倒计时跳转 菜鸟教程也有一个demo： 这也是一篇文章，写的听不错的，推荐一波！ 链接地址：js 定时器 写在后面：就十天没写文了，写的时候就感觉有点不知道怎么入手了，纠结了半天。我觉得应该把定时器的用法介绍清楚了，如果有什么地方写的不好的，欢迎指正，会在文章内勘误的。 最后：如需转载，请放上原文链接并署名。码字不易，感谢支持！因为我经常看不懂别人写的分享，所以个人写文比较偏小白，写的不好之处，欢迎指点。然后就是希望看完的朋友点个喜欢，也可以关注一下我。ps：目前待业，坐标北京，本人适应互联网快节奏，高强度，持续学习，持续成长，认真，严谨，学习积极性强。中小公司大佬求带走，邮箱：obkoro1@foxmail.com。掘金个人主页 参考链接：js 定时器关于js中两种定时器的设置及清除w3c：setTimeout(),w3c：setInterval()，w3c：clearTimeout()，w3c：clearInterval()。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js定时器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[随机数详解]生成一个随机数，生成指定范围的随机数及随机数组去重]]></title>
    <url>%2F2017%2F10%2F11%2F%E9%9A%8F%E6%9C%BA%E6%95%B0%E8%AF%A6%E8%A7%A3-%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%8C%E7%94%9F%E6%88%90%E6%8C%87%E5%AE%9A%E8%8C%83%E5%9B%B4%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%8F%8A%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%2F</url>
    <content type="text"><![CDATA[写在前面：很早之前在简书写过几篇关于随机数的文章之前写的很乱，现在重新整理一下这些知识点。本文包含了如下这些知识点：js生成随机数，生成指定范围的随机数，获得不重复随机数组。 js生成随机数。Math.random()——生成大于等于0.0且小于1.0的一个随机数;通常我们生成随机数都是使用这个方法，这个方法返回值是一个伪随机选择的数，该值大于等于0.0且小于1.0，即取值范围是[0.0,1.0)的左闭右开区间，在该范围内（近似）均匀分布。 下面有张动态图栗子，可以看一下。 Math.floor(Math.random()*20)——取0~20之间的随机整数：Math.floor(x)——使后面括号内的x（任意数值或表达式），生成一个小于等于 x，且与 x 最接近的整数。 Math.floor(x)，可以简单理解为下舍入。这里有几个栗子帮助理解，//后面是输出的内容：123456document.write(Math.floor(0.60) + &quot;&lt;br /&gt;&quot;)//0document.write(Math.floor(0.40) + &quot;&lt;br /&gt;&quot;)//0document.write(Math.floor(5) + &quot;&lt;br /&gt;&quot;)//5document.write(Math.floor(5.1) + &quot;&lt;br /&gt;&quot;)//5document.write(Math.floor(-5.1) + &quot;&lt;br /&gt;&quot;)//-6document.write(Math.floor(-5.9))//-6 解析上面Math.floor(Math.random()*20)的栗子：1.通过Math.random()生成0-1之间的随机数2.然后乘以20，就是取从0~20间的随机数，注意这里并不是整数。这里的范围可以改变，只要改后面那个数字为50,、8，就可以变成0~50,0~80之间的随机数。3.Math.floor()，使括号里面的(Math.random()乘以20)这个表达式，下舍入，生成为一个整数。 上面两个方法的demo动态图。 文末有demo链接，可以把代码复制回去，自己试试 生成指定范围的随机数（从任意值到任意值）这里是从任意值开始，我们刚才取的随机数都是从0开始。但是有些场景可能需要我们取一个指定范围的随机数，比如20-30,80-120等等。 这里有一个公式：Math.floor(Math.random()*(max-min+1)+min);ps： max - 范围内的最大值，min - 单位内的最小值 按照这个公式来，就没错了，下面是demo栗子。 值得注意的是：如果是负数范围的随机数，要进行符号转换的，比如–30（这里是说减去三十。），转换符号后变成+。不转换符号，会出现报错！ 12Math.floor(Math.random()*(-10--30+1)+-30)//错误Math.floor(Math.random()*(-10+30+1)-30);//正确。 生成指定范围的随机数的栗子： 获得不重复的随机数组。获得不重复随机数组的方法非常多，这里就介绍一种：使用indexOf()的方法来去重，然后通过push()方法来添加数组。 push() 方法的作用：push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。 indexOf()方法的定义及介绍： 看完了还是一脸懵逼，到底跟随机数组去重有什么关系？？ 这里有一句特别关键： 注释：如果要检索的字符串值没有出现，则该方法返回 -1。依靠这句注释，通过if条件判断，我们就可以做出随机数组去重的功能。 代码： 12345678910//num是一个数组，randomNum是一个随机数值。 while (num.length&lt;3)&#123;//num.length代表数组的长度，当数组的长度不再满足小于3，跳出循环 var randomNum=Math.floor(Math.random()*9);//获得在0-9之间的随机数 if (num.indexOf(randomNum)&lt;0)&#123; //判断randomNum之前有没有在数组里面，如果没有，就添加进去，如果有，重新循环。 num.push(randomNum); // 将randomNum这个随机数，添加到num这个数组里面。 &#125; console.log(num); &#125; 代码思路：1.先限定数组的长度，否则就成死循环了。2.获得一个随机数3.判断是否已经在数组里面，如果没有，就执行if下面的函数。4.没有出现这个随机数，indexOf（）这个方法会返回-1，这是判断条件的依据。5.当随机数达到三个了就跳出循环。此时num数组已经去重完毕。 代码执行演示：以下是演示的一个栗子，当数组里面已经有6了，再随机到6的时候，就会跳过push，直到随机到不重复的。 ps：indexOf（）这个方法去重效率到后期偏低，仅适用于数据量比较小的时候，因为后期数据量大的话，数组中每一个都进行依次比较的话，时间方面会花很长时间。文中出现栗子的：demo链接以上就是本文介绍的一些随机数的知识点。 最后：如需转载，请放上原文链接并署名。码字不易，感谢支持！因为我经常看不懂别人写的分享，所以个人写文比较偏小白，写的不好之处，欢迎指点。然后就是希望看完的朋友点个喜欢，也可以关注一下我。ps：目前待业，坐标北京，本人适应互联网快节奏，高强度，持续学习，持续成长，认真，严谨，学习积极性强。中小公司大佬求带走，邮箱：1677593011@qq.com。掘金个人主页 2017.5.9]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js随机数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用原生 JS 实现双向绑定及应用实例]]></title>
    <url>%2F2017%2F10%2F11%2F%E7%94%A8%E5%8E%9F%E7%94%9F-JS-%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8F%8A%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[写在前面：所谓的双向绑定，无非是从界面的操作能实时反映到数据，数据的变更也能实时展现到界面。angular封装了双向绑定的方法，使双向绑定变得十分简单。但是在有些场景下（比如下面那个场景），不能使用angular来实现双向绑定，需要我们使用js来实现双向绑定。 需求场景：写了一个点击事件，当点击的时候在后台赋值了，但是在页面视图上面没有显示出来，想到要使用双向绑定来实现这个功能。因为代码之前是用js和jq写的，引入angular的话，会导致之前的代码不能用。在网上参考了一篇文章之后做出来了这个功能 ps零碎知识点：楼主踩过坑了，引用angular写的话，不能再使用JQ写代码，楼主上次代码都删的差不多了，还不能使用，最后才发现是angular和JQ冲突了，所以最好不要混着使用。 实现效果： 实现效果点击按钮的时候，在后台赋值，然后直接在页面中显示出来，在方框里面输入值，也可以实时反映到数据。 ps：文末有demo链接，可以直接复制到本地试一试 应用：比如实现一个在后台赋值，然后界面出现一个随机的选项，谁是卧底、狼人杀这类型的。 实现原生js过程中的三个步骤：1.需要一个UI元素和属性相互绑定的方法（核心） 2.监视属性和UI元素的变化 3.需要让所有绑定的对象和元素都能感知到变化 实现思路：我们使用数据特性来为HTML代码进行绑定，所有被绑定在一起的JavaScript对象和DOM元素都会订阅一个PubSub对象。只要JavaScript对象或者一个HTML输入元素监听到数据的变化时，就会触发绑定到PubSub对象上的事件，从而其他绑定的对象和元素都会做出相应的变化。 代码实现部分：html代码部分：1234567891011&lt;h1&gt;原生js双向绑定及其应用&lt;/h1&gt;&lt;div class=&quot;js-2-1section2 col-sm-10 col-xs-10&quot;&gt; &lt;div&gt;&lt;input type=&quot;text&quot; data-bind-1=&quot;peopleName&quot; id=&quot;text1&quot;/&gt; &lt;!--data-bind-1=&quot;peopleName&quot; 原生js双向绑定的格式--&gt; &lt;/div&gt; &lt;div&gt;&lt;input type=&quot;text&quot; data-bind-2=&quot;killName&quot; id=&quot;text2&quot; /&gt; &lt;button class=&quot;btn btn-primary&quot; onclick=&quot;randomGroup()&quot;&gt;随机词组&lt;/button&gt; &lt;/div&gt; &lt;p data-bind-1=&quot;peopleName&quot;&gt;&lt;/p&gt; &lt;p data-bind-2=&quot;killName&quot;&gt;&lt;/p&gt;&lt;/div&gt; 上面代码中data-bind-1=”peopleName” 比较重要，其他一些乱七八糟，用来实现效果的，可以不用管。 分析一下————data-bind-1=”peopleName”：格式：data-bind-可以更改，只能是数字=”可以更改，相当于变量名” ps：第一个地方只能更改数字，因为创建的是对象。这里的数字可以不按照顺序，我试了999都可以。 js代码双向绑定部分js代码是封装好了的一个方法，可以按照前面几行的方式调用，代码里面有注释。 实际上以下这段代码已经实现了双向绑定，下面还有一个应用实例，感兴趣的可以看看。文末有demo链接，可以直接复制到本地试一试。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091var DBind1 = new DBind( 1 ); var DBind2 = new DBind( 2 );//前面是变量，括号里面的是html那里填的数字 DBind1.set( &quot;peopleName&quot;, &apos;第一个&apos; ); DBind2.set( &quot;killName&quot;, &apos;第二个&apos; );//第一个是刚才html格式那里的变量名，第二个方框是赋值 function DataBinder( object_id ) &#123; // 创建一个简单的pubSub对象 var pubSub = &#123; callbacks: &#123;&#125;, on: function( msg, callback ) &#123; this.callbacks[ msg ] = this.callbacks[ msg ] || []; this.callbacks[ msg ].push( callback ); &#125;, publish: function( msg ) &#123; this.callbacks[ msg ] = this.callbacks[ msg ] || []; for ( var i = 0, len = this.callbacks[ msg ].length; i &lt; len; i++ ) &#123; this.callbacks[ msg ][ i ].apply( this, arguments ); &#125; &#125; &#125;, data_attr = &quot;data-bind-&quot; + object_id, message = object_id + &quot;:input&quot;, timeIn; changeHandler = function( evt ) &#123; var target = evt.target || evt.srcElement, // IE8兼容 prop_name = target.getAttribute( data_attr ); if ( prop_name &amp;&amp; prop_name !== &quot;&quot; ) &#123; clearTimeout(timeIn); timeIn = setTimeout(function()&#123; pubSub.publish( message, prop_name, target.value ); &#125;,50); &#125; &#125;; // 监听事件变化，并代理到pubSub if ( document.addEventListener ) &#123; document.addEventListener( &quot;input&quot;, changeHandler, false ); &#125; else &#123; // IE8使用attachEvent而不是addEventListenter document.attachEvent( &quot;oninput&quot;, changeHandler ); &#125; // pubSub将变化传播到所有绑定元素 pubSub.on( message, function( evt, prop_name, new_val ) &#123; var elements = document.querySelectorAll(&quot;[&quot; + data_attr + &quot;=&quot; + prop_name + &quot;]&quot;), tag_name; for ( var i = 0, len = elements.length; i &lt; len; i++ ) &#123; tag_name = elements[ i ].tagName.toLowerCase(); if ( tag_name === &quot;input&quot; || tag_name === &quot;textarea&quot; || tag_name === &quot;select&quot; ) &#123; elements[ i ].value = new_val; &#125; else &#123; elements[ i ].innerHTML = new_val; &#125; &#125; &#125;); return pubSub; &#125; function DBind( uid ) &#123; var binder = new DataBinder( uid ), user = &#123; // 属性设置器使用数据绑定器pubSub来发布 attributes: &#123;&#125;, set: function( attr_name, val ) &#123; this.attributes[ attr_name ] = val; // Use the `publish` method binder.publish( uid + &quot;:input&quot;, attr_name, val, this ); &#125;, get: function( attr_name ) &#123; return this.attributes[ attr_name ]; &#125;, _binder: binder &#125;; // Subscribe to the PubSub binder.on( uid + &quot;:input&quot;, function( evt, attr_name, new_val, initiator ) &#123; if ( initiator !== user ) &#123; user.set( attr_name, new_val ); &#125; &#125;); return user; &#125; 原生js双向绑定应用实例：做了一个实现像谁是卧底中，随机抽取词汇，类似的功能。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function randomGroup() &#123; var oGroup=[];//存放所有词汇的词组、 for(var i=0;i&lt;20;i++)&#123; oGroup[i]=&#123;&#125;;//设置数组中的每个元素都是一个对象 &#125; //一个一个定义他们状态的字符串，然后在下面赋值 oGroup[0].people=&quot;降龙十八掌&quot;; oGroup[0].killer=&quot;九阴白骨爪&quot;; oGroup[1].people=&quot;快乐大本营&quot;; oGroup[1].killer=&quot;天天向上&quot;; oGroup[2].people=&quot;零花钱&quot;; oGroup[2].killer=&quot;生活费&quot;; oGroup[3].people=&quot;爷爷&quot;; oGroup[3].killer=&quot;姥爷&quot;; oGroup[4].people=&quot;同学&quot;; oGroup[4].killer=&quot;同桌&quot;; oGroup[5].people=&quot;小沈阳&quot;; oGroup[5].killer=&quot;宋小宝&quot;; oGroup[6].people=&quot;成吉思汗&quot;; oGroup[6].killer=&quot;努尔哈赤&quot;; oGroup[7].people=&quot;谢娜张杰&quot;; oGroup[7].killer=&quot;邓超孙俪&quot;; oGroup[8].people=&quot;新年&quot;; oGroup[8].killer=&quot;跨年&quot;; oGroup[9].people=&quot;保安&quot;; oGroup[9].killer=&quot;保镖&quot;; oGroup[10].people=&quot;眉毛&quot;; oGroup[10].killer=&quot;胡须&quot;; oGroup[11].people=&quot;端午节&quot;; oGroup[11].killer=&quot;中秋节&quot;; oGroup[12].people=&quot;摩托车&quot;; oGroup[12].killer=&quot;电动车&quot;; oGroup[13].people=&quot;高跟鞋&quot;; oGroup[13].killer=&quot;增高鞋&quot;; oGroup[14].people=&quot;汉堡包&quot;; oGroup[14].killer=&quot;肉夹馍&quot;; oGroup[15].people=&quot;牛奶&quot;; oGroup[15].killer=&quot;豆浆&quot;; oGroup[16].people=&quot;唇膏&quot;; oGroup[16].killer=&quot;口红&quot;; oGroup[17].people=&quot;公交&quot;; oGroup[17].killer=&quot;地铁&quot;; oGroup[18].people=&quot;结婚&quot;; oGroup[18].killer=&quot;订婚&quot;; oGroup[19].people=&quot;面包&quot;; oGroup[19].killer=&quot;蛋糕&quot;; //词汇出自——————谁是卧底的词汇大全 var oGroupNum=Math.floor(Math.random()*20);//抽取一个随机数，随机数范围跟上面数组的长度是一致的 oPeople=oGroup[oGroupNum].people; okiller=oGroup[oGroupNum].killer;//随机数的对应下标的状态字符串赋值给这个变量。 console.log(oPeople,okiller); DBind1.set( &quot;peopleName&quot;, oPeople );//将上面的状态字符串赋值给input框，。这一步将在界面中直接显示出来 DBind2.set( &quot;killName&quot;, okiller );&#125; demo地址以上就是用原生js实现双向绑定及其应用的所有内容了，本文主要是分享给之前不知道的小伙伴们看的，或者需要此类资料的小伙伴们。 最后：如需转载，请放上原文链接并署名。码字不易，感谢支持！因为我经常看不懂别人写的分享，所以个人写文比较偏小白，写的不好之处，欢迎指点。然后就是希望看完的朋友点个喜欢，也可以关注一下我。ps：目前待业，坐标北京，本人适应互联网快节奏，高强度，持续学习，持续成长，认真，严谨，学习积极性强。中小公司大佬求带走，邮箱：1677593011@qq.com。掘金个人主页 参考链接：JavaScript 实现简单的双向数据绑定 Javascript实现简单的双向绑定 用原生js实现数据双向绑定]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js双向绑定</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【闭包概念】关于闭包概念不同解读——你可以自己理解。]]></title>
    <url>%2F2017%2F10%2F11%2F%E3%80%90%E9%97%AD%E5%8C%85%E6%A6%82%E5%BF%B5%E3%80%91%E5%85%B3%E4%BA%8E%E9%97%AD%E5%8C%85%E6%A6%82%E5%BF%B5%E4%B8%8D%E5%90%8C%E8%A7%A3%E8%AF%BB%E2%80%94%E2%80%94%E4%BD%A0%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%B7%B1%E7%90%86%E8%A7%A3%E3%80%82%2F</url>
    <content type="text"><![CDATA[写在前面：闭包是被讲烂的内容，但是当我不了解的情况下，看过很多教程，听过很多道理，还是无法完全理解闭包这个东西。所以想要写一篇比较详细，前端小白也能够真正理解闭包概念的干货文章，本文参考很多闭包资料，希望能真正把闭包这个东西讲清楚，喜欢的朋友可以点个赞，或者点波关注。 首先需要了解一波js变量的作用域以及变量的生存周期。前几天我发在掘金上面了，下面是一个内容概要，墙裂推荐所有小伙伴，还是点进去学习一波，作用域这个问题可以说是闭包最为重要的内容。 里面的内容包括：1.变量的作用域（变量的有效范围）。2.变量作用域，js高级程序设计（红宝书）中的解释。3.红宝书中的作用域链栗子（还有一个例子的解析：画重点，这里关于作用域讲的比较详细，看完这个作用域就了解差不多）。4.变量的生存周期。 这里是链接，点进去学习一波：js 变量的作用域详解、生存周期，以及一些小细节。 闭包的概念：不同解读一览。以下节选了一些对闭包概念的不同理解，基本都没偏离本质，我进行一些解释和画重点操作，小伙伴们可以从中挑选一款相对于自己来说比较好理解的概念，自己意会。 维基百科闭包，不同于一般的函数，它允许一个函数在立即词法作用域外调用时，仍然访问非本地变量 MDN上面这么说：闭包是一种特殊的对象。闭包是由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。 闭包概念 根据《javascript权威指南》里对闭包的解释：所有的javascript函数都是闭包。而当一个嵌套函数被导出到它所定义的作用域外时，闭包会更有趣。 ps：我们通常意义上的闭包指的是在一个函数内部嵌套另一个函数，这里的概念很有趣。把所有函数都当成闭包，相当于把所有局部环境都当成了一个闭包，细细想想觉得蛮有道理的，这里就见仁见智了。 阮一峰的理解：闭包就是能够读取其他函数内部变量的函数。 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 javascript高级程序设计（红宝书）的解释）：闭包就是指有权访问另一个函数作用域中的变量的函数。 感觉这里比较简单且清晰，对此要解释一波，上面的意思是：闭包是一个函数内部嵌套着另一个函数，而被嵌套的那个函数有权利访问嵌套它的那个函数的作用域中变量。 上面这里分点来读，慢慢读。1.被嵌套的那个函数2.有权利访问3.嵌套它的那个函数4.的作用域中5.的变量。 这里有一张帮助你理解闭包概念的图片：用图片来记忆，记忆效率还是高一点，而且是这么特别的一张图片，这么6的图片，出自一张图搞定闭包概念 图片解释：描述嵌套函数的闭包情况。1.打个比方：有一只袜子，它的内部就好比是一个链式作用域；ps:作用域链的定义以及解析，在上面变量部分的链接里面。 2.小人无法直接获得袜子内部的“a”。这里的“a”就好比链式作用域里的一个局部变量；ps：蓝色圈圈里面的作用域形成了一个闭包，所以外面的无法访问a。 3.蓝色小圆圈就好比是内部链式作用域里的嵌套函数（闭包）。它可以通过链式作用域获取到“a”； 4.蓝色小圆圈通过伸出到袜子外的箭头，让小人可以拉取。这好比嵌套函数返回到外部；（return） 5.小人不断拉取小圆圈的线，把袜子里面翻了出来。他通过获取的蓝色小圆圈，顺利的获取到了“a”； ps：这里想表达的意思是：小人是全局环境，袜子是一个函数，蓝色圈圈是袜子函数里面嵌套的函数，a是嵌套函数中的变量。 产生一个闭包：创建闭包最常见方式，就是在一个函数内部创建另一个函数。 12345678function func()&#123; var a = 1,b = 2; function closure()&#123; return a+b; &#125; return closure;&#125; 上面例子中的 函数closure（） 就是一个闭包。 闭包的作用域链：包含着它自己的作用域，以及包含它的函数的作用域和全局作用域。（作用域链这块儿前面变量那里讲的很清楚了，不再赘述） 以下，我会再扩展开,过几天发出来：闭包的注意事项。闭包的应用。常见错误，在循环中创建闭包。闭包的面试题。 后话：想认真写明白一个东西真难，本文其实写到这里好几天了。最后那些没有扩展开的，希望能够写的详细点，然后就一直想着怎么写的更通俗一点。so，我先发这个出来，后面几个一个一个，慢慢解决。到时候，放链接链接起来。 最后：码字不易，感谢支持！因为我经常看不懂别人写的分享，所以个人写文比较偏小白，写的不好之处，欢迎指点。然后就是希望看完的朋友点个喜欢，也可以关注一下我。ps：目前待业，坐标北京，本人适应互联网快节奏，高强度，持续学习，持续成长，认真，严谨，学习积极性强。中小公司大佬求带走，邮箱：1677593011@qq.com。掘金个人主页 ，简书主页链接，csdn博客主页链接]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js闭包概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[布局概念] 关于CSS-BFC深入理解]]></title>
    <url>%2F2017%2F10%2F11%2F%E5%B8%83%E5%B1%80%E6%A6%82%E5%BF%B5-%E5%85%B3%E4%BA%8ECSS-BFC%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[写在前面好记性不如烂笔头，研究了一下BFC，发现里面比较细的东西也是很多的！关于BFC，很多人可能都听说过BFC这个东西，大概知道这是个啥东西，相信很多人对此并没有一个非常细致的了解，本文预计篇幅较长，认真，耐着性子看，应该都能够比较深入的理解BFC这个概念的规则、作用以及用法。希望喜欢的朋友可以点个赞，或者关注一波本人，谢谢。 BFC是什么鬼？BFC概括：可以在心中记住这么一个概念———所谓的BFC就是css布局的一个概念，是一块区域，一个环境。 先稳住别懵逼，接着往下走。 关于BFC的定义：BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与（在下面有解释）， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。 我们常说的文档流其实分为定位流、浮动流和普通流三种。而普通流其实就是指BFC中的FC。 FC是formatting context的首字母缩写，直译过来是格式化上下文，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用。 常见的FC有BFC、IFC（行级格式化上下文），还有GFC（网格布局格式化上下文）和FFC（自适应格式化上下文），这里就不再展开了。 通俗一点的方式解释:BFC 可以简单的理解为某个元素的一个 CSS 属性，只不过这个属性不能被开发者显式的修改，拥有这个属性的元素对内部元素和外部元素会表现出一些特性，这就是BFC。 下面列一波目录，然后分别展开来讲：触发条件或者说哪些元素会生成BFC： 满足下列条件之一就可触发BFC 【1】根元素，即HTML元素 【2】float的值不为none 【3】overflow的值不为visible 【4】display的值为inline-block、table-cell、table-caption 【5】position的值为absolute或fixed BFC布局规则：1.内部的Box会在垂直方向，一个接一个地放置。 2.Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 3.每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 4.BFC的区域不会与float box重叠。 5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 6.计算BFC的高度时，浮动元素也参与计算 BFC有哪些作用： 自适应两栏布局2可以阻止元素被浮动元素覆盖3可以包含浮动元素——清除内部浮动4.分属于不同的BFC时可以阻止margin重叠 BFC布局规则1：内部的Box会在垂直方向，一个接一个地放置。上文定义中提到过的块级盒：block-level box，在这里解析一波： 我们平常说的盒子是由margin、border、padding、content组成的，实际上每种类型的四条边定义了一个盒子，分别是分别是content box、padding box、border box、margin box，这四种类型的盒子一直存在，即使他们的值为0.决定块盒在包含块中与相邻块盒的垂直间距的便是margin-box。 提示：Box之间的距离虽然也可以使用padding来控制，但是此时实际上还是属于box内部里面，而且使用padding来控制的话就不能再使用border属性了。 布局规则1就是我们平常div一行一行块级放置的样式，大家想一下就知道了，这里就不展开了。 BFC布局规则2：Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。 上文提到过，决定块盒在包含块中与相邻块盒的垂直间距的便是margin-box。，上面的栗子就是这种情况。 演示中css属性设置：上面的box：margin-bottom: 100px;下面的box：margin-top: 100px;（他们是同一侧的margin，所以会发生margin重叠的情况，两个div的距离实际上只有100px。） BFC的作用4：阻止margin重叠:当两个相邻块级子元素分属于不同的BFC时可以阻止margin重叠 操作方法：给其中一个div外面包一个div，然后通过触发外面这个div的BFC，就可以阻止这两个div的margin重叠 下面是代码： 1234567891011121314151617181920&lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;&lt;div class=&quot;text&quot;&gt; &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;!--下面是css代码--&gt; .aside &#123; margin-bottom: 100px;//margin属性 width: 100px; height: 150px; background: #f66; &#125; .main &#123; margin-top: 100px;//margin属性 height: 200px; background: #fcc; &#125; .text&#123; /*盒子main的外面包一个div，通过改变此div的属性使两个盒子分属于两个不同的BFC，以此来阻止margin重叠*/ overflow: hidden;//此时已经触发了BFC属性。 &#125; ps：触发方式可以参考上文给出的触发条件。 这里有一个网址可以在线演示，通过演示，可以更直观一点： 链接地址：http://www.cnblogs.com/xiaohuochai/p/5248536.html BFC布局规则3：每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。12345&lt;div class=&quot;par&quot;&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; //给这两个子div加浮动，浮动的结果，如果没有清除浮动的话，父div不会将下面两个div包裹，但还是在父div的范围之内。 &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;&lt;/div&gt; 解析：给这两个子div加浮动，浮动的结果，如果没有清除浮动的话，父div不会将下面两个div包裹，但还是在父div的范围之内，左浮是子div的左边接触父div的borderbox的左边，右浮是子div接触父div的borderbox右边，除非设置margin来撑开距离，否则一直是这个规则。 BFC作用3：可以包含浮动元素——清除内部浮动给父divpar加上 overflow: hidden; 清除浮动原理：触发父div的BFC属性，使下面的子div都处在父div的同一个BFC区域之内，此时已成功清除浮动。 还可以向同一个方向浮动来达到清除浮动的目的，清除浮动的原理是两个div都位于同一个浮动的BFC区域之中。 BFC布局规则4：BFC的区域不会与float box重叠：12345678910111213141516171819&lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;&lt;div class=&quot;text&quot;&gt; &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;!--下面是css代码--&gt; .aside &#123; width: 100px; height: 150px; float: left; background: #f66; &#125; .main &#123; height: 200px; overflow: hidden;//触发main盒子的BFC background: #fcc; &#125; .text&#123; width: 500px; &#125; 上面aside盒子有一个浮动属性，覆盖了main盒子的内容，main盒子没有清除aside盒子的浮动。只做了一个动作，就是触发自身的BFC，然后就不再被aside盒子覆盖了。所以：BFC的区域不会与float box重叠。 BFC作用：自适应两栏布局。 还是上面的代码，此时BFC的区域不会与float box重叠，因此会根据包含块（父div）的宽度，和aside的宽度，自适应宽度。 BFC 与 LayoutIE 作为浏览器中的奇葩，当然不可能按部就班的支持 BFC 标准，于是乎 IE 中有了 Layout 这个东西。Layout 和 BFC 基本是等价的，为了处理 IE 的兼容性，在需要触发 BFC 时，我们除了需要用触发条件中的 CSS 属性来触发 BFC，还需要针对 IE 浏览器使用 zoom: 1 来触发 IE 浏览器的 Layout。 有趣的文本:1234567891011.par &#123; margin-top: 3rem; border: 5px solid #fcc; width: 300px; &#125; .child &#123; border: 5px solid #f66; width:100px; height: 100px; float: left; &#125; 当我使用上面的属性，再加上一个没有属性的p或者span标签，就发现两个子div的float属性自动被清除了，这是因为span或者p这类文本自带一个BFC吗？还是什么？求路过的大神解释。。。 以上是错误的。这里两个div被撑开，是因为父div被p标签撑开了，并不是因为清除浮动的原因，从下面这张图片可以清楚的知道。 其实以上的几个例子都体现了BFC布局规则第五条———— BFC布局规则5：BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 文本环绕float：123456&lt;div style=&quot;float: left; width: 100px; height: 100px; background: #000;&quot;&gt;&lt;/div&gt;&lt;div style=&quot;height: 200px; background: #AAA;&quot;&gt; &lt;div style=&quot; width: 30px; height: 30px; background: red;&quot;&gt;&lt;/div&gt; &lt;p&gt;content&lt;/p&gt; &lt;p&gt;content&lt;/p&gt; &lt;p&gt;content&lt;/p&gt; &lt;p&gt;content&lt;/p&gt; &lt;p&gt;content&lt;/p&gt;&lt;/div&gt; 问题：为什么 div 的左上角被覆盖了，而文本却没有被覆盖，float不是应该跟普通流不在一个层级吗？是因为float属性不生效吗？ 解决：float的定义和用法：float 属性定义元素在哪个方向浮动。以往这个属性总应用于图像，使文本围绕在图像周围，不过在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。 从上图可以看到，float属性确实生效，将float隐藏后，下面还有一个红色的div，这个div是被黑色div所覆盖掉的。div会被float覆盖，而文本却没有被float覆盖，是因为float当初设计的时候就是为了使文本围绕在浮动对象的周围。 后话上面说的有些东西，其实在我们平常的布局中，已经有在使用这些规律，只是没有总结出来，如果写的不好之处欢迎批评指导。还有一篇关于闭包的，还没写完。。五一三天净打游戏了！应该很快就会写好了。 最后：码字不易，感谢支持！因为我经常看不懂别人写的分享，所以个人写文比较偏小白，写的不好之处，欢迎指点。然后就是希望看完的朋友点个喜欢，也可以关注一下我。ps：目前待业，坐标北京，本人适应互联网快节奏，高强度，持续学习，持续成长，认真，严谨，学习积极性强。中小公司大佬求带走，邮箱：1677593011@qq.com。掘金个人主页 ，简书主页链接，csdn博客主页链接 参考链接：BFC神奇背后的原理，深入理解BFC什么是BFCBlock Formatting Context (BFC) 浅析 以上。2017.5.4.]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>Css-BFC作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js变量的作用域详解、生存周期，以及一些小细节。]]></title>
    <url>%2F2017%2F10%2F11%2Fjs%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%AF%A6%E8%A7%A3%E3%80%81%E7%94%9F%E5%AD%98%E5%91%A8%E6%9C%9F%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%BB%86%E8%8A%82%E3%80%82%2F</url>
    <content type="text"><![CDATA[写在前面：是想写一个闭包的，因为写的比较细，基于篇幅，所以闭包前面关于变量的部分就单独发出来，到时候放个链接引进来，js闭包虽然是一个被讲烂的东西，但其实很多人刚接触这个概念也不太懂，所以希望写一篇接地气，能够让一个从前不知道这个内容的小伙伴能够清楚的理解闭包这个东西。so，本文是基于闭包的变量部分。 首先需要理解变量的作用域（变量的有效范围）：变量的作用域有两种：全局变量和局部变量。 全局变量很好理解：就是我们平时没有再函数内部声明的那些变量，在全局中任何地方（函数，对象等）都可以被引用。 栗子： 12345var n=999; function f1()&#123; alert(n); &#125; f1(); // 输出999,说明全局变量n在函数内部被读取 局部变量：在函数内部声明的变量。函数内部的变量，外部无法读取。 栗子： 1234 function f1()&#123; var n=999; &#125; alert(n); // 没有定义，说明函数内部的变量，外部无法读取。 在函数内部声明变量没有使用var，实际上是声明了一个全局变量，前提是需要先调用函数（闭包函数中，也是全局变量。）！ 栗子： 12345678910111213var func1=function()&#123; a1=1; console.log(a1); //输出:1 function func2() &#123;//func2()是一个闭包 a2=2; console.log(a2); &#125; func2()；//闭包函数中的变量在调用函数之后，变量也是全局变量 console.log(a2);//输出2&#125;;func1();//调用函数，才会使变量生效console.log(a1);//输出1 console.log(a2);//输出2，说明闭包中没有用var声明的变量也是全局变量。 上面栗子中在函数里面声明变量没有用var，在调用函数之后，a1，a2都能有效输出，看完栗子之后，相信你们对变量的作用域也有一些了解了，我们总结一下： 变量作用域，js高级程序设计（红宝书）中的解释：内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境是线性、有次序的。每个环境都可以向上搜索作用域链，以查询变量和函数名； 意思就是：比如函数的局部环境可以访问到外界所有的变量的函数，而且环境的搜索是先从自己本身的环境开始，一级一级往上搜索，这样由多个执行上下文的变量对象构成的链表就叫做作用域链。 关于查找变量，红宝书中有一句话是这样的：标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级的向后查找，直至找到标识符位置（如果找不到标识符，通常会导致错误的发生、） ps：标识符指的是变量的名字，作用域链的前端指的是当前执行代码所在环境的变量对象。 作用域链的用途：保证对执行环境有权访问的所有变量和函数的有序访问。 红宝书中的作用域链栗子：123456789101112131415var color = &apos;blue&apos;;function text1()&#123; var anotherColor = &apos;red&apos;; function text2()&#123; var tempCplor = anotherColor; anotherColor = color; //这里可以访问到color、anotherColor和tempColor &#125; //这里可以访问color和anotherColor,但不能访问到tempColor text2();&#125;//这里只能访问到colortext1(); 解析（画重点，这里关于作用域讲的比较详细，看完这个作用域就了解差不多）：以上代码一共涉及三个执行环境：全局环境，text1()的局部环境和text2()的局部环境。 1.全局环境中有一个变量color和一个函数text1()。 2.text1()的局部环境中有一个anotherColor变量和一个text2()的函数，但它可以访问到全局环境中的变量color。 3.text2()的局部环境有一个变量tempColor，该变量只能在text2()自身的环境中被访问到。这是一个闭包，无论是全局环境还是text1()的局部环境都无权访问tempColor。但是在text2()的内部环境中，可以访问到全局环境和text1()中的所有变量，因为这两个环境是text2()的父执行环境。 这个作用域链为： ps：函数参数也被当做变量来对待，因此其访问规则与执行函数中的其他变量相同。 以上出自红宝书，自己修改了一丢丢，红宝书还是神器啊，常看常新，每次都会有新发现。 关于变量的生存周期：1.全局变量的生存周期是永久的，除非我们主动销毁。 ps：变量永久生存，且可以随时调用，但是使用的时候要适度，正是因为它的生命周期长，所以将占据更多的内存，如果声明的变量都是全局变量，当项目比较大的时候，就可能出现性能问题,养成一个好的习惯还是有必要的。 2.而对于在函数内用 var 关键字声明的局部变量来说,当退出函数时,这些局部变量即失去了它们的价值,它们都会随着函数的调用的结束而销毁。 ps：调用函数结束，局部变量确实会销毁。但并不是完全销毁，而是一直函数的内部环境中存活着，当函数再度被调用时，变量就“复活”了，所以局部变量还是非常方便的，不会影响二次使用。 值得注意的是：在局部环境中，出现全局变量与局部变量重名的时候，起作用的是局部变量，全局变量被屏蔽掉。这是因为上文说过作用域链的原因，先由局部开始搜索变量，当局部找到该变量的时候，就不会再我继续往父级找变量了。 后话：就这些吧，觉得内容不够多，平常多一点的。本来想写个面试题的，后来几经修改，觉得写的不好，就删掉了。这几天五一，争取把闭包这个东西写出来，写的不好之处，欢迎指导。 最后：码字不易，感谢支持！因为我经常看不懂别人写的分享，所以个人写文比较偏小白，写的不好之处，欢迎指点。然后就是希望看完的朋友点个喜欢，也可以关注一下我。ps：目前待业，坐标北京，本人适应互联网快节奏，高强度，持续学习，持续成长，认真，严谨，学习积极性强。中小公司大佬求带走，邮箱：1677593011@qq.com。掘金个人主页 ，简书主页链接，csdn博客主页链接]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js变量作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http状态码是什么，有什么用，在哪里查看，分别代表什么意思？]]></title>
    <url>%2F2017%2F10%2F11%2Fhttp%E7%8A%B6%E6%80%81%E7%A0%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%8C%E5%9C%A8%E5%93%AA%E9%87%8C%E6%9F%A5%E7%9C%8B%EF%BC%8C%E5%88%86%E5%88%AB%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[写在前面：当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头用以响应浏览器的请求。本文主要是：关于http状态码是什么，有什么用，在哪里查看状态码分别代表什么意思的分享，这里面内容也是非常多的，所以在此科普一下，做波分享。这里面有关键词版本和详细介绍每个错误的版本。 http状态码有什么用？http状态码的核心作用是Web Server服务器用来告诉客户端，当前的网页请求发生了什么事，或者说当前Web服务器的响应状态。所以HTTP状态码常用来判断和分析当前Web服务器的运行状况。 我们作为程序猿，需要对这些状态码，尽可能了解的更多一些，将这些状态码一一弄清楚，工作中遇到的时候，能够明白问题出在哪里，针对性的解决问题。 常用的http状态码：200 OK 服务器成功处理了请求（这个是我们见到最多的） 301/302 Moved Permanently（重定向）请求的URL已移走。Response中应该包含一个Location URL, 说明资源现在所处的位置 404 Not Found(页面丢失)未找到资源 501 Internal Server Error服务器遇到一个错误，使其无法对请求提供服务 常见的HTTP状态码的概括（文章下面有详细的介绍）：1开头：（被接受，需要继续处理。）这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。 2开头 （请求成功）这一类型的状态码，代表请求已成功被服务器接收、理解、并接受 3开头 （请求被重定向）这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。 4开头：（请求错误）这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个 HEAD 请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。 5开头：（服务器错误）这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD 请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。 http状态码在哪里查看？1.浏览器的F12调试（或者右键检查），network查看Status，如下图所示，status就是http返回的状态码。 2.各种在线输入网址查询HTTP状态的工具：比如：站长工具，http状态查询：http://tool.chinaz.com/pagestatus/ 像这样的网站，也提供这个功能。。。。http://www.3464.com/Tools/PageStatus/ 其他的应该还有很多，可以自己去搜索一下。 状态码的变化转换：在进行一个http请求的时候，我们看到的只是最后服务器返回来的状态码，比如出错了404之类，或者成功了200.这说明整个http状态请求的过程中，状态码都只是最后返回的那个状态码吗？ 实际上在请求的过程中，http状态码的变化的非常快，像刚才说的1开头的状态码（被接受，需要继续处理。），这类状态码只是一个临时响应的状态码，http请求还是要继续进行下去的，这种状态码是用来反映现在请求进行到哪一步了。除非是类似那种像打断点的东西，一步操作停一下，才会清晰的看出http状态码是如何进行变化的。 http状态码的概括：这里是对每个http状态的主要作用进行概括，关于详细的http状态有兴趣了解的朋友们，可以点这里：HTTP状态码,这里是百度百科的对http状态码的详细解析，是我看到的最全的了。 1开头：（被接受，需要继续处理。）这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。 100（客户端继续发送请求，这是临时响应）：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。 101服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议。 102 (代表处理将被继续执行) 由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。 2开头 这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 201 （已创建） 请求成功并且服务器创建了新的资源。 202 （已接受） 服务器已接受请求，但尚未处理。 203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204 （无内容） 服务器成功处理了请求，但没有返回任何内容。 205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。 206 （部分内容） 服务器成功处理了部分 GET 请求。 207 (代表之后的消息体将是一个XML消息)，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。 3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304 （未修改）自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。400 （错误请求） 服务器不理解请求的语法。 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 （禁止） 服务器拒绝请求。 404 （未找到） 服务器找不到请求的网页。 405 （方法禁用） 禁用请求中指定的方法。 406 （不接受） 无法使用请求的内容特性响应请求的网页。 407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 408 （请求超时） 服务器等候请求时发生超时。 409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。 411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 415 （不支持的媒体类型） 请求的格式不受请求页面的支持。 416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。 5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。 500 （服务器内部错误） 服务器遇到错误，无法完成请求。 501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 ps：还有一些状态码还没写出来，有兴趣了解的，点这里：http百度百科 最后：码字不易，感谢支持！因为我经常看不懂别人写的分享，所以个人写文比较偏小白，写的不好之处，欢迎指点。然后就是希望看完的朋友点个喜欢，也可以关注一下我。ps：目前待业，坐标北京，中小公司大佬求带走，qq：1677593011。掘金个人主页 ，简书主页链接，csdn博客主页链接 参考资料：常见的HTTP状态码(HTTP Status Code)说明百度百科HTTP状态码 以上。2017.4.27]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http状态码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 jQuery, Angular.js 实现登录界面验证码详解]]></title>
    <url>%2F2017%2F10%2F11%2F%E4%BD%BF%E7%94%A8-jQuery-Angular-js-%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[写在前面：前段事件，做了一个用ajax后台异步交互的登录功能，自己在上面加了一个验证码的功能，这个功能背后的原理挺好理解的，实现起来也十分简单，特此写波分享，，自己写的过程中踩了不少坑，这里还是照例写的详细点，大家可以做个参考，喜欢的朋友可以点个赞，或者关注一波。 最终实现的效果： 验证码效果当点击登录之前，会先判断验证码是否正确（验证码可以不区分大小写，也可以区分大小写），验证码错误会刷新验证码，验证码验证之前，不会进行跨域登录操作。 整体思路。1.取四位随机数 2.赋值到验证码的input框里。 3.在点击登录之前先用if判断验证码input框的值和输入框的值是否相等，相等时进入下一步操作，不相等直接返回错误 4.里面ajax的部分可以直接套进去。 细节：1.这里的验证码框的背景图片是网上自己找的，显得验证码比较正式，不然显得有点low。 2.不区分大小写实际上就是利用js的toUpperCase()方法是把小写转换成大写，因为是原生js所以在angular中也可以使用！ 3.将验证码封装成一个函数，然后在点击登录时在最后调用这个函数，可以每次都刷新函数。 4.避免验证码被复制，在html里面使用：disabled=”disabled”——禁止验证码框文字被选中。 下面是代码部分实现过程详解（注释写的比较详细）：html代码应该不会解释了，有不懂的，可以在评论区问我。下面有部分关于angular的内容，暂时还没学到这里可以跳过去，没有影响到实现效果的。(可以把代码复制过去，然后在自己本地试试。) 先放用jq实现的过程，然后放angular实现的过程，看过我几篇文章的都知道，我尽量会把所有代码，每一步都注释的清清楚楚，希望可以帮助到大家。 这里是html的内容：12345678910111213141516171819202122232425&lt;div class=&quot;js5-form&quot; id=&quot;js5-form&quot; ng-controller=&quot;enterCtrl&quot;&gt; &lt;div id=&quot;enter-all&quot; &gt; &lt;h3&gt;jnshu后台登录&lt;/h3&gt; &lt;form action=&quot;&quot; name=&quot;myForm&quot;&gt; &lt;div class=&quot;js5-input-div&quot;&gt; &lt;div class=&quot;js5-input-img1&quot;&gt;&lt;/div&gt; &lt;input id=&quot;js5-userNum&quot; type=&quot;text&quot; name=&quot;userName&quot; placeholder=&quot;用户名&quot; maxlength=&quot;12&quot; ng-model=&quot;userName&quot; ng-keyup=&quot;mykey($event)&quot; required/&gt; &lt;/div&gt; &lt;/form&gt; &lt;form action=&quot;&quot; name=&quot;registerForm&quot;&gt; &lt;div class=&quot;js5-input-div&quot;&gt; &lt;div class=&quot;js5-input-img2&quot;&gt;&lt;/div&gt; &lt;input id=&quot;js5-password&quot; type=&quot;password&quot; name=&quot;userPsd&quot; placeholder=&quot;密码&quot; maxlength=&quot;20&quot; ng-model=&quot;userPsd&quot; ng-keyup=&quot;mykey($event)&quot; ng-minlength=&quot;5&quot; ng-maxlength=&quot;16&quot; required/&gt; &lt;/div&gt; &lt;/form&gt; &lt;!--账号和密码的登录框--&gt; &lt;form action=&quot;&quot; &gt; &lt;div class=&quot;js5-input-div&quot;&gt; &lt;span class=&quot;js5-input-divSpan&quot;&gt;验证码：&lt;/span&gt; &lt;input type=&quot;text&quot; placeholder=&quot;不区分大小写&quot; class=&quot;js5-form3-input&quot; id=&quot;js5-form3-input&quot; ng-model=&quot;writeCode&quot; maxlength=&quot;6&quot; ng-keyup=&quot;mykey($event)&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;js5-authCode&quot; value=&quot;&quot; id=&quot;js5-authCode&quot; ng-model=&quot;showAuthCode&quot; disabled=&quot;disabled&quot;&gt; &lt;!--disabled=&quot;disabled&quot;禁止验证码框文字被选中--&gt; &lt;span class=&quot;spanShift&quot; ng-click=&quot;changeVerify()&quot;&gt;获取&lt;/span&gt; &lt;/div&gt; &lt;/form&gt; 这里是jq代码实现部分：记得引入jq文件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071var authCode; randomCode=$(&quot;#js5-authCode&quot;).eq(0);//获取验证码出现的方框domconsole.log(randomCode);function createCode() &#123; authCode=&quot;&quot;;//设置这个为空变量，然后往里面添加随机数 var authCodeLength=4;//随机数的长度 randomArray=[0,1,2,3,4,5,6,7,8,9,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;,&apos;G&apos;,&apos;H&apos;,&apos;I&apos;,&apos;J&apos;,&apos;K&apos;,&apos;L&apos;,&apos;M&apos;,&apos;N&apos;,&apos;O&apos;,&apos;P&apos;,&apos;Q&apos;,&apos;R&apos;, &apos;S&apos;,&apos;T&apos;,&apos;U&apos;,&apos;V&apos;,&apos;W&apos;,&apos;X&apos;,&apos;Y&apos;,&apos;Z&apos;]; //创建一个数组，随机数从里面选择四位数或者更多 for(var i=0;i&lt;authCodeLength;i++)&#123; var index=Math.floor(Math.random()*36);//随机取一位数 authCode +=randomArray[index];//取四位数，并+相连 &#125; console.log(authCode);//取到四位随机数之后，跳出循环 randomCode.val(authCode);//将四位随机数赋值给验证码出现的方框 console.log(randomCode.val());&#125;//以上是封装的获取验证码的函数$(function () &#123;//当文档加载结束后，运行这个函数 createCode();//一开始先运行一遍取随机数的函数 $(&quot;#js5-btn&quot;).click(function () &#123;//这里是一个点击事件 console.log(window.randomCode); //这里写了一个必报，window.randomCode是在文档里面找到这个dom，否则上文的四个随机数传不到这里来 var randomCode=window.randomCode.val(); console.log(randomCode); var authInput=$(&quot;#js5-form3-input&quot;).val().toUpperCase(), user=$(&quot;#js5-userNum&quot;).val(), psd=$(&apos;#js5-password&apos;).val(); //上面三个是分别获取验证码输入框的值，账号的值，密码的值。 //验证码输入框这里，最后toUpperCase()方法是把小写转换成大写 console.log(authInput); console.log(randomCode); console.log(user,psd); if (randomCode===authInput) &#123; //验证验证码，在验证码输入框与验证码的值不相等之前，是不会进入下面登录的步骤的，验证码是第一步关卡 var firstAjax = new XMLHttpRequest(); //创建ajax对象，这里是ajax跨域的部分 firstAjax.open(&quot;POST&quot;, &quot;这里是你url跨域的地址&quot;, true); //连接服务器，跨域。 firstAjax.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); //setRequestHeader() 方法指定了一个 HTTP 请求的头部，它应该包含在通过后续 send() 调用而发布的请求中。 //可以理解为，这是http的请求头，固定格式，位置必须要在open之后，send之前。 firstAjax.send(&quot;name=&quot; + user + &quot;&amp;pwd=&quot; + psd); //在使用POST方式时参数代表着向服务器发送的数据，前面两个是账号框和密码框 firstAjax.onreadystatechange = function () &#123;//当参数被传入服务器的时候，引用监听事件。 if (firstAjax.readyState == 4) &#123;//readyState四种状态，当执行四步完成之后 if (firstAjax.status == 200) &#123;//返回的是200，代表成功，404未找到。 var returnValue = JSON.parse(firstAjax.responseText);//取回由服务器返回的数据 console.log(returnValue); if (returnValue.code == 0) &#123;//这里是后端定义的，当code==0的时候，代表登录正确。 window.location.href = &quot;https://www.baidu.com/index.php?tn=98012088_3_dg&amp;ch=1&quot;; //后端返回的数据验证成功就跳转链接。 &#125; else &#123; $(&quot;#js5Message&quot;).text(returnValue.message);//当code不等于0时，返回出错信息 &#125; &#125; else &#123; alert(&quot;出错咯，咯咯咯&quot;);//返回的不是200的时候，出错。 &#125; &#125; &#125;; createCode();//点击登录按钮，验证之后会刷新验证码 &#125; else &#123; $(&quot;#js5Message&quot;).text(&quot;验证码错误，请重新输入&quot;); createCode();//验证码错误，刷新验证码。 &#125; &#125;)&#125;); 这是是angular代码实现部分：jq部分写的详细一点，这里也挺详细的，如果不懂的话，可以回头看看jq部分，原理都是一样的，复制到本地自己多试试，记得引angular文件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var enter=angular.module(&quot;myApp&quot;);enter.controller(&apos;enterCtrl&apos;,[&apos;$scope&apos;,&apos;$http&apos;,&apos;$state&apos;,function ($scope,$http,$state) &#123; $scope.changeVerify=function () &#123;//定义了一个点击事件，获取验证码 var authCode=&quot;&quot;; var authCodeLength=4;//取几个随机数字 var randomArray=[0,1,2,3,4,5,6,7,8,9,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;,&apos;G&apos;,&apos;H&apos;,&apos;I&apos;,&apos;J&apos;,&apos;K&apos;,&apos;L&apos;,&apos;M&apos;,&apos;N&apos;,&apos;O&apos;,&apos;P&apos;,&apos;Q&apos;,&apos;R&apos;, &apos;S&apos;,&apos;T&apos;,&apos;U&apos;,&apos;V&apos;,&apos;W&apos;,&apos;X&apos;,&apos;Y&apos;,&apos;Z&apos;]; for(var i=0;i&lt;authCodeLength;i++)&#123; var index=Math.floor(Math.random()*36);//随机取一位数 authCode +=randomArray[index];//取四位数，并+相连 &#125; $scope.showAuthCode=authCode;//赋值 console.log($scope.showAuthCode); &#125;; //上面是封装的获取验证码的函数，会在下面进行调用 (function () &#123; $scope.changeVerify();//调用点击事件。 $scope.enter=function (userName,userPsd) &#123; //点击登录按钮事件，将双向绑定的账号密码当做参数传入函数 if ($scope.writeCode.toUpperCase() ==$scope.showAuthCode)&#123;//toUpperCase()将小写转化为大写 //双向绑定验证码输入框，可以直接使用，这里是验证验证码 $http(&#123; method:&quot;POST&quot;, url:&quot;你的跨域地址&quot;,//$http的固定格式 params:&#123; &quot;name&quot;:userName, &quot;pwd&quot;:userPsd //双向绑定的参数传到下个页面 &#125; &#125;).then(function (res) &#123; //获取服务器返回的参数 console.log(res); if (res.data.code!==0)&#123; //参数不为0的时候，弹出提示 alert(res.data.message); &#125;else &#123; //参数为0的时候，跳转页面 $state.go(&quot;home.studentList&quot;); &#125; &#125;) &#125;else &#123; alert(&quot;验证码输入错误咯，咯咯咯&quot;); $scope.changeVerify();//验证后，刷新验证码 &#125; &#125; &#125;()); 后话断断续续写了两天，现在写的没有之前那么快了。。差不多就以上这些内容，有问题可在评论区留言。有不足欢迎指导，拍砖。 最后：因为我经常看不懂别人写的分享，所以个人写文比较偏小白，写的不好之处，欢迎指点。然后就是希望看完的朋友点个喜欢，也可以关注一下我，现在这阶段基本上每个月都不会少于十五篇文章（看到干货我也会进行分享）。码字不易，感谢支持！ps：目前待业，坐标北京，求推荐工作。然后希望我写哪方面的文章可以在底下评论，或者是私信我，虽然写的不好，但我就当这是记录自己成长的一种方式咯。（前提是我会了，如果不会我也会记下来，等会了的时候再更出来。）掘金个人主页 ，简书主页链接，csdn博客主页链接 ，github 。]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>前端登录界面验证码详解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sass变量详解——你不知道的sass。]]></title>
    <url>%2F2017%2F10%2F11%2Fsass%E5%8F%98%E9%87%8F%E8%AF%A6%E8%A7%A3%E2%80%94%E2%80%94%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84sass%E3%80%82%2F</url>
    <content type="text"><![CDATA[写在前面：现在一直使用sass写css，当初入门的时候，看的很多教程，当时看的云里雾里的，现在看来还是蛮详细的，就是一点，不够小白。本人文章类型一直比较偏小白的，想要更好的为不会用sass提供一点学习的资料，相信本文对想要学习sass的人，还是有极大的参考价值的。里面有些细节，也许对已经学会使用sass的大手子也有一定的参考价值。 变量是什么？w3c关于JavaScript 变量的介绍： 上面一大堆巴拉巴拉的东西，可以先这么理解，把变量看作一个存放东西的盒子，可以将钥匙、手机、饮料等物品存放在这个盒子中，也可以在需要的时候换成我们想存放的新物品，那里面的旧的东西就存不了，只能存一个东西。 建议这里有个很好的网站，可以在线把sass文件编译成css文件，大家可以跟着栗子，一边看，一边动手做做demo，看看最后输出css是什么样子的。 sass变量的格式：sass变量格式：$var:value; 栗子：$color:red; 1.必须是$开头解析：这是sass变量的符号 2.$后面紧跟变量名解析：变量名首字母必须为字母(a-z A-Z)，下划线(_)开头。 3.变量的值解析：变量值和变量名之间就需要使用冒号(:)分隔开（就像CSS属性设置一样）。 sass变量的用法：12$color:red;/*1.这就是声明变量*/p&#123;color:$color;&#125;/*P标签的颜色被改为red————这是变量的使用*/ 1.变量使用之前要先声明变量解析：声明在变量这个盒子里面要放什么东西，那里面就有东西了 2.第二步使用变量。解析：现在变量里面有东西了，要把里面的东西拿出来用，就要先找到变量这个盒子，找到盒子才能使用里面的东西。变量的变量名，就是这个盒子在的地方，把他放在你所要用的地方，就是把盒子里面的东西取出来用了。 多值变量：多值变量格式：$var:value,value,value; 实例：123456$back:#fff,green,red;/*1.多个变量一起声明*/ p&#123; color: nth($back,1);/*2.输出green*/ &#125; span&#123; color: nth($back,3);/*3.输出red*/ 解析：所谓的多值变量就是字面上的意思，把多个相关的值写在一个变量里，然后通过nth($var,index)来获取第几个值。通常可以用于在写页面的时候声明多个颜色，然后再样式里面直接使用就可以了。 关于变量的作用域： 解析：以上是我在sass文件里面做的一个demo，里面分成了三个部分，下面分别给大家解析一下。 1.第一部分，变量要提前声明才能使用。这里我上面没有声明$text1这个变量，直接使用，导致文件报错。 sass文件编译是从上往下的，所以使用的时候，变量要声明在上面，当上面没有声明的时候，使用这个变量就会报错，文件编译错误，导致css文件无法使用。 2.第二部分，sass的全局属性，详见demo，里面注释的很清楚了。 因为sass文件是从上往下解析的，同一个sass变量在外界声明的时候，会有一个覆盖的作用，即上面已经声明过的变量，会被下面声明的给覆盖。 3.第三部分，sass也有局部变量。局部被包裹的变量，将不会影响到外界的变量，只在自己的一亩三分田里面起作用，外界要引用这个变量也是不行的。如果这里我没有定义外界的变量，局部被包裹起来的那部分$text:blue;还是会生效的。 变量的默认值default：刚才说了，sass文件是从上往下渲染的，后面声明的变量会覆盖前面的变量，default这里的作用就是使后面的变量变成声明在第一个的变量（就是开始声明这个变量的地方，默认是第一个。） 变量格式：$var:value!default; 栗子：$color:red!default; 代码示例。 解析：1.这里把注释弄掉之后，sass编译会出错，因为上面没有声明这个变量，说明加上default之后，刚才关于变量的作用域的介绍也是不变的，下面还有一个局部作用域的栗子。 2和3.在代码注释里面，已经很详细了，不赘述了。 4.说明连续声明两个default也是有效的，第一个default会被第二个default覆盖。第二个default会被没有声明default的变量覆盖，所以最终输出的是没有声明default的变量red。 1.这里不解析了，详见注释。 变量用#{}包裹这是一个格式，用在属性或者选择器上面里。大家看一下栗子就懂了。 12345$ipt:input;$btm:bottom;.#&#123;$ipt&#125;&#123; /*这里输出.input&#123;&#125;*/ padding-#&#123;$btm&#125;:5rem;/*这里输出padding-bottom: 5rem;*/&#125; 后话：断断续续写了三天，每天都有在写，今天算是差不多写完了。这篇是面向对sass变量概念不太熟悉的朋友，写的较为详细，在短短的一篇文章里面肯定无法保证阅读本文的人对sass有多熟悉，但我希望通过这篇文章，让你知道sass变量的一些用法，概念。能够不再那么一头雾水，那么我这篇文章的目的也就达到了。 最后：因为我经常看不懂别人写的分享，所以个人写文比较偏小白，写的不好之处，欢迎指点。然后就是希望看完的朋友点个喜欢，也可以关注一下我，现在这阶段基本上每个月都不会少于十五篇文章（看到干货我也会进行分享）。码字不易，感谢支持！ps：目前待业，坐标北京，求推荐工作。然后希望我写哪方面的文章可以在底下评论，或者是私信我，虽然写的不好，但我就当这是记录自己成长的一种方式咯。（前提是我会了，如果不会我也会记下来，等会了的时候再更出来。）掘金个人主页 ，简书主页链接，csdn博客主页链接 ，github 。 参考文献： sass揭秘之变量 以上。2017.4.22]]></content>
      <categories>
        <category>sass</category>
      </categories>
      <tags>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单词太长导致自动换行，出现空白区域。——word-wrap和word-break]]></title>
    <url>%2F2017%2F10%2F11%2F%E5%8D%95%E8%AF%8D%E5%A4%AA%E9%95%BF%E5%AF%BC%E8%87%B4%E8%87%AA%E5%8A%A8%E6%8D%A2%E8%A1%8C%EF%BC%8C%E5%87%BA%E7%8E%B0%E7%A9%BA%E7%99%BD%E5%8C%BA%E5%9F%9F%E3%80%82%E2%80%94%E2%80%94word-wrap%E5%92%8Cword-break%2F</url>
    <content type="text"><![CDATA[写在前面：在写页面的时候，偶尔有时会遇到下图这两种情况，一种是单词过长时会溢出div，一种是直接换行，导致出现空白区域。这两个情景就需要word-wrap、word-break这两个属性出场来解决了。闲话不扯了，本文主要内容有：word-wrap和word-break属性介绍，使用方法，他们之间的区别，浏览器兼容性，demo链接。需要的朋友可以过来参考下，喜欢的可以点个赞，希望能对大家有所帮助。 应用场景： word-wrap和word-break是什么？在mozilla的官网上找到如下的解释： 经过翻译：word-wrap: css的 word-wrap 属性用来标明是否允许浏览器在单词内进行断句，这是为了防止当一个字符串太长而找不到它的自然断句点时产生溢出现象。 word-break: css的 word-break 属性用来标明怎么样进行单词内的断句。 何谓单词内断句？ 这个单词没有发生单词内断句的情况，这个单词太长了，溢出了容器的范围。 下面是发生了单词内断句的情况实例： 这里面分别使用了word-wrap：break-word;和word-break:break-all;这里可以看到，效果是一样的，下面再说说他们的区别。 word-wrap的属性介绍 word-wrap的浏览器支持情况： 语法：123/* 二选一 */word-wrap: normal;word-wrap: break-word; 解析：normal就是大家平常见得最多的正常的换行规则，break-word如果长单词超出了一行的长度的话，在一行中有可以换行的标点时就换行，实在没有可以换行的地方时，才在单词中间换行。（这句的解析入下图） 上图就是：一行中有可以换行的标点时就换行，实在没有可以换行的地方时，才在单词中间换行 word-break属性的属性介绍： 浏览器支持： 除了opera不支持以外，其他都支持（火狐也从不支持改为支持了）! 语法使用：1234/* 默认normal */word-break: normal;word-break: break-all;word-break: keep-all; 解析：几个关键字值的含义如下：normal 使用默认的换行规则。 break-all 允许任意非CJK(Chinese/Japanese/Korean)文本间的单词断行。(这里是CJK中文，日文，韩文的意思) keep-all不允许CJK(Chinese/Japanese/Korean)文本中的单词换行，只能在半角空格或连字符处换行。非CJK文本的行为实际上和normal一致。(一致性可看下图的demo效果) word-break:break-all和word-wrap:break-word之间的区别：其实可以从上述demo栗子中看出来： word-break:break-all碰到英文单词统统都换行，只要到了容器的边界就会换行，不浪费一点空间，一点空隙都不放过。 而word-wrap:break-word在一行中有可以换行点时就换行，实在没有可以换行的地方时，才在单词中间换行。 这里所说的换行点指的是：如空格，或CJK(Chinese/Japanese/Korean)(中文/日文/韩文)之类的，让这些换行点换行，至于对不对齐，好不好看，则不关心，因此，很容易出现一片一片牛皮癣一样的空白的情况。 后话：以上就是本文的内容了，其实大概分清他们的区别，以后碰到这类型问题，知道需要用哪个属性来解决就好了。 最后：因为我经常看不懂别人写的分享，所以个人写文比较偏小白，写的不好之处，欢迎指点。然后就是希望看完的朋友点个喜欢，也可以关注一下我，现在这阶段基本上每个月都不会少于十五篇文章（看到干货我也会进行分享）。码字不易，感谢支持！ps：目前待业，坐标北京，求推荐工作。然后希望我写哪方面的文章可以在底下评论，或者是私信我，虽然写的不好，但我就当这是记录自己成长的一种方式咯。（前提是我会了，如果不会我也会记下来，等会了的时候再更出来。）掘金个人主页 ，简书主页链接，csdn博客主页链接 ，github 。 参考链接： word-break:break-all和word-wrap:break-word的区别 你真的了解word-wrap和word-break的区别吗？ CSS3 word-wrap 属性 CSS3 word-break 属性]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于js、jq零碎知识点]]></title>
    <url>%2F2017%2F10%2F11%2F%E5%85%B3%E4%BA%8Ejs%E3%80%81jq%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[写在前面：本文都是我目前学到的一些比较零碎的知识点，也是相对偏一点的知识，这是第二篇。前后可能没有太大的相关性，需要的朋友可以过来参考下，喜欢的可以点个赞，希望对大家有所帮助。本文的受众是刚学前端，大手子可以跳过。 1.页面加载完成之后，才开始执行函数。123$(function() &#123;// 需要执行的js函数内容&#125;); 背景：碰到一个JQ很复杂的函数，上面简化了的整体格式，这跟自执行函数又不太一样，之前没见过这种写法，查了蛮久之后才找到这方面的内容，在这里分享一波。 jQuery 事件 -ready() 方法定义和用法当 DOM（文档对象模型） 已经加载，并且页面（包括图像）已经完全呈现时，会发生 ready 事件。ready() 函数规定当 ready 事件发生时执行的代码。ready() 函数仅能用于当前文档，因此无需选择器。 意思就是：当页面载入完毕之后就开始执行函数代码。允许使用以下三种语法： 语法 11$(document).ready(function) 语法 21$().ready(function) 语法 31$(function) js貌似也有一个这类型的方法，js方法如下： window.onload = function() {$(“table tr:nth-child(even)”).addClass(“even”); //这个是jquery代码}; js方法和jq方法的区别：当使用js方法的时候，会在整个页面的document全部加载完成以后执行。不幸的这种方式不仅要求页面的DOM tree全部加载完成，而且要求所有的外部图片和资源全部加载完成。更不幸的是，如果外部资源加载时间过长，例如图片需要很长时间来加载，那么这个js效果就会让用户感觉失效了，所以当这个情景下，使用这种方法的用户体验是非常差的。 使用jquery方法：就仅仅只需要加载所有的DOM结构，在浏览器把所有的HTML放入DOM tree之前就执行js效果，包括在加载外部图片和资源之前。 2.获取class和tag类型的dom节点，获取到的是一个对象数组背景：写代码的时候，因为之前做css习惯性的用class来命名，然后直接获取了class，tagname类名节点，赋值的时候一直出错，查了好久最后，知道了class和tag类型的节点，因为不唯一性，所以获取节点的时候，返回的是一个对象数组。 ps：赋值出错是因为，数组对象赋值时不能直接a=b，要a[index]=b，因为这里获取class，tagName的dom节点，浏览器不知道class和tag在html里面有多少个（class、tag可以有多个），所以默认生成的是一个对象数组，所以当赋值的时候，要有相应的下标，否则就会出错。 getElementsByClassName()w3c定义：getElementsByClassName() 方法返回文档中所有指定类名的元素集合，作为 NodeList 对象。NodeList 对象代表一个有顺序的节点列表。我们可通过节点列表中的节点索引号来访问列表中的节点(索引号由0开始)。 解决方式：因为id的唯一性质（同一个html里面只能取一个相同的id），没特殊情况最好用id命名，并且用id获取dom，这样不容易出错，就算写css习惯性的采用class，也可以再标签里面再加一段id=”名字”。 3.变量作用域，参数传递不进去。背景： 这种情况是作用域的问题，上面定义的变量是全局变量，在虽然是一个闭包，但是应该可以使用全局的变量，回一级一级往上找这个变量。这里不太清楚为什么会没有找到？ 然而，虽然不太清楚中间发生了什么，但是最后问题还是成功的解决了。 全局的window对象JavaScript中的任何一个全局函数或变量都是window的属性，可以是使用如下方法获取dom，并且操作dom。 栗子1：1234&lt;script type=&quot;text/javascript&quot;&gt; var name=&quot;这里是测试&quot;; document.write(window.name);//输出name的内容&lt;/script&gt; 实际应用如下： 应用场景：当你层次嵌套多层之后，取不到变量或对象的时候，就可以使用window全局对象的方法，来传递参数，使其成功连接。 找不到关于这方面的比较详细的资料，大伙儿就记住这个方法就好了。 换行符和占位符在字符串里面正常生效效果如图： 如图，占位符和换行符在字符串中正常生效，不会变成字符串。其他的我不知道，反正这两个亲测可行，个人觉得蛮神奇，一直以为会变成字符串。 评论区还有一种说法，意思是说在字符串中使用特殊符号，在输出的时候可以起效果，然而将特殊符号作为一个值来计算，或者是当做一个变量来使用的话，这种情况下就会出错！so，我们还是不要用特殊符号乱搞事情，输出的时候使用即可，而且好像应用场景也就输出的时候，应该没有什么其他场景应用的到了吧？ 大家可以看看： 后话：先记这些，以后学到了新的东西，累积起来，再发一些，这些都是我目前学到的一些比较零碎的知识点，也是相对偏一点的知识，再次强调一下是写给小白看的，让他们以后少踩些坑，小白们也多点参考资料。 最后：希望看完的朋友点个喜欢，也可以关注一下我，现在这阶段基本上每个月都不会少于十五篇文章（看到干货我也会进行分享）。写的不好之处，欢迎指点。码字不易，感谢支持！ps：目前待业，坐标北京，求推荐工作。然后希望我写哪方面的文章可以在底下评论，或者是私信我，虽然写的不好，但我就当这是记录自己成长的一种方式咯。（前提是我会了，如果不会我也会记下来，等会了的时候再更出来。）掘金个人主页 ，简书主页链接，csdn博客主页链接 ，github 。 以上。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>jq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[range滑块自定义样式，步骤详解以及实际应用]]></title>
    <url>%2F2017%2F10%2F11%2Frange%E6%BB%91%E5%9D%97%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F%EF%BC%8C%E6%AD%A5%E9%AA%A4%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[写在前面：本文的主要内容包括：type=”range”属性介绍，修改range默认css样式以及在js中的实际应用。本文面向前端小白，写的不好之处，请多多见谅。文末有demo链接，可以自行复制到本地进行试验。 相关：自定义 range radio select的样式滑轮，按钮，选择框 最终要实现的效果： 步骤：1.range属性相关介绍2.搭建html结构；3.css样式修改，包括给滑动轨道添加样式、给滑块添加样式；4.添加相关js代码实现应用效果;5.关于浏览器兼容。 在html里面输入如下内容，即可使用：1&lt;input type=&quot;range&quot;&gt;//这是最粗糙的使用方式 range在各个浏览器中的默认样式： range属性相关：range 输入类型用于应该包含指定范围值的输入字段。range 类型显示为滑块。您也可以设置可接受数字的范围限制：1&lt;input type=&quot;range&quot; name=&quot;points&quot; min=&quot;1&quot; max=&quot;10&quot; /&gt;//max为最大的值，min为最小的值 html5 range 类型的限定： HTML DOM Input Range 对象（js获取dom） 搭建html结构：1234567891011121314&lt;div class=&quot;js-2-1section3&quot;&gt; &lt;div class=&quot;js-2-1section3-div1&quot;&gt; &lt;span class=&quot;js-2-1section3-div1-span1&quot;&gt;玩家人数&lt;/span&gt; &lt;input type=&quot;text&quot; class=&quot;player-num&quot; id=&quot;player&quot; value=&quot;6&quot; max=&quot;18&quot; min=&quot;6&quot; onblur=&quot;on_change()&quot;&gt; &lt;!--onblur是当对象失去焦点的时候执行的函数--&gt; &lt;span class=&quot;js-2-1section3-div1-span1&quot;&gt;人&lt;/span&gt; &lt;/div&gt;&lt;!--上面这部分是玩家人数方框的html--&gt; &lt;div class=&quot;js-2-1section3-div2&quot;&gt; &lt;button class=&quot;btn-sub&quot; id=&quot;btnSub&quot; onclick=&quot;less()&quot; &gt;&lt;/button&gt;&lt;!--减value的按钮--&gt; &lt;input type=&quot;range&quot; class=&quot;slider-block&quot; id=&quot;slider&quot; max=&quot;18&quot; min=&quot;6&quot; step=&quot;1&quot; value=&quot;6&quot; onchange=&quot;moveChange()&quot;&gt; &lt;!--onchange是当对象发生变化时执行的函数--&gt; &lt;button class=&quot;btn-add&quot; id=&quot;btnAdd&quot; onclick=&quot;plus()&quot;&gt;&lt;/button&gt;&lt;!--加value的按钮--&gt; &lt;/div&gt;&lt;/div&gt; 解析：1.考虑到文章篇幅，html其他标签自行补全。 2.上面中，代码注释已经注释的很清楚了，不明白的多看几遍代码，然后也可以百度一下相关属性之类的。 3.滑块里面设置value=”6”的作用是浏览器进入时候滑块在最小值，也就是最左侧的地方，否则默认在中间 4.step=”1”意思是，滑块每次动态改变的数值。 5.关于代码中js部分，还没学js的小伙伴们，可以跳过，不影响修改滑块的默认样式的。 css样式修改：下面是玩家人数的css样式（不重要，可以跳过）：1234567891011121314151617181920212223242526272829303132333435body&#123; width: 50%; margin:5rem auto 0;&#125;div&#123; margin: 2rem;&#125;.js-2-1section3&#123; background: #fff;&#125;.js-2-1section3-div1&#123; margin-left: 2rem;&#125;.player-num&#123; font-size: 1.8rem; margin:0 0.6rem; background: #f4f5f5; padding: 0.2rem 0.6rem; color: gold; width: 9%; border: none; outline: none;&#125;span&#123; display: inline-block; font-size: 1.8rem; color: #444;&#125;.js-2-1section3-div2&#123; display: flex; justify-content: space-around; align-items: center; padding: 1.6rem 0;&#125;/*上面是玩家人数的css样式*/ 修改滑块样式的css代码(重点)：12345678910111213141516171819202122232425262728293031323334353637383940414243 #slider&#123; /*设置滑块下面那条线的样式*/ outline: none; /*去掉点击时出现的外边框*/ -webkit-appearance: none; -moz-appearance: none; appearance: none; /*这三个是去掉那条线原有的默认样式，划重点！！*/ width: 30%; height: 0.3rem; background: orange; /*这三个是设置滑块下面那条线的样式*/ &#125; input[type=&quot;range&quot;]::-webkit-slider-thumb &#123; /*::-webkit-slider-thumb是代表给滑块的样式进行变更*/ -webkit-appearance: none; -moz-appearance: none; appearance: none; /*//这三个是去掉滑块原有的默认样式，划重点！！*/ -webkit-box-shadow:0 0 2px ; /*设置滑块的阴影*/ width: 2.6rem; height:1.6rem; background: url(&quot;images/js2-d_03.png&quot;); background-size: cover; /*//这几个是设置滑块的样式*/ &#125; &lt;!--上面是修改滑块和滑块轨道的样式，下面是左右两边按钮的css样式--&gt; .btn-sub&#123; /*这里是左边减按钮的css样式*/ outline: none; border: none; cursor: pointer; background: url(&quot;images/js2-f_03.png&quot;); background-size: 100%; width: 1.8rem; height: 1.8rem; &#125; .btn-add&#123; /*这里是右边+按钮的css样式*/ outline: none; border: none; cursor: pointer; background: url(&quot;images/js2-e_03.png&quot;) no-repeat; background-size: 100%; width: 1.8rem; height: 1.8rem; &#125;&lt;!--css代码写的有点乱，见谅啊。--&gt; 解析：1.代码注释里面已经很清楚了，不清楚多看几遍代码。2.文末有demo链接，可以自行复制到本地进行试验。 以上是修改css样式到上面放的图片效果。 扩展：使用js完成实际应用12345678910111213141516171819202122232425262728293031323334353637383940 var oPlayerNum = document.getElementById(&quot;player&quot;);//玩家总人数var osliderBlock = document.getElementById(&quot;slider&quot;);//滑块的值function on_change() &#123; if (oPlayerNum.value &gt;= 6 &amp;&amp; oPlayerNum.value &lt;= 18) &#123;//设置方框里面玩家人数范围 osliderBlock.value=oPlayerNum.value ;//将玩家总人数赋值给滑块的值，实现动态变化 &#125; else &#123; alert(&quot;请输入正确的人数6~18&quot;); oPlayerNum.value=6; osliderBlock.value=6;//人数超出范围的话，弹出警告框，并且将方框和滑块的值重置为6 &#125;&#125;function moveChange() &#123;// 滑块的值改变，运行这个函数 oPlayerNum.value=osliderBlock.value; //滑块的值改变的话，滑块的值赋值给方框，实现动态变化&#125;function less() &#123; oPlayerNum.value--; //减的按钮，减掉玩家总人数的值 if (oPlayerNum.value&lt;6)&#123; alert(&quot;人太少了，再找几个小伙伴来吧&quot;); oPlayerNum.value=6; //人数超出范围的话，弹出警告框，并且将方框和滑块的值重置为6 &#125; else &#123; osliderBlock.value=oPlayerNum.value;// 将玩家人数赋值给滑轮的值 &#125;&#125;function plus() &#123; oPlayerNum.value++; //加的按钮，减掉玩家总人数的值，上面的值已经相互关联了，所以方框的值改变，滑块的值也会改变 if (oPlayerNum.value&gt;18)&#123; alert(&quot;人太多了，可以分一批人再开一局&quot;); oPlayerNum.value=18; //人数超出范围的话，弹出警告框，并且将方框和滑块的值重置为18 &#125; else &#123; osliderBlock.value=oPlayerNum.value;// 将玩家人数赋值给滑轮的值 &#125;&#125; ps：1.特地重新再打一遍注释，注释里面说的蛮清楚了，还没学js的小伙伴别灰心，先mark起来，等以后学会了，再回头看看。2.文末有demo链接，可以自行复制到本地进行试验。 关于浏览器兼容的问题：还未完成的效果，滑块填充效果。ps：关于浏览器兼容这块儿，还没研究好（下面有篇文章是讲浏览器兼容的）。以上只针对谷歌浏览器，因为range是html5新出的属性，w3c还没出标准属性，各个浏览器的方法不一样，这块儿有点麻烦。但我记在笔记里面了，今后研究清楚了，再回来更文。 关于滑块的填充效果，各个浏览器都不一样Chrome浏览器中不支持直接设置进度条，要借助js。而在IE 9以上的浏览器中可以使用::-ms-fill-lower 和 ::-ms-fill-upper来自定义进度条；在Firefox浏览器中则可以通过::-moz-range-progress来自定义；今天下午研究了一阵子，只弄出了一个ie的填充效果，没研究清楚，可能过段时间会再回来更新。（有兴趣的小伙伴可以研究一下，相互交流交流。） 以下是I兼容E浏览器的滑块123456789101112131415/*以下是I兼容E浏览器的滑块，还有一些问题，不过现在没空再弄了。等到有空了再解决清楚。*/ input[type=range]::-ms-fill-lower &#123;//::-ms-fill-lower这是ie兼容range的属性写法下面那个同理 /*进度条已填充的部分*/ height: 22px; border-radius: 10px; /*background: black;*/ background: linear-gradient(to right, #059CFA, white 100%, white); &#125; input[type=range]::-ms-fill-upper &#123; /*进度条未填充的部分*/ height: 22px; border-radius: 10px; background: red; &#125; 这里有篇关于range的文章，里面有浏览器兼容的内容，我没弄清楚：自定义(滑动条)input[type=”range”]样式 range-demo链接：https://obkoro1.github.io/article-demo/diy-style/range-diy.html 后话：昨天说好的要详细更新，range、radio、select这三类的文章，今天如约更好了range部分，后面几天应该还会持续更文。不说了，要打球去了^_^。 最后：希望看完的朋友点个喜欢，也可以关注一下我，现在这阶段基本上每个月都不会少于十五篇文章（看到干货我也会进行分享）。写的不好之处，欢迎指点。码字不易，感谢支持！ps：目前待业，坐标北京，求推荐工作。然后希望我写哪方面的文章可以在底下评论，或者是私信我，虽然写的不好，但我就当这是记录自己成长的一种方式咯。（前提是我会了，如果不会我也会记下来，等会了的时候再更出来。）掘金个人主页 ，简书主页链接，csdn博客主页链接 ，github 。 以上。2017.4.16]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(干货)css自定义 range radio select的样式滑轮，按钮，选择框]]></title>
    <url>%2F2017%2F10%2F11%2F%E5%B9%B2%E8%B4%A7-css%E8%87%AA%E5%AE%9A%E4%B9%89-range-radio-select%E7%9A%84%E6%A0%B7%E5%BC%8F%E6%BB%91%E8%BD%AE%EF%BC%8C%E6%8C%89%E9%92%AE%EF%BC%8C%E9%80%89%E6%8B%A9%E6%A1%86%2F</url>
    <content type="text"><![CDATA[写在前面：之前踩坑css的时候，遇到滑轮，按钮，选择框这类型的东西，为了页面效果，总是需要自定义他们的样式，而不使用他们的默认样式。当时写的时候，我也是蛮头疼的，弄了个demo，链接在下面。对此做个总结。本文是面向前端小白的，大手子可以跳过，写的不好之处多多见谅。 额，今天就先大概的将代码贴上来，考虑到篇幅的问题，就先写一下三个的实现方式，一般也都看得懂，代码注释的非常详细。因为细分下来内容也很多，准备之后再将如何实现的方式，属性，优化以及如何兼容各个浏览器的方式一步步的写出来。 最终效果： 如何使用这些属性？用法很简单，如下所示： 123&lt;input type=&quot;range&quot;&gt;//滑动条&lt;input type=&quot;radio&quot;&gt;//按钮&lt;select&gt;//选择框 input type=”range”样式修改： html content1234&lt;div&gt; &lt;input type=&quot;range&quot; class=&quot;slider-block&quot; id=&quot;slider&quot; max=&quot;18&quot; min=&quot;6&quot; step=&quot;1&quot; value=&quot;6&quot;&gt; &lt;!--主要是一个type=&quot;range&quot;属性,其他的会在细分的文章里面讲出来--&gt;&lt;/div&gt; csscontent123456789101112131415161718192021.slider-block&#123; outline: none; /*去掉点击时出现的外边框*/ -webkit-appearance: none; -moz-appearance: none; appearance: none; /*这三个是去掉那条线原有的默认样式，划重点！！*/ width: 30%; height: 0.3rem; background: orange; /*这三个是设置滑块下面那条线的样式*/ &#125; input[type=&quot;range&quot;]::-webkit-slider-thumb &#123; /*::-webkit-slider-thumb是代表给滑块的样式进行变更*/ -webkit-appearance: none; -moz-appearance: none; appearance: none; /*//这三个是去掉滑块原有的默认样式，划重点！！*/ -webkit-box-shadow:0 0 2px ;/*设置滑块的阴影*/ width: 2.6rem; height:1.6rem; background: url(&quot;images/js2-d_03.png&quot;); background-size: cover; /*//这几个是设置滑块的样式*/ &#125; //文章下面有demo链接 文章下面有demo链接代码里面注释关键点都写了，还不能理解的，可以看下demo。 input type=”radio”修改默认样式 html content123456789&lt;form class=&quot;task10-main-box-shape&quot; method=&quot;post&quot; action=&quot;#&quot;&gt; &lt;!--//表单元素基本上都要加form，传送的参数的方式，传递的位置，这是一个好习惯--&gt;&lt;div&gt; &lt;input id=&quot;shape1&quot; name=&quot;box-shape&quot; type=&quot;radio&quot; checked=&quot;checked&quot; value=&quot;shape1&quot; /&gt; &lt;!--checked属性是当页面载入的时候选择这个按钮，value是传送的值--&gt; &lt;label for=&quot;shape1&quot;&gt;对口箱&lt;/label&gt;&lt;!--/加label标签点击这个字的时候，可以选中按钮--&gt;&lt;/div&gt;&lt;/form&gt; css样式这里相对难点，但我注释的已经很多了。12345.task10-main-box-shape input[type=&quot;radio&quot;]&#123; display: none; /*隐藏默认按钮的样式,这跟其他隐藏默认按钮的样式的方法不一样，注意一下*/&#125; 12345678910111213141516171819202122232425262728293031.task10-main-box-shape label&#123; /*这里是设置文字的样式*/ display: inline-block; cursor: pointer; position: relative; padding-left: 3rem; margin-right: 6rem; font-size: 1.8rem; color: rgb(102,102,102); &#125; .task10-main-box-shape label:before &#123; /*这里是没被选中时候按钮的样式*/ content: &quot;&quot;; /*将要自定义的东西设置为空的字符串，就可以往里面随意加定义的样式了*/ display: inline-block; background-color: #FFFFFF; /*设置背景*/ padding:0.45em; /*撑开背景，就是中间那块白色的*/ border: 1px solid gray; margin-right: 10px; position: absolute; left: 0; bottom: 3px; border-radius: 50%; /*设置圆角*/ &#125; input[type=radio]:checked + label:before &#123;/*按钮被选中之后的样式，多了一个checked*/ font-size: 1px; color: #FFFFFF; border:0.7rem solid rgb(29,122,217); /*设置按钮样式*/ &#125; select修改默认样式### html cantent 1234567&lt;div&gt; &lt;select class=&quot;task10-main-box-row2-select&quot;&gt; &lt;option&gt;查看详情&lt;/option&gt; &lt;option&gt;我也不知道&lt;/option&gt; &lt;option&gt;详情是什么&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; css cantent123456789101112.task10-main-box-row2-select&#123; font-size: 1.6rem; color: rgb(153,153,153); padding: 0.3% 2% 0.3% 1%; margin: 0; /*这里是选择框里面的样式*/ background: url(&quot;images/task10-d_03.png&quot;) no-repeat 97%; /*97%是设置图片，也就是三角形的位置*/ background-size:20%; /*背景图片的尺寸*/ appearance:none; -moz-appearance:none; -webkit-appearance:none; /*这三个是隐藏默认样式*/ &#125; ps:css样式写的有点乱，各位看官，将就着看看，下面有demo链接。 总结总的来说这类型的首先需要将样式隐藏掉，然后再自行添加需要的类型，但是有些隐藏样式的方式也不同，有些是这种，appearance:none; -moz-appearance:none; -webkit-appearance:none;像radio按钮的，反而是display:none;这种类型的。还有的样式可以写的很好看，比如滑块怎么移动的时候，填充条跟着移动。会的大家都会，要琢磨的精，会别人不会的，才是你身价所在。 后话：连续一个多星期不睡午觉，终于熬不住了。感觉身体被掏空，以后就改为下午的时候更文。因为一些事情耽搁了，直到晚上才弄好。下面几天会逐渐把这几个如何实现的方式，属性，优化以及如何兼容各个浏览器的方式一步步的写出来，链接会放在文末的。 假装这里有三个链接。range滑块自定义样式，步骤详解以及实际应用 最后：希望看完的朋友点个喜欢，也可以关注一下我，现在这阶段基本上每个月都不会少于十五篇文章（看到干货我也会进行分享）。码字不易，感谢支持，感激不尽！ps：目前待业，坐标北京，求推荐工作。然后希望我写哪方面的文章可以在底下评论，或者是私信我，虽然写的不好，但我就当这是记录自己成长的一种方式咯。（前提是我会了，如果不会我也会记下来，等会了的时候再更出来。）掘金个人主页 ，简书主页链接，csdn博客主页链接 ，github 。 demo链接：https://obkoro1.github.io/article-demo/diy-style/diyStyle.html 以上，2017.4.16.]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>range  radio select css样式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 CSS 的零碎知识点]]></title>
    <url>%2F2017%2F10%2F11%2F%E5%85%B3%E4%BA%8E-CSS-%E7%9A%84%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[写在前面：这篇文章是本人学习过程中遇到css的零碎知识点2（就是以前自己不知道的），我都记下来了，需要的朋友可以过来参考下，喜欢的可以点个赞，希望对大家有所帮助。本文的受众是前端小白，大手子可以跳过。 1.scss编译css文件使用中文注释出现乱码： 在文件开头部分加上：@charset “UTF-8”;注意：这里必须要加在文件开头部分，加在文件中部和结尾部分是无效的。 2.HTML input标签的 maxlength 属性定义和用法：maxlength 属性规定输入字段的最大长度，以字符个数计。maxlength 属性与 input type=”text” 或 input type=”password” 配合使用。 注意：这里所说的以字符个数计算，中文是占两个字符，字母和数字都是占一个字符，但是我实际使用过程中，input里面无论中文，英文字母，数字，都可以输入相同长度，也就是说这是一个bug？？？ 上面是我先前的理解，经过评论区朋友的指点，发现原先的理解事错的，回来更正一下。 字节不等同于字符，字节不等同于字符，字节不等同于字符， 汉字占两个字节，但是只占了一个字符，所以属性没毛病，是我之前理解错了这里有一个用JS限制文本框所输入字符串的最大字节数的办法有兴趣可以看一下：http://blog.sina.com.cn/s/blog_815611fb0101jkah.html ps：其实我也不知道有什么用，可能有些场景对这些规定的比较死，才能用的到，你们就蛮看一下。。 3.背景图片如何居中：background：url center no-repeat；只要在这里加个center就可以使背景图片垂直水平居中了 实际上这里是用了 background-position属性。 background-position定义和用法 4.css样式最好不要把宽度定死了，这样会导致页面缩小的时候超出范围。这个问题太low，我就不放栗子了。 说明：当你某个div或者head，body哪里宽度定死了之后，查看手机自适应的时候，就很容易出现横向滚动条，是因为页面缩小之后，你宽度定死的那个部分没有跟随其他部分按照相同比例缩小，虽然那个部分也是缩小了，但是缩小的比例不对。 5.字体间距letter-spacing 所有浏览器都支持 letter-spacing 属性。 蛮看一下，稍微记下，这个还是蛮偏的 使用场景：有时候留白部分太多，看起来空空荡荡的，或者字体过小，不易阅读，此时可以使用这个属性。允许使用负值，有时候字体之间的距离也会更大，这时使用负值会让字母之间挤得更紧。 后话：先记这些，以后学到了新的东西，累积起来，再发一些，这些都是我写页面期间遇到的问题，再次强调一下是写给小白看的，让他们以后少踩些坑，小白们也多点参考资料。 最后：希望看完的朋友点个喜欢，也可以关注一下我，现在这阶段基本上每个月都不会少于十五篇文章（看到干货我也会进行分享）。码字不易，感谢支持，感激不尽！ps：目前待业，坐标北京，求推荐工作。然后希望我写哪方面的文章可以在底下评论，或者是私信我，虽然写的不好，但我就当这是记录自己成长的一种方式咯。（前提是我会了，如果不会我也会记下来，等会了的时候再更出来。）掘金个人主页 ，简书主页链接，csdn博客主页链接 ，github 。 以上。2017.4.14.]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js原生dom对象和jQuery对象可以混合使用吗？]]></title>
    <url>%2F2017%2F10%2F11%2Fjs%E5%8E%9F%E7%94%9Fdom%E5%AF%B9%E8%B1%A1%E5%92%8CjQuery%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[写在前面：本文主要内容包括js原生dom对象和jQuery对象的区别，联系，相互转换，以及踩坑经历。情况是这样的，今天在实现一个js验证码的功能，需要获取input的值，然后我用jQuery的方法获取到了dom节点，然后用原生js获取input的值，结果就出错了，好在后来场外求助启宸欧巴在师兄的帮助下发现问题所在，并成功解决。将今天的踩坑经历，以及网上查阅的资料，集合成一篇文章，分享一波。 Dom原生对象和jQuery对象的区别：1.jquery选择器得到的jquery对象和标准的 javascript中的document.getElementById()取得的dom对象是两种不同的对象类型，两者不等价； 注：js原生获取的dom是一个对象，jQuery对象就是一个数组对象，其实就是选择出来元素的数组集合。所以说他们两者是不同的对象类型不等价。 2.jQuery无法使用DOM对象的任何方法，同理DOM对象也不能使用jQuery里的方法. 乱使用会报错。例如（文章下面有两个踩坑经历。）： $(“#id”).html(); document.getElementById(“id”).innerHTML; 意思是指：获取ID为id的元素内的html代码。这两段代码结果相同，但中间的取值过程不同。 即：$(“#id”).innerHTML、document.getElementById(“id”).html()之类的写法都是错误的。 注：jQuery是从js衍生出来的，师出同源，但是jQuery是经过一系列操作之后，将其封装成了一个个不同的方法，学习jQuery开始就应当树立正确的观念，分清jQuery对象和DOM对象之间的区别，之后学习 jQuery就会轻松很多的。 js-dom对象和jQuery对象相互转换： jQuery对象转成DOM对象—两种转换方式：[index]和.get(index) 1、jQuery对象是一个数据对象，通过[index]的方法（就是通过下标索引寻找dom，进行操作） 如：var $v = $(“#v”) ; //jQuery对象 var v = $v[0]; //DOM对象 alert(v.checked) //检测这个checkbox是否被选中 2、jQuery本身提供，通过.get(index)方法 如：var $v = $(“#v”); //jQuery对象 var v = $v.get(0); //DOM对象 alert(v.checked) //检测这个checkbox是否被选中 注：其实两者都是同一个道理，即通过索引下标的方式，来寻找dom进行转换。 DOM对象转成jQuery对象: 对于DOM对象，只需用$()把DOM对象包装起来，就可得到jQuery对象 如：var v=document.getElementById(“v”); //DOM对象 var $v=$(v); //jQuery对象 踩坑经历：今天出错的问题：出错代码：12var randomCode=$(&quot;#js5-authCode&quot;).value;//用jq获取dom，用js获取值。//console的时候，这里会出现undefined。 正确的应该：1var randomCode=$(&quot;#js5-authCode&quot;).val();//这里的val()是jq的一种方法。 再举个栗子：$(“#id”).innerHTML）、document.getElementById(“id”).html()。 出错点：第一个是用jq获取dom，然后用js操作。第二个是用js获取dom，然后用jq进行操作 总结框架之类的东西都是封装好了的一个个函数，中间会经历一些操作，中间的取值过程也是不同，所以我们写代码的时候尽量使用同一种方式来写，不能混合使用，大概就是酱样子。参考资料：Js - Dom原生对象和jQuery对象的联系、区别、相互转换DOM对象与jQuery对象的理解与分析 最后：希望看完的朋友点个喜欢，也可以关注一下我，现在这阶段基本上每个月都不会少于十五篇文章（看到干货我也会进行分享）。码字不易，感谢支持，感激不尽！ps：目前待业，坐标北京，求推荐工作。然后希望我写哪方面的文章可以在底下评论，或者是私信我，虽然写的不好，但我就当这是记录自己成长的一种方式咯。（前提是我会了，如果不会我也会记下来，等会了的时候再更出来。）掘金个人主页 ，简书主页链接，csdn博客主页链接 ，github 。 以上。2017.4.13]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你知道渐进增强和优雅降级吗？[css3兼容性写法]]]></title>
    <url>%2F2017%2F10%2F11%2F%E4%BD%A0%E7%9F%A5%E9%81%93%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA%E5%92%8C%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7%E5%90%97%EF%BC%9F-css3%E5%85%BC%E5%AE%B9%E6%80%A7%E5%86%99%E6%B3%95%2F</url>
    <content type="text"><![CDATA[写在前面：在前端开发的过程中，如果有注意的话，发现有些写css3属性时，兼容性的写法顺序不太一样，比如transition属性，有些把transition放在前面有些是放在后面，这就引出了两个概念：优雅降级和渐进增强。 写法栗子：123456789101112.transition &#123; /*渐进增强写法*/ -webkit-transition: all .5s; -moz-transition: all .5s; -o-transition: all .5s; transition: all .5s;&#125;.transition &#123; /*优雅降级写法*/ transition: all .5s; -o-transition: all .5s; -moz-transition: all .5s; -webkit-transition: all .5s;&#125; 渐进增强和优雅降级概念出现的原因：翻看进度条，会发现渐进增强和优雅降级这两个概念是在 CSS3 出现之后火起来的。由于低级浏览器不支持 CSS3，但是 CSS3 特效太优秀不忍放弃，所以产生了的一种解决方式在高级浏览器中使用CSS3，而在低级浏览器只保证最基本的功能。 何谓渐进增强：渐进增强（Progressive Enhancement）：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。 何谓优雅降级：优雅降级（Graceful Degradation）：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。 支持渐进增强和优雅降级背后的思维是什么：两者之间的微妙差别：在本质上：“它们是看待同种事物的两种观点”，“优雅降级”和“渐进增强”的目的都是关注不同浏览器下的不同体验，但是它们侧重点不同，所以导致了工作流程上的不同。 渐进增强观点认为应关注于内容本身。请注意其中的差别：我甚至连“浏览器”三个字都没提。内容是我们建立网站的诱因。有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得渐进增强成为一种更为合理的设计范例。这也是它立即被 Yahoo! 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。 优雅降级观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。 别说话，看图： 工作流程上面的区别：1.渐进增强（progressive enhancement）：一开始只构建站点的最少特性，保证他们的内容，然后不断地对版本较高的浏览器追加不同的功能 2.优雅降级（graceful degradation）：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，就是针对版本较低的浏览器进行测试和修复 ps： 降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带; 广义和狭义：1.广义：其实要定义一个基准线，在此之上的增强叫做渐进增强，在此之下的兼容叫优雅降级。 2.狭义：渐进增强一般说的是使用CSS3技术，在不影响老浏览器的正常显示与使用情形下来增强体验，而优雅降级则是体现html标签的语义，以便在js/css的加载失败/被禁用时，也不影响用户的相应功能。 栗子：渐进增强的例子： 1.来自张鑫旭大神的栗子。123456789101112.transition &#123; /*渐进增强写法*/ -webkit-transition: all .5s; -moz-transition: all .5s; -o-transition: all .5s; transition: all .5s;&#125;.transition &#123; /*优雅降级写法*/ transition: all .5s; -o-transition: all .5s; -moz-transition: all .5s; -webkit-transition: all .5s;&#125; *前缀CSS3（-webkit- / -moz- / -o-）和正常CSS3在浏览器中的支持情况是这样的： 1.很久以前：浏览器前缀CSS3和正常CSS3都不支持；2.不久之前：浏览器只支持前缀CSS3，不支持正常CSS3；3.现在：浏览器既支持前缀CSS3，又支持正常CSS3；4.未来：浏览器不支持前缀CSS3，仅支持正常CSS3. ps：从这里可以引申到其他有前缀的css3的属性，不要局限在这个属性里。优雅降级的例子： 4.假如你写了一个表单，没有用到input type=”submit”表单元素，用了一个a标签的click事件做提交，但如果Javascript被禁用了怎么办？使用如下的文档结构，就可以在javascript被禁用时，依然可以提交。 1234&lt;form&gt; &lt;input type=&quot;text&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 优雅降级需要正确地体现HTML标签的语义，符合“浏览器的预期”。让你的网页在各种情况—下——包括降级（javascript被禁用，css传输失败等等）的情形都可以运作良好。这是我理解的优雅降级的意义。 在网页布局中如何选择？如果软件开发的预算和时间充足，就不存在抉择的问题，可以两者都调整到一个最佳状态，而不用权衡，做选择题了。然而现实很残酷，要么开发周期短，要么开发预算少，或者二者兼而有之，这个时候该如何抉择？就我个人而言，讲讲我的观点。 分析使用你客户端程序的版本比例。如果低版本用户居多，当然优先采用渐进增强的开发流程； 如果高版本用户居多，为了提高大多数用户的使用体验，那当然优先采用优雅降级的开发流程。 大多数公司是怎么处理这个问题的：绝大多数的大公司都是采用渐进增强的方式，因为业务优先，提升用户体验永远不会排在最前面。 例如：新浪微博网站前端的更新，拥有这种亿级用户的网站，绝对不可能追求某个特效而不考虑低版本用户可不可用，一定是确保低版本到高版本的可访问性，再去渐进增强，采用新功能给高版本用户提供更好的用户体验。 但也不是没有反例。如果你开发的是一款面向青少年的软件（或网站） 你知道这个群体的人总是喜欢尝试新事物，总是喜欢酷炫的特效，总是喜欢把它们的软件更新到最新版本（而不像我们老一辈的用户）。面对这种情况，渐进增强的开发流程实为上选。 PS： 其实优雅降级和渐进增强都是页面的加分项，是针对技术的一种形而上的要求。保证尽可能多的用户都能正常使用网站是第一步，在此之上才需要考虑降级的极端情形和现代浏览器的体验增强。 参考来自： 渐进增强和优雅降级之间的有什么不同？需警惕CSS3属性的书写顺序渐进增强 VS 优雅降级你能描述一下渐进增强和优雅降级之间的不同吗?如果提到了特性检测，可以加分。 最后：希望看完的朋友点个喜欢，也可以关注一下我，现在这阶段基本上每个月都不会少于十五篇文章（看到干货我也会进行分享）。码字不易，感谢支持，感激不尽！ps：目前待业，坐标北京，求推荐工作。然后希望我写哪方面的文章可以在底下评论，或者是私信我，虽然写的不好，但我就当这是记录自己成长的一种方式咯。（前提是我会了，如果不会我也会记下来，等会了的时候再更出来。）**掘金个人主页 ，简书主页链接，csdn博客主页链接 ，github 。 以上。2017.4.12]]></content>
      <categories>
        <category>css3</category>
      </categories>
      <tags>
        <tag>渐进增强和优雅降级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ps切图实用小技巧、图片格式的区别及相关内容]]></title>
    <url>%2F2017%2F10%2F11%2Fps%E5%88%87%E5%9B%BE%E5%AE%9E%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7%E3%80%81%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[写在前面之前写了两篇前端图片相关的内容（前端ps切图方法，图文详细,css sprite雪碧图制作，使用以及相关，图文gif），本文是面向前端小白的，搜集整理的一些切图技巧，及其相关内容。 关于版本：推荐pscc2017版，一些老版本很多新功能没有，会影响到效率的。（目前2017/4/11） 基本设置先要调整工作区域的布局。 1.选择“窗口”——把“信息”，“图层”，“历史记录”，“颜色”面板打开，其他的可以先关闭了，在切图的工作中其他的基本用不到，这个很简单的，打几个勾就可以了，如下图所示： 2.调整好面板之后，选择“窗口”——“工作区”——“新建工作区”，将当前的工作布局保存起来，并命个名，之后下次打开的时候就会直接出现你调整好的工作布局，否则的话你每次重新打开ps的时候都要重新设置。 ps：就算有别人弄乱了你的面板也可以直接通过“窗口”——“工作区”——选择你之前保存的工作布局。 设置标尺坐标 操作gif： 还有其他的一些设置： 文件-新建–：初始化预设设置1920x2000，72分辨率，8位色图，背景透明色 然后保存起来。后续可以选择新建模版 视图/显示/智能参考线以及视图/字符，这两个都要选上； ps界面中有菜单栏、属性栏、工具栏、面板、工作区： 测量 、取色哪些要测量？标签的宽度、高度、内边距、边框、定位、文字大小、行高、背景图位置等等，凡是需要数值型，都要进行测量。 使用什么方式：下面弄了一个矩形选择框的例子，如果想要更精确的话，直接使用标尺工具也可以。 测量宽高的两种方式：标尺测量的方法：矩形选择框测量的方法： 颜色取色技巧：QQ截图的方式：截图的时候，鼠标移动到哪里，下面就有一个rgb。（在ps中也是一样，鼠标移动信息栏就会有对应的rgb）ps拾色器获得 ： 注意要把画布尽量放大，来减少我们测量的误差。 关于png、jpg、gif三种图片格式的区别：JPG的特性1、支持摄影图像或写实图像的高级压缩，并且可利用压缩比例控制图像文件大小。2、有损压缩会使图像数据质量下降，并且在编辑和重新保存JPG格式图像时，这种下降损失会累积。3、JPG不适用于所含颜色很少、具有大块颜色相近的区域或亮度差异十分明显的较简单的图片。 PNG的特性1、能在保证最不失真的情况下尽可能压缩图像文件的大小。2、PNG用来存储灰度图像时，灰度图像的深度可多到16位，存储彩色图像时，彩色图像的深度可多到48位，并且还可存储多到16位的α通道数据。3、对于需要高保真的较复杂的图像，PNG虽然能无损压缩，但图片文件较大，不适合应用在Web页面上。 什么时候应该使用PNG具备以下条件的图像更适合用PNG8格式进行存储： 1、图像上颜色较少，并且主要以纯色或者平滑的渐变色进行填充。2、具备较大亮度差异以及强烈对比的简单图像（如“立刻购买”按钮中的背景和文字）。 对于写实的摄影图像或是颜色层次非常丰富的图像采用JPG格式的图片格式保存一般能达到最佳的压缩效果。 这篇文章写得非常详细，有兴趣的要看一下：png、jpg、gif三种图片格式的区别快捷键1.快速选中图层用ctrl+鼠标右键2.安住空格键鼠标变成一只手拖拽图片3.alt+鼠标滚轮可以放大或者缩小区域4.ctrl+h隐藏所有的参考线 5.h,鼠标移动文件，t文字工具，i吸管工具，移动工具，任何时候按v，就可以回到移动工具6.导出切片：alt+shift+ctrl+s（文件-存储为web所用格式） 踩坑经历：自动化切图，文件–脚本–图层保存为文件（这个时候要注意之前的保存为web格式文件时是保存了所有切片，而不是仅用户切片，不然会导致一直搜索过滤图层，半天没反应，而且一直谭警告窗，要一直点）意思就是保存图层的时候要保存自己选中的切片。 快捷键：https://zhidao.baidu.com/question/522391139.html 压缩图片ps切出来的图片一般文件都比较大：这里有一个压缩图片很神奇的网站（有墙，攻城狮应该都会科学上网）： https://tinypng.com/ 一般网站文件目录PSD切图（项目文件目录）project：-admin(后台)-static（所有资源）-css（所有子文件都可以分子文件夹，方便管理，层级不建议太多）common.css/reset.css/yemian.css-images（可以按页面主题来）-js(预定义的，引入的，common.js)-font-pulgs-前台页面-其他单独文件 参考：写给前端小白的切图技巧开始前端开发（PhotoShop切图）png、jpg、gif三种图片格式的区别 最后：希望看完的朋友点个喜欢，也可以关注一下我，现在这阶段基本上每个月都不会少于十五篇文章（看到干货我也会进行分享）。码字不易，感谢支持，感激不尽！ps：目前待业，坐标北京，求推荐工作。然后希望我写哪方面的文章可以在底下评论，或者是私信我，虽然写的不好，但我就当这是记录自己成长的一种方式咯。（前提是我会了，如果不会我也会记下来，等会了的时候再更出来。）掘金个人主页 ，简书主页链接，csdn博客主页链接 ，github 。 以上。2017.4.11]]></content>
      <categories>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>ps切图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css sprite雪碧图制作，使用以及相关，图文gif]]></title>
    <url>%2F2017%2F10%2F11%2Fcss-sprite%E9%9B%AA%E7%A2%A7%E5%9B%BE%E5%88%B6%E4%BD%9C%EF%BC%8C%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%EF%BC%8C%E5%9B%BE%E6%96%87gif%2F</url>
    <content type="text"><![CDATA[写在前面：在网页制作中，雪碧图也是前端攻城狮必须掌握的一项小技能。百度词条对雪碧图的解释是：CSS雪碧 即CSS Sprite，也有人叫它CSS精灵，是一种CSS图像合并技术，该方法是将小图标和背景图像合并到一张图片上，然后利用css的背景定位来显示需要显示的图片部分。本文主要内容包括雪碧图如何制作，雪碧图优缺点，哪些场景需要使用雪碧图。 实现原理：CSS雪碧的基本原理是把你的网站上用到的一些图片整合到一张单独的图片中，从而减少你的网站的HTTP请求数量。该图片使用CSS background和background-position属性渲染，这也就意味着你的标签变得更加复杂了，图片是在CSS中定义，而非img标签。 1.前期准备下载工具：css sprit（css精灵）长这样： 看图片就知道多好用！ 文件不到200k，相当轻便，这是百度云链接：http://pan.baidu.com/s/1nuOZDqT 也有mac版本的，这是链接：http://dl.pconline.com.cn/download/421423.html 2.使用方法下载，打开之后。1.首先要切一些图片，不会切的话，移步：《前端ps切图方法，图文详细》 2.打开雪碧图，选择图片。 3.添加完图片之后，会自动生成代码，需要排列一下图片： 可以看到排列图片的时候，下面的代码也会跟着刷新 注意：排列图片的时候要注意各个图片之间留点空隙，不然使用的时候，会相互覆盖。 3.保存图片以及雪碧图css代码保存雪碧图 生成的雪碧图：保存雪碧图-css代码（因为软件没有到导出css代码的功能，所以要自己新建一个txt文件，放在雪碧图旁边，以后打开txt就知道图片在雪碧图的位置。） gif操作： 如何在html中使用？慕课网雪碧图： 慕课网demo：http://www.imooc.com/code/1511。慕课网雪碧图教程：http://www.imooc.com/learn/93 3.雪碧图优劣势1.加快网页加载速度网页上面每一张图片，都要向浏览器请求下载图片，而浏览器接受的同时请求数是10个，一次能处理的请求数目是两个。 http发起请求，最耗时的是在三次握手，每次请求之前都要握手。所以在网页性能优化中，减少http请求的次数是相当重要的一点！（本来想写多一点，但有些知识点不太清楚，怕误人子弟就不再赘述了。） 当一个网页有几百张，几千张图片的时候加载起来简直了！而且对于不稳定的网络带宽，加载起来更是噩梦，所以把图片拼接为一张大图，从而加快加载速度，以及加速页面渲染 2.后期维护简单该工具可以直接通过选择图片进行图片的拼接，当然你也可以自己挪动里面的图片，自己去布局你的雪碧图，更换图片的时候也只要更改一下图片的位置就可以了。直接生成代码，简单易用 3、CSS Sprites能减少图片的字节，曾经比较过多次3张图片合并成1张图片的字节总是小于这3张图片的字节总和。 4、解决了网页设计师在图片命名上的困扰，只需对一张集合的图片上命名就可以了，不需要对每一个小元素进行命名，从而提高了网页的制作效率。 5、更换风格方便，只需要在一张或少张图片上修改图片的颜色或样式，整个网页的风格就可以改变。维护起来更加方便。 关于雪碧图的缺点内容：不要滥用雪碧图sprite里面说了蛮多的，这事情可以根据使用场景来决定，大家可以看看，毕竟我是来教雪碧图的。。。下面有关于雪碧图的demo。 之前写过两篇相关的：1.前端ps切图方法，图文详细2.ps切图实用小技巧、图片格式的区别及相关内容 以上，2017.4.10。 最后又到了观众朋友们最喜欢的求赞求关注环节：希望看完的朋友点个喜欢，也可以关注一下我，现在这阶段基本上每个月都不会少于十五篇文章（看到干货我也会进行分享）。码字不易，感谢支持，感激不尽！ps：目前待业，坐标北京，求推荐工作。然后希望我写哪方面的文章可以在底下评论，或者是私信我，虽然写的不好，但我就当这是记录自己成长的一种方式咯。（前提是我会了，如果不会我也会记下来，等会了的时候再更出来。）**掘金个人主页 ，简书主页链接，csdn博客主页链接 ，github 。]]></content>
      <categories>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>css sprite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端 PS 切图方法，图文详细]]></title>
    <url>%2F2017%2F10%2F11%2F%E5%89%8D%E7%AB%AF-PS-%E5%88%87%E5%9B%BE%E6%96%B9%E6%B3%95%EF%BC%8C%E5%9B%BE%E6%96%87%E8%AF%A6%E7%BB%86%2F</url>
    <content type="text"><![CDATA[写在前面：本文主要内容是目前我所知道的切图技巧结合网上的资料，写出来分享一波。图文教程，多图！！ BB：很多人都会说，切图这个活倒底分给UI还是分给前端。虽然好的UI会给我们把图切好，但是他们切的图不一定百分之百符合我们的需求，所以我一直都觉得这是页面仔必须要会的一项技能，因为只有你自己才会知道怎么切合适。况且这项技能根本一点都不难，所以还是自己动手丰衣足食比较好。 1.下载我现在使用的版本号：PS-CS6，网上很多破解版本的自行搜索下载。 2.安装好PS之后，先要调整工作区域的布局。1.选择“窗口”——把“信息”，“图层”，“历史记录”，“颜色”面板打开，其他的可以先关闭了，在切图的工作中其他的基本用不到，这个很简单的，打几个勾就可以了，如下图所示： 2.调整好面板之后，选择“窗口”——“工作区”——“新建工作区”，将当前的工作布局保存起来，并命个名，之后下次打开的时候就会直接出现你调整好的工作布局，否则的话你每次重新打开ps的时候都要重新设置。 ps：就算有别人弄乱了你的面板也可以直接通过“窗口”——“工作区”——选择你之前保存的工作布局。 3.切图切图需求： 切图步骤见图 选择图层的时候要先按住alt不放，然后再按鼠标右键。 隐藏图层。 效果： 连续操作隐藏图层(背景图要隐藏干净)：效果，以及接下的步骤（切线就是一根根淡蓝色的线） 保存切片1 保存切片2 保存切片3 被局限的方法（原理是一样的）： 踩坑经历：网上很多教程都说使用png格式就可以，却并没有说png-8或者是png-24，甚至有些教程告诉我使用png-8！在这里分享一波，保存切片必须使用png-24，因为我踩过坑了（/(ㄒoㄒ)/~~） 切出来的图片对比： 网页效果对比： 更新一波原理：之前不知道为什么png8，png24为什么有这种差别，经过评论区@唐挽斐 解答一波，现在明白了，更新到文章里面。 因为黄色图标这里是不透明的，png8不支持半透明的 搜了一下png8和png-24的区别：1、png8是一个256色的图片，png24则是一个1670万色的图片 2、png8的压缩率比png24高很多，所以png8图片的大小会比png24小很多。 3、png8的全透明没有png24的质量高。 4、png8在半透明和透明的情况下会有毛边锯齿的现象，png24则不会，如下图 @唐挽斐建议：必须保存png24，这个确实可以保证图片不会出错，但是对于大的不需要半透明的图片保存成 png24 的话导致文件体积会很大，所以建议不需要半透明的图片保存成 png8，这样体积会小一点而且不会影响图片清晰度，需要半透明的一定要保存成 png24。 感谢建议，之前有点不太理解，这回学习到了。 这是别人写的教程，跟我用的方法有些差别，有兴趣可以看看。http://blog.csdn.net/xiaoermingn/article/details/53240266 以上：2017.4.9。 后话： 本文的受众是前端小白们呢，只是帮助小白们，先学会切图能把图片切出来，能够使用就可以了，这些都是小技能学会用了就可以了，不打紧的。明天写一篇关于雪碧图的合成方法，以及关于切图的一些东西。 相关：1.css sprite雪碧图制作，使用以及相关，图文2.ps切图实用小技巧、图片格式的区别及相关内容 最后又到了观众朋友们最喜欢的求赞求关注环节：希望看完的朋友点个喜欢，也可以关注一下我，现在这阶段基本上每个月都不会少于十五篇文章（看到干货我也会进行分享）。码字不易，感谢支持，感激不尽！ps：如果希望我写哪方面的文章可以在底下评论，或者是私信我，虽然写的不好，但我就当这是记录自己成长的一种方式咯。（前提是我会了，如果不会我也会记下来，等会了的时候再更出来。）**掘金个人主页 ，简书主页链接，csdn博客主页链接 ，github 。]]></content>
      <categories>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>ps切图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[标签栏图标，随机背景图，压缩背景]]></title>
    <url>%2F2017%2F10%2F11%2F%E6%A0%87%E7%AD%BE%E6%A0%8F%E5%9B%BE%E6%A0%87%EF%BC%8C%E9%9A%8F%E6%9C%BA%E8%83%8C%E6%99%AF%E5%9B%BE%EF%BC%8C%E5%8E%8B%E7%BC%A9%E8%83%8C%E6%99%AF%2F</url>
    <content type="text"><![CDATA[写在前面：本文内容见标题，之前github个人主页每次看到地址栏旁边的小图标默认的样子，都觉得丑爆了，前几天终于抽空把这个改了，还有之前背景图片用了一个大壁纸的网址链接，每次读取背景的时候感觉要半天那么久，一直想着要弄个反应速度快的！然后我又找到一个好方法。 效果(文章最后有demo)： 地址栏的图标：问题描述很早之前就对别的网页有这种漂亮的小图标好喜欢，自己也决定弄一个怎样添加这样的图标呢，没有设置的话，默认是没有的。 其实，这个是通过favicon.ico来控制的。favicon.ico图标（图片大小有限制，下面有在线转换的网址）是网站的缩略标志，可以显示在浏览器标签、地址栏左边和收藏夹，是展示网站个性的缩略logo标志，也可以说是网站头像，如果要让网站看起来更专业、更美、更有个性，favicon.ico是必不可少的。 代码：1&lt;link rel=&quot;shortcut icon bookmark&quot; type=&quot;image/png&quot; href=&quot;compress-bg/ico4.ico&quot;&gt; 概念 ：rel：链接外部文件与此文件的关系。bookmark – 书签Shortcut Icon– 小图片 注意：这里的图片是要用专门格式的，这里是两个在线转换图片格式的网址：http://ico.storyren.com/http://www.bitbug.net/ 这里有两篇关于rel属性的详细介绍写的很多，有兴趣深究的可以看一下：1.http://www.jb51.net/web/25005.html2.http://paranimage.com/link-rel-attribute/ 随机背景图###问题描述：在github搭建了一个个人网站，（搭建方法）背景图片随机，载入速度过慢：之前我用的是这种方法1body&#123;background:url(&quot;https://unsplash.it/1600/900?random&quot;);&#125; 解读：这里是将背景图片跟一个高清壁纸的网址链接（这个高清图片网站还是不错的，推荐一波），随机倒是随机了，但每次读取背景的时候感觉要半天那么久（因为是分辨率比较高），但是这跟我的需求不一样，没工夫等那么久,so,有了下面的方法。 在网上查了两种方法，方法一： 博文链接：http://blog.csdn.net/ldl_xz/article/details/51532558 方法二（我目前用的）：原理就是通过js代码来动态的生成一个代表图片路径的 字符串 或者 html代码 在 标签中使用class: bg1&lt;body class=&quot;bg&quot;&gt;&lt;/body&gt; js代码：12345678910111213 &lt;script type=&quot;text/javascript&quot;&gt;//产生随机背景图片 var bodyBgs = [];//图片url的路径 for (var i = 1; i &lt; 62; i++) &#123;//注意图片数量 bodyBgs[i] = &quot;compress-bg/bg&quot;+i+&quot;.jpg&quot;;//动态改变i的数量，随机选择到图片 &#125;; var randomBgIndex = Math.round( Math.random() * 61 );//随机获取字符串标识，注意图片数量(这里随机数包括0，图片要从bg0开始到bg(n)） console.log(randomBgIndex); document.write(&apos;&lt;style&gt;.bg&#123;width:100%;background:url(&apos;); document.write(bodyBgs[randomBgIndex]); document.write(&apos;);background-size: cover;&#125;&lt;/style&gt;&apos;); //上面的三个字符串可以用“+”连接成一个字符串，这里因为位置原因我拆开写了。 &lt;/script&gt; 执行过程：1.通过循环生成一组图片路径的字符串。//重要的就是图片路径这块儿的理解。2.通过产生随机数，随机得到某张图片的路径字符串。3.动态生成包含 css代码 的 html代码 。4.通过浏览器查看网页的显示情况。（文末有 ） 注意事项：1.图片路径不要错！！！2.随机数是从0开始的，注意bg[n]，n是从0开始。3.要想背景载入速度够快的话，最好压缩压缩压缩（说三遍）一下图片 这里推荐一个在线压缩图片超好用的网站https://tinypng.com/# 这是米国的网站，最好翻墙一下，不然会出现这种情况（也可以下载破解版的软件，搜索tinypng就可以） 我翻译了一下页面 需要注册一下，然后一个月可以压缩500张，一般是够用的。 demo在最下面。 favicon.ico图标参考文章：http://blog.csdn.net/hsd2012/article/details/51782545随机生成背景图参考网址：http://www.tuicool.com/articles/y2miAby 2017.4.8，以上。 最后又到了观众朋友们最喜欢的求赞求关注环节：希望看完的朋友点个喜欢，也可以关注一下我，现在这阶段基本上每个月都不会少于十五篇文章（看到干货我也会进行分享）。码字不易，感谢支持，感激不尽！ps：如果希望我写哪方面的文章可以在底下评论，或者是私信我，虽然写的不好，但我就当这是记录自己成长的一种方式咯。（前提是我会了，如果不会我也会记下来，等会了的时候再更出来。）简书主页链接，csdn博客主页链接 github ， 掘金个人主页 说好的demo,demo地址123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot; name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, minimum-scale=0.5, maximum-scale=2.0, user-scalable=yes&quot;/&gt;&lt;link rel=&quot;icon shortcut bookmark&quot; type=&quot;image/png&quot; href=&quot;compress-bg/ico1.ico&quot;&gt;&lt;title&gt;简书demo&lt;/title&gt;&lt;base target=&quot;_blank&quot; /&gt;&lt;style type=&quot;text/css&quot;&gt;.bg&#123;margin: 0;&#125;.allBox&#123;width: 80%;margin: 0 auto;&#125;p&#123;display: inline-block!important;width: 50%;font-size: 2rem;float: left;&#125;a&#123;text-decoration: none;target= &quot;_Blank&quot;;color:#7e6b5a;&#125;h1&#123;color: #d1c0a5;text-align: center;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body class=&quot;bg&quot;&gt;&lt;div class=&quot;allBox&quot;&gt;&lt;h1&gt;这里是简书demo&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;js-time/time-countDown.html&quot;&gt;1.倒计时和获取时间的demo&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;//产生随机背景图片var bodyBgs = [];for (var i = 1; i &lt; 62; i++) &#123;//注意图片数量bodyBgs[i] = &quot;compress-bg/bg&quot;+i+&quot;.jpg&quot;;&#125;;var randomBgIndex = Math.round( Math.random() * 61 );//随机获取字符串标识，注意图片数量console.log(randomBgIndex);document.write(&apos;&lt;style&gt;.bg&#123;width:100%;background:url(&apos;);document.write(bodyBgs[randomBgIndex]);document.write(&apos;);background-size: cover;&#125;&lt;/style&gt;&apos;);//上面的三个字符串可以用“+”连接成一个字符串，这里因为位置原因我拆开写了。&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>网站随机背景</tag>
        <tag>标签栏favicon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解读viewport—网页自适应移动app神器]]></title>
    <url>%2F2017%2F10%2F11%2F%E8%A7%A3%E8%AF%BBviewport%E2%80%94%E7%BD%91%E9%A1%B5%E8%87%AA%E9%80%82%E5%BA%94%E7%A7%BB%E5%8A%A8app%E7%A5%9E%E5%99%A8%2F</url>
    <content type="text"><![CDATA[写在前面：viewport指的是是用户网页的可视区域，查了许久，遗憾的是近一两年几乎没有高质量的解析viewport的文章，本文内容是参考大牛，对内容进行了重新排版，以及对重点内容进行标注、精简，加上些许的个人理解形成的。有兴趣的朋友，可以参考一下。 一.背景介绍现在人通过手机浏览网页占了大多数，随着浏览方式的改变，网页在webapp下面实现多终端自适应，无论是对于避免工程师无谓的重复劳动或者是对于项目管理便捷性上来说都是十分重要的，然而在移动设备上进行网页的重构或开发，首先得搞明白的就是移动设备上的viewport了，只有明白了viewport的概念以及弄清楚了跟viewport有关的meta标签的使用，才能更好地让我们的网页适配或响应各种不同分辨率的移动设备。 二.知识剖析1.viewport的概念通俗的讲，移动设备上的viewport就是设备的屏幕上能用来显示我们的网页的那一块区域。 在具体一点，就是浏览器上(也可能是一个app中的webview)用来显示网页的那部分区域，但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域要大，也可能比浏览器的可视区域要小。 在默认情况下，一般来讲，移动设备上的viewport都是要大于浏览器可视区域的，这是因为考虑到移动设备的分辨率相对于桌面电脑来说都比较小，所以为了能在移动设备上正常显示那些传统的为桌面浏览器设计的网站。 移动设备上的浏览器都会把自己默认的viewport设为980px或1024px（也可能是其它值，这个是由设备自己决定的），但带来的后果就是浏览器会出现横向滚动条，因为浏览器可视区域的宽度是比这个默认的viewport的宽度要小的。下图列出了一些设备上浏览器的默认viewport的宽度。 2.移动设备哪些因素会引起css中px的变化？ 在css中我们一般使用px作为单位，在桌面浏览器中css的1个像素往往都是对应着电脑屏幕的1个物理像素。但实际情况却并非如此，css中的像素只是一个抽象的单位，在不同的设备或不同的环境中，css中的1px所代表的设备物理像素是不同的。 1）从iphone4开始，苹果公司便推出了所谓的Retina屏，分辨率提高了一倍，变成640x960，但屏幕尺寸却没变化，这就意味着同样大小的屏幕上，像素却多了一倍，这时，一个css像素是等于两个物理像素的（意思就是你分辨率越大，css中1px代表的物理像素就会越多）。 2)用户对设备界面的缩放，例如，当用户把页面放大一倍，那么css中1px所代表的物理像素也会增加一倍；反之把页面缩小一倍，css中1px所代表的物理像素也会减少一倍。 3.devicePixelRatio属性1)它的官方的定义为：设备物理像素和设备独立像素的比例，也就是1devicePixelRatio = 物理像素 / 独立像素。 理解：1.css中的px就可以看做是设备的独立像素，所以知道devicePixelRatio，我们可以知道该设备上一个css像素代表多少个物理像素。ps：兼容这块儿，笔者还没找到相应的数据支持。但是在日常应用中，基本上主流的手机，都支持。有兴趣的小伙伴可以研究一下。 举个栗子：在Retina屏的iphone上，devicePixelRatio的值为2，也就是说1个css像素相当于2个物理像素。 4.ideal viewport——完美适配移动设备的理想viewport。所谓的完美适配（通常意义下，攻城狮口中的自适应）指的是: 1)不需要用户缩放和横向滚动条就能正常的查看网站的所有内容； 2)显示的文字的大小是合适，比如一段14px大小的文字，不会因为在一个高密度像素的屏幕里显示得太小而无法看清，理想的情况是这段14px的文字无论是在何种密度屏幕，何种分辨率下，显示出来的大小都是差不多的。 ideal viewport并没有一个固定的尺寸，不同的设备拥有有不同的ideal viewport。所有的phone的ideal viewport宽度都是320px，无论它的屏幕宽度是320还是640，也就是说，在iphone屏幕宽度在640px以下中，css中的320px就代表iphone屏幕的宽度。 不同分辨率的安卓手机上，devicePixelRatio的值能正好填充全屏宽度： 三.常见问题。1）.在进行移动设备网站的开发时，如何控制ideal viewport呢？ 我们在开发移动设备的网站时，最常见的的一个动作就是把下面这个东西复制到我们的head标签中：1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt; 标签解读： 在安卓中还支持 target-densitydpi 这个私有属性，它表示目标设备的密度等级，作用是决定css中的1px代表多少物理像素 target-densitydpi： 值可以为一个数值或 high-dpi 、 medium-dpi、 low-dpi、 device-dpi 这几个字符串中的一个 注意：当 target-densitydpi=device-dpi 时， css中的1px会等于物理像素中的1px。 2）把当前的viewport宽度设置为 ideal viewport 的宽度。1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; 可以看到通过width=device-width，所有浏览器都能把当前的viewport宽度变成ideal viewport的宽度，但要注意的是，在iphone和ipad上，无论是竖屏还是横屏，宽度都是竖屏时ideal viewport的宽度。 上面这串代码还有另一种写法：1&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1&quot;&gt;` 四.扩展——关于meta viewport的更多知识。1.关于缩放缩放是相对于ideal viewport来缩放的，缩放值越大，当前viewport的宽度就会越小，反之亦然。举个栗子：在iphone中，ideal viewport的宽度是320px，如果我们设置 initial-scale=2 ，此时viewport的宽度会变为只有160px了 理解：就是原来1px的东西变成2px了，但是1px变为2px并不是把原来的320px变为640px了，而是在实际宽度不变的情况下，1px变得跟原来的2px的长度一样了，所以放大2倍后原来需要320px才能填满的宽度现在只需要160px就做到了。因此，我们可以得出一个公式：123visual viewport宽度 = ideal viewport宽度 / 当前缩放值当前缩放值 = ideal viewport宽度 / visual viewport宽度 ps: visual viewport的宽度指的是浏览器可视区域的宽度。ideal viewport宽度指的是完美适配移动设备的宽度 2.initial-scale的默认值是多少？initial-scale的默认值很显然不会是1，因为当 initial-scale = 1 时，当前的layout viewport宽度会被设为 ideal viewport的宽度，但前面说了，各浏览器默认的 layout viewport宽度一般都是980啊，1024啊，800啊等等这些个值，没有一开始就是 ideal viewport的宽度的。 ps：layout viewport在手机浏览器上面的默认值是980px。 安卓设备上的initial-scale默认值：如果没有设置的话，就没有，一定要设置，这个属性才会起作用。 iphone和ipad上的initial-scale默认值： 测试：在iphone上，我们不设置任何的viewport meta标签，此时layout viewport的宽度为980px，但我们可以看到浏览器并没有出现横向滚动条，浏览器默认的把页面缩小了。根据上面的公式，当前缩放值 = ideal viewport宽度 / visual viewport宽度，我们可以得出： 当前缩放值 = 320 / 980，也就是当前的initial-scale默认值是 0.33这样子。 结论：在iphone和ipad上，无论你给viewport设的宽的是多少，如果没有指定默认的缩放值，则iphone和ipad会自动计算这个缩放值，以达到当前页面不会出现横向滚动条(或者说viewport的宽度就是屏幕的宽度)的目的。 这里楼主有个踩坑经历：http://www.jianshu.com/p/232a4d9a90c9 3.js动态改变meta viewport标签第一种方法 可以使用document.write来动态输出meta viewport标签，例如：1document.write(&apos;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;&apos;) 第二种方法 js通过setAttribute来改变12345&lt;meta id=&quot;testViewport&quot; name=&quot;viewport&quot; content=&quot;width = 380&quot;&gt;&lt;script&gt;var mvp = document.getElementById(&apos;testViewport&apos;);mvp.setAttribute(&apos;content&apos;,&apos;width=480&apos;);&lt;/script&gt; 五.总结得到缩放值的公式：123当前缩放值 = ideal viewport宽度 / visual viewport宽度//visual viewport宽度指的是浏览器可视区域的宽度。//ideal viewport宽度指的是完美适配移动设备的宽度 如果表示不理解本文的内容，在head部分加上这串代码也可以解决网页自适应移动app的这个问题：1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt; 提示：如果不设置meta viewport标签，移动设备上浏览器默认的宽度值为800px，980px，1024px等这些，总之是大于屏幕宽度的（意思就是说，会不自适应手机端的页面） 还是刚才那个踩坑经历：http://www.jianshu.com/p/232a4d9a90c9（迷迷糊糊的太难受了） 本文大部分内容来自：http://www.cnblogs.com/2050/p/3877280.html本人重新排版，以及对重点内容进行标注，和精简。原文较为详细，细细阅读，理解更加深刻。 后话：确实，当我们在开发移动设备上的网页时，不管你明不明白什么是viewport，可能你只需要这么一句代码就够了。当有时候，我们要知其然，更要知其所以然，当你明白了其中的原理，对其使用就会更加得心应手，不会迷迷糊糊，连这串代码是什么意思都不知道。老大曾经说过一句话：当你达到一定高度的时候，你的理论知识才能决定你能走多远。共勉。 最后又到了观众朋友们最喜欢的求赞求关注环节：希望看完的朋友点个喜欢，也可以关注一下我，现在这阶段基本上每个月都不会少于十五篇文章（看到干货我也会进行分享）。码字不易，感谢支持，感激不尽！ps：如果希望我写哪方面的文章可以在底下评论，或者是私信我，虽然写的不好，但我就当这是记录自己成长的一种方式咯。（前提是我会了，如果不会我也会记下来，等会了的时候再更出来。）简书主页链接，csdn博客主页链接 github]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[倒计时跳转和获取实时时间]]></title>
    <url>%2F2017%2F10%2F11%2F%E5%80%92%E8%AE%A1%E6%97%B6%E8%B7%B3%E8%BD%AC%E5%92%8C%E8%8E%B7%E5%8F%96%E5%AE%9E%E6%97%B6%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[写在前面：本文内容如题，自己做的一个demo，倒计时和获取实时时间在许多场景都用的到，所以还算蛮实用的，需要的朋友可以做个参考。 效果图： 代码解析：html代码123456789101112&lt;body onload=&quot;startTime()&quot;&gt;&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;time&quot;&gt;请等待&lt;span id=&quot;dd&quot;&gt;6&lt;/span&gt;秒&lt;/div&gt; &lt;!--设置时间长一点，不然一直跳转很烦--&gt; ![](aaa.png) &lt;div class=&quot;id-box&quot;&gt; &lt;div id=&quot;time&quot;&gt;&lt;/div&gt; &lt;div id=&quot;date&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;p&gt;更多·更全·更好用&lt;/p&gt;&lt;/body&gt; js倒计时代码12345678910 function run()&#123; var s = document.getElementById(&quot;dd&quot;);//获取dom，并获得数字 if(s.innerHTML == 1)&#123;// 当dom==0的时候，跳转链接并且暂停函数 window.location.href = &quot;https://www.baidu.com/index.php?tn=98012088_3_dg&amp;ch=1&quot;; clearInterval(run());//暂停setInterval调用的run()函数 &#125; s.innerHTML = s.innerHTML -1;//跑一秒减一个数字 &#125; window.setInterval(&quot;run();&quot;, 1000);//调用时间函数， 一秒跑一次` 上面基本上每一行都有注释，所以我就为不知道的朋友写点定义和自己的理解，知道的朋友也可以加深点印象。innerHTML定义和用法：innerHTML 属性设置或返回表格行的开始和结束标签之间的 HTML。 作用意思就是删除原来的样式，插入html的文字之类的(w3c解释：http://www.w3school.com.cn/jsref/prop_tablerow_innerhtml.asp) setInterval定义和用法setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。(w3c解释：http://www.jb51.net/shouce/htmldom/jb51.net.htmldom/htmldom/met_win_setinterval.asp.html) clearInterval定义和用法clearInterval() 方法可取消由 setInterval() 设置的 timeout。（就是暂停的意思，这里是到了一秒就暂停住了，不再往下数了。） clearInterval() 方法的参数必须是由 setInterval() 返回的 ID 值。（这里的ID值是run()相当于获取这个dom。）(w3c解释：http://www.w3school.com.cn/jsref/met_win_clearinterval.asp) ps：还有不懂的可以把我的demo复制到本地，自己演示一下。 html代码在上面。获取实时时间js代码：123456789101112131415161718192021222324252627function checkTime(i)&#123; if (i&lt;10)&#123; i = &quot;0&quot; + i; // 当数值小于10的时候，在i前面加个0字符串。 &#125;return i; &#125; function startTime()&#123;//onload事件 var today = new Date(); var y = today.getFullYear(); var month = today.getMonth(); //获取当前时间。get。 var d = today.getDate(); var h = today.getHours(); var m = today.getMinutes(); var s = today.getSeconds(); // add a zero in front of numbers&lt;10 month =checkTime(month+1);//因为月份是0-11月份,+1是把区间定在1-12月份，毕竟没有0月份，笑。 d = checkTime(d); h =checkTime(h); m =checkTime(m); //将函数checkTime作用于时间变量，当变量小于10的时候将再变量前面加个字符串0 s =checkTime(s); document.getElementById(&quot;time&quot;).innerHTML = h+&quot;:&quot;+m+&quot;:&quot;+s;//将实时时间结合字符串写出来。 document.getElementById(&quot;date&quot;).innerHTML = y+&quot;/&quot;+month+&quot;/&quot;+d; t=setTimeout(&quot;startTime()&quot;,1000);// 每隔1000毫秒，再调用一下这个函数，刷新一下时间 &#125;` 这个比较简单，在w3c上面演化出来的。 w3cDate对象：http://www.w3school.com.cn/jsref/jsref_obj_date.asp checkTime(i)：这里主要是符合我们看时间的习惯，比如18点05分。这里的0就是这个函数的”0”字符串。 onload事件：页面加载之后立即执行一段 JavaScript： 核心思想就是：获取实时的时间，然后通过+操作符，把他们链接起来，并跟html关联，使其呈现出来。 其他的，在注释里面都介绍的很清楚了，不会的，自己写一个试试就知道了。 demo链接：https://obkoro1.github.io/article-demo/js-time/time-countDown.html 以上。 最后又到了观众朋友们最喜欢的求赞求关注环节：希望看完的朋友点个喜欢，想关注我这个菜鸡是如何成长的也可以关注一下我，基本上每个月都不会少于十五篇文章（看到干货我也会进行分享）。码字不易，感谢支持，感激不尽！ps：如果希望我写哪方面的文章可以在底下评论，或者是私信我，虽然写的不好，但我就当这是记录自己成长的一种方式咯。（前提是我会了，如果不会我也会记下来，等会了的时候再更出来。）简书主页链接，csdn博客主页链接]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js_demo</tag>
        <tag>倒计时</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shuffle()方法、removeAttribute() 方法、split()方法]]></title>
    <url>%2F2017%2F10%2F11%2Fshuffle-%E6%96%B9%E6%B3%95%E3%80%81removeAttribute-%E6%96%B9%E6%B3%95%E3%80%81split-%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[写在前面：内容包括demo代码，应用和定义，以及参考文献，本文主要内容是学习js期间学到的一些实用的零碎的js1知识，我都记下来了，需要的朋友可以过来参考下，前后可能没有太大的相关性。喜欢的可以点个赞，希望对大家有所帮助。Python shuffle()方法语法1shuffle (lst ) 参数lst – 这可能是一个列表或元组。作用：打乱一个有序数组，最高效的数组乱序方法应用：打乱输出后，从头输出可用来输出随机数字。 这里有篇文章介绍数组乱序效率http://www.jb51.net/article/56099.htm HTML DOM removeAttribute() 方法定义和用法 removeAttribute() 方法删除指定的属性（可用来清空设置的style属性） 语法element.removeAttribute(attributename)效果 demo(demo比较长，放在文末) audio.pause引用JQury导致不能正常播放(引用音频，不能调用JQ的函数，否则会导致音频无法播放。)问题描述：之前调用JQ的$，来获取dom，然后下面的pause就显示没有定义，因为这里调用了JQ，JQ里面没有封装pause，导致pause没有定义。正确的代码123456789//之前引入JQ，然后用$(&quot;music&quot;),会报错。因为pause没在JQ里面封装函数，不能调用JQ，所以要用getElementById(&quot;music&quot;);获取dom。var audio=document.getElementById(&quot;music&quot;);function runMusic() &#123;//这是一个点击事件 if (audio.paused)&#123; audio.play(); &#125;else &#123; audio.pause(); &#125;&#125; split()方法语法1string.split(separator,limit) 参数separator:可选。字符串或正则表达式，从该参数指定的地方分割 string Object。 limit:可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。 用法：split() 方法用于把一个字符串分割成字符串数组。提示： 如果把空字符串 (“”) 用作 separator，那么 stringObject 中的每个字符之间都会被分割。注意： split() 方法不改变原始字符串。demo12var a =&quot;1,2,3,4,5,6&quot;//这是一个字符串变量，里面包含&quot;1,2,3,4,5,6&quot;这个字符串。var B = a.split(&quot;,&quot;)//从逗号处分割成一个字符串，返回值是数组B=[1,2,3,4,5,6]; 后话：这次就先记这三个，还有一些没记，以后再记。（下面有removeAttribute() 方法的demo*） 最后又到了观众朋友们最喜欢的求赞求关注环节：希望看完的朋友点个喜欢，想关注我这个菜鸡是如何成长的也可以关注一下我，基本上每个月都不会少于十五篇文章（看到干货我也会进行分享）。码字不易，感谢支持，感激不尽！ps：如果希望我写哪方面的文章可以在底下评论，或者是私信我，虽然写的不好，但我就当这是记录自己成长的一种方式咯。（前提是我会了，如果不会我也会记下来，等会了的时候再更出来。）简书主页链接，csdn博客主页链接 removeAttribute() 方法,demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; Content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;javascript&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;body&#123;font-size:12px;&#125;#txt&#123; height:400px; width:600px; border:#333 solid 1px; padding:5px;&#125;p&#123; line-height:18px; text-indent:2em;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h2 id=&quot;con&quot;&gt;JavaScript课程&lt;/H2&gt; &lt;div id=&quot;txt&quot;&gt; &lt;h5&gt;JavaScript为网页添加动态效果并实现与用户交互的功能。&lt;/h5&gt; &lt;p&gt;1. JavaScript入门篇，让不懂JS的你，快速了解JS。&lt;/p&gt; &lt;p&gt;2. JavaScript进阶篇，让你掌握JS的基础语法、函数、数组、事件、内置对象、BOM浏览器、DOM操作。&lt;/p&gt; &lt;p&gt;3. 学完以上两门基础课后，在深入学习JavaScript的变量作用域、事件、对象、运动、cookie、正则表达式、ajax等课程。&lt;/p&gt; &lt;/div&gt; &lt;form&gt; &lt;!--当点击相应按钮，执行相应操作，为按钮添加相应事件--&gt; &lt;input type=&quot;button&quot; value=&quot;改变颜色&quot; onclick=&quot;color()&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;改变宽高&quot; onclick=&quot;widthHeight()&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;隐藏内容&quot; onclick=&quot;cantent()&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;显示内容&quot; onclick =&quot;block()&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;取消设置&quot; onclick=&quot;recover()&quot; &gt; &lt;/form&gt; &lt;script type=&quot;text/javascript&quot;&gt;//定义&quot;改变颜色&quot;的函数var cantent_box = document.getElementById(&quot;txt&quot;);function color()&#123; cantent_box.style.color = &quot;red&quot;; cantent_box.style.backgroundColor = &quot;blue&quot;;&#125;function widthHeight()&#123; cantent_box.style.width =&quot;100px&quot;; cantent_box.style.height =&quot;600px&quot;;&#125;function cantent()&#123; cantent_box.style.display =&quot;none&quot;;&#125;//定义&quot;改变宽高&quot;的函数//定义&quot;隐藏内容&quot;的函数function block()&#123; cantent_box.style.display = &quot;block&quot;;&#125;//定义&quot;显示内容&quot;的函数function recover() &#123;var open=confirm(&quot;是否取消设置&quot;); if(open==true) &#123; txt.removeAttribute(&quot;style&quot;); &#125;&#125;//定义&quot;取消设置&quot;的函数 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>shuffle</tag>
        <tag>removeAttribute</tag>
        <tag>split</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[indexOf和push（）获得不重复随机数组]]></title>
    <url>%2F2017%2F10%2F11%2FindexOf%E5%92%8Cpush%EF%BC%88%EF%BC%89%E8%8E%B7%E5%BE%97%E4%B8%8D%E9%87%8D%E5%A4%8D%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[写在前面：整体思路：先random()获取随机数，indexOf()排除相同的随机数，push()将不重复随机数添加到数组。其实一直想写这篇已经很久了，因为之前做的一个东西还不完善，有bug。所以一直拖到现在。今天中午趁机做了个总结，需要的小伙伴可以看看，做个参考。 之前本来是一个很low的去重方法:1先获得三个随机数，然后三个随机数分别互相比较，当出现相等的情况时，那个随机数再随机一次，然后返回那三个随机数。这个方法low在：每个数值都要比较一下，，数量少的时候，还可以写，数量多的时候，你一个个比一下试试看？ 下面是新想的方法：先上效果： 页面效果：每隔一秒换一下随机box和随机颜色，不间断运行。 （下面有链接） 获取随机box，以及添加到数组里面的js代码12345678910111213141516var num=[];//box的随机数组var box_dom = document.getElementsByClassName(&quot;icon&quot;);//获得盒子的domfunction whileRun()&#123; num=[];//继续运行的时候清空数组，不然box不会变。 while (num.length&lt;3)&#123; box_dom_num=Math.floor(Math.random()*9); console.log(box_dom_num); //随机的box赋值给box_dom_num. if (num.indexOf(box_dom_num)&lt;0)&#123;//随机选择的box看有没有在原先已经添加的数组里面，如果没有，就添加进去，如果有，重新运行函数。 num.push(box_dom_num);// 将随机选择到的box添加到数组里面去。 &#125; console.log(num); &#125; return num;// 跳出while循环再返回数组&#125; 分解步骤：random()获取随机数：1box_dom_num=Math.floor(Math.random()*9);//获取盒子的随机数,下标从0开始，随机数范围0~8； 上面这串代码的解释：盒子=随机获得0-1之间的数字*9然后进行下舍入获得的整数。关于随机数生成这里还不太懂的同学，http://www.jianshu.com/p/759546b24c5b 移步这里。 indexOf()排除相同的随机数首先需要知道的是indexOf()这个方法是什么，及其作用。 w3c定义和用法indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。 从这里看不出有什么跟获取随机数有什么关联的地方，但是下面的一句注释，就可以和随机数关联起来： 这是代码：123if (num.indexOf(box_dom_num)&lt;0)&#123;//随机选择的box看有没有在原先已经添加的数组里面，如果没有，就添加进去，如果有，重新运行函数。 num.push(box_dom_num);// 将随机选择到的box添加到数组里面去。 &#125; 解释：检索num这个数组里面，之前有没有出现box_bom_num。如果没有出现的话（就是不重复了）,那么 (num.indexOf(box_dom_num)就会&lt;0，然后执行下面的内容。 push()将不重复随机数添加到数组push()定义和用法：push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。1num.push(box_dom_num);// 将随机选择到的box添加到数组里面去。 解释：上面已经将box_dom_num去除重复随机数了，直接添加就可以。 然后：继续while循环，直到num.length&lt;3的时候，返回已经去完重复随机数的num数组。 链接放上来，可以自己看源码：https://obkoro1.github.io/jnshu/js-task/task1/js1.html 最后又到了观众朋友们最喜欢的求赞求关注环节：希望看完的朋友点个喜欢，想关注我这个菜鸡是如何成长的也可以关注一下我，基本上每个月都不会少于十五篇文章（看到干货我也会进行分享）。码字不易，感谢支持，感激不尽！ps：如果希望我写哪方面的文章可以在底下评论，或者是私信我，虽然写的不好，但我就当这是记录自己成长的一种方式咯。（前提是我会了，如果不会我也会记下来，等会了的时候再更出来。）简书主页链接，csdn博客主页链接]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>indexOf数组去重</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js函数常见的写法以及调用方法]]></title>
    <url>%2F2017%2F10%2F11%2Fjs%E5%87%BD%E6%95%B0%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%99%E6%B3%95%E4%BB%A5%E5%8F%8A%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[写在前面：本文详细的介绍了5种js函数常见的写法以及调用的方法，平时看别人代码的时候总是看到各种不同风格的js函数的写法。不明不白的，找了点资料，做了个总结，需要的小伙伴可以看看，做个参考。1.常规写法（最常见的那种）123456//函数的写法function run () &#123; alert(&apos;常规写法&apos;);//这里是你函数的内容 &#125; // 调用 run(); 2.匿名函数写法（可以想成给变量赋值一个函数）123456 // 匿名函数的写法var run = function()&#123; alert(&apos;这是一种声明函数的方式，左边是一个变量，右边是一个函数的表达式，意思就是把一个匿名的函数表达式赋值给了变量myfun，只是声明了一个变量指向了一个函数对象。&apos;);//这里是你函数的内容 &#125; // 调用 run(); 3.将方法作为一个对象123456789101112 // 作为对象方法，函数写法，这里创建了两个函数外面用&#123;&#125;包裹起来 var Test = &#123;run1:function()&#123; alert(&apos;这个必须放在一个对象内部，放在外边会出错！&apos;);//这里是你函数的内容&#125;,run2:function()&#123; alert(&apos;这个必须放在一个对象内部，放在外边会出错！&apos;);//这里是你函数的内容&#125;&#125;//调用Test.run1();//调用第1个函数Test.run2();//调用第2个函数 4.构造函数中给对象添加方法 javascript中的每个对象都有prototype属性，Javascript中对象的prototype属性的解释是：返回对象类型原型的引用。12345678// 给对象添加方法 var funName = function()&#123;&#125;; funName.prototype.way = function()&#123; alert(&apos;这是在funName函数上的原始对象上加了一个way方法，构造函数中用到&apos;); &#125; // 调用 var funname = new text();// 创建对象 funname.way();//调用对象属性 5.自执行函数js自执行函数查到了几种不同写法，放上来给大家看看123456//方法1：最前最后加括号(function()&#123;alert(1);&#125;());/*这是jslint推荐的写法，好处是，能提醒阅读代码的人，这段代码是一个整体。例如，在有语法高亮匹配功能的编辑器里，光标在第一个左括号后时，最后一个右括号也会高亮，看代码的人一眼就可以看到这个整体。 */ 123//方法2：function外面加括号(function()&#123;alert(1);&#125;)();//这种做法比方法1少了一个代码整体性的好处。 12345//方法3：function前面加运算符，常见的是!与void 。!function()&#123;alert(1);&#125;();void function()&#123;alert(2);&#125;();/*显然，加上“!”或“+”等运算符，写起来是最简单的。加上“void ”要敲五下键盘，但是听说有一个好处是，比加&quot;!&quot;少一次逻辑运算。----我只是听说，不明所以。*/ 以上。参考：1.http://www.jb51.net/article/31078.htm2.http://www.cnblogs.com/Imever/p/4777985.html最后又到了观众朋友们最喜欢的求赞求关注环节：希望看完的朋友点个喜欢，想关注我这个菜鸡是如何成长的也可以关注一下我，基本上每个月都不会少于十五篇文章（看到干货我也会进行分享）。然后github也互相加个star。码字不易，感谢支持，感激不尽！ps：如果希望我写哪方面的文章可以在底下评论，或者是私信我，虽然写的不好，但我就当这是记录自己成长的一种方式咯。（前提是我会了，如果不会我也会记下来，等会了的时候再更出来。）简书主页链接，csdn博客主页链接]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html不随放大缩小而变形——initial-scale]]></title>
    <url>%2F2017%2F10%2F11%2Fhtml%E4%B8%8D%E9%9A%8F%E6%94%BE%E5%A4%A7%E7%BC%A9%E5%B0%8F%E8%80%8C%E5%8F%98%E5%BD%A2%E2%80%94%E2%80%94initial-scale%2F</url>
    <content type="text"><![CDATA[写在前面：很惭愧我都在做jq了，关于手机端页面变形，直到今天早上才知道问题出在哪里？之前写了好多css页面用谷歌的F12查看手机端的页面，效果如下面的图，然后我一直以为我电脑的谷歌F12出问题了，直到今天在启宸师兄的帮助下才明白。下面进入正文：一直以为是谷歌F12出问题了，查了好多相关的资料还是没查到，然后今天回过头来修改之前页面的问题，然后看到head头部，就觉得可能是initial-scale出的问题，抱着死马当活马医的心态改了一下meta标签的内容。修改initial-scale之前页面的效果： 之前meta标签的用法(这是错的)：1&lt;meta charset=&quot;utf-8&quot; name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, minimum-scale=0.5, maximum-scale=2.0, user-scalable=yes&quot;/&gt; width=device-width ：表示宽度是设备屏幕的宽度initial-scale=1.0：表示初始的缩放比例minimum-scale=0.5：表示最小的缩放比例maximum-scale=2.0：表示最大的缩放比例user-scalable=yes：表示用户是否可以调整缩放比例 如果是想要一打开网页，自动以原始比例显示，并且不允许用户修改的话，则是：1&lt;meta charset=&quot;utf-8&quot; name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, minimum-scale=1, maximum-scale=1, user-scalable=no&quot;/&gt; ps：将比例都改为1,即可。修改initial-scale之后页面的效果： 后话：实际上我一直知道这个标签的意思，但没往这方面去想。这个坑，我纠结了好久，单纯的写出来分享一下，希望可以帮助到需要的朋友。 最后又到了观众朋友们最喜欢的求赞求关注环节：希望看完的朋友点个喜欢，想关注我这个菜鸡是如何成长的也可以关注一下我，基本上每个月都不会少于十五篇文章（看到干货我也会进行分享）。然后github也互相加个star。码字不易，感谢支持，感激不尽！ps：如果希望我写哪方面的文章可以在底下评论，或者是私信我，虽然写的不好，但我就当这是记录自己成长的一种方式咯。（前提是我会了，如果不会我也会记下来，等会了的时候再更出来。）简书主页链接，csdn博客主页链接]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纵向排列文字以及禁止文字选中]]></title>
    <url>%2F2017%2F10%2F11%2F%E7%BA%B5%E5%90%91%E6%8E%92%E5%88%97%E6%96%87%E5%AD%97%E4%BB%A5%E5%8F%8A%E7%A6%81%E6%AD%A2%E6%96%87%E5%AD%97%E9%80%89%E4%B8%AD-1%2F</url>
    <content type="text"><![CDATA[写在前面：内容包括demo代码，应用和定义，以及参考文献，本文主要内容是本人学习过程中遇到css的零碎知识点1（就是以前自己不知道的），我都记下来了，需要的朋友可以过来参考下，喜欢的可以点个赞，希望对大家有所帮助。 writing-mode: tb-rl; （纵向排列文字）应用： 说明：设置或检索对象的内容块固有的书写方向。西方语言一般都是 lr-tb 的书写方式，但是亚洲语言 lr-tb | tb-rl 的书写方式都有。作为IE的私有属性之一，IE5.5率先实现了 writing-mode ，后期被w3c采纳成标准属性；此属性效果不能被累加使用。例如，父对象的此属性值设为 tb-rl ，子对象再设置该属性将不起作用，仍应用父对象的设置。对应的脚本特性为writingMode。 demo代码： 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta charset=&quot;utf-8&quot; name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, minimum-scale=0.5, maximum-scale=2.0, user-scalable=yes&quot;/&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; &lt;title&gt;demo&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .verticle-mode &#123; writing-mode: tb-rl; -webkit-writing-mode: vertical-rl; writing-mode: vertical-rl; &#125; /* IE7比较弱，需要做点额外的动作 */ .verticle-mode &#123; *width: 120px; &#125; .verticle-mode h4, .verticle-mode p &#123; *display: inline; *writing-mode: tb-rl; &#125; .verticle-mode h4 &#123; *float:rightright; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;verticle-mode&quot;&gt; &lt;h4&gt;咏柳&lt;/h4&gt; &lt;p&gt;碧玉妆成一树高，&lt;br&gt;万条垂下绿丝绦。&lt;br&gt;不知细叶谁裁出，&lt;br&gt;二月春风似剪刀。&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 还有一种解决方法是设置div的宽度小一点，字会被挤下去，但是我个人不喜欢这种处理方式，觉得low。想要再深入了解的童鞋，可以点这边：张鑫旭大神的文章：改变CSS世界纵横规则的writing-mode属性，http://www.zhangxinxu.com/wordpress/2016/04/css-writing-mode/css3参考手册：http://www.css88.com/book/css/properties/writing-modes/writing-mode.htm user-select: none; （禁止文字选中）说明：设置或检索是否允许用户选中文本。 应用（点击按钮，点快的时候文字会被选中，很丑，）： 现象需求：html中可能有些地方不想让用户复制文字，或是用a标签做了个点击按钮，点快的时候文字会被选中，很丑，这个时候可以使用下面的方案禁止文字选中。 user-select取值：none：文本不能被选择text：可以选择文本all：当所有内容作为一个整体时可以被选择。如果双击或者在上下文上点击子元素，那么被选择的部分将是以该子元素向上回溯的最高祖先元素。element：可以选择文本，但选择范围受元素边界的约束（css3参考手册：http://www.css88.com/book/css/properties/user-interface/user-select.htm） 兼容：不同的浏览器设置的内容不一样，user-select不是一个W3C的标准，浏览器的支持不完成，需要对不同的浏览器进行调整。12345678910111213body&#123;-moz-user-select:none;/*火狐*/-webkit-user-select:none;/*webkit浏览器*/-ms-user-select:none;/*IE10*/-khtml-user-select:none;/*早期浏览器*/user-select:none;&#125; demo代码123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cmn-Hans&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot; /&gt;&lt;title&gt;user-select_CSS参考手册_web前端开发参考手册系列&lt;/title&gt;&lt;meta name=&quot;author&quot; content=&quot;Joy Du(飘零雾雨), dooyoe@gmail.com, www.doyoe.com&quot; /&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;&lt;style&gt;.test&#123;padding:10px;-webkit-user-select:none;-moz-user-select:none;-o-user-select:none;user-select:none;background:#eee;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;test&quot; onselectstart=&quot;return false;&quot; unselectable=&quot;on&quot;&gt;选择我试试，你会发现怎么也选择不到我，哈哈哈哈&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 注意：IE6-9不支持该属性，但支持使用标签属性 onselectstart=”return false;” 来达到 user-select:none 的效果；Safari和Chrome也支持该标签属性；直到Opera12.5仍然不支持该属性，但和IE6-9一样，也支持使用私有的标签属性 unselectable=”on” 来达到 user-select:none 的效果；unselectable 的另一个值是 off；除Chrome和Safari外，在其它浏览器中，如果将文本设置为 -ms-user-select:none;，则用户将无法在该文本块中开始选择文本。不过，如果用户在页面的其他区域开始选择文本，则用户仍然可以继续选择将文本设置为 -ms-user-select:none; 的区域文本；对应的脚本特性为userSelect。 参考文献：1.http://www.css88.com/book/css/properties/user-interface/user-select.htm2.http://www.cnblogs.com/codebook/p/5924073.html最后又到了观众朋友们最喜欢的求赞求关注环节：希望看完的朋友点个喜欢，想关注我这个菜鸡是如何成长的也可以关注一下我，基本上每个月都不会少于十五篇文章（看到干货我也会进行分享）。然后github也互相加个star。码字不易，感谢支持，感激不尽！]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内容滚动条和子div高度自适应]]></title>
    <url>%2F2017%2F10%2F11%2F%E5%86%85%E5%AE%B9%E6%BB%9A%E5%8A%A8%E6%9D%A1%E5%92%8C%E5%AD%90div%E9%AB%98%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94%2F</url>
    <content type="text"><![CDATA[写在前面：老套路有图有真相，这才叫做分享。本文内容是：一个div里面，两个子div高度自适应（平分父div的高度）和元素内容过多的时候，根据需求出现高度滚动条或者宽度滚动条。 先放最终效果（在下面会有demo代码。）： 实现这些效果要怎么做呢？咱一步一步来。 第一步： 先设置html结构：这里我已经搭好了。12345678910111213141516171819&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;box1&quot;&gt; &lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt; &lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt; &lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt; &lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt; &lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt; &lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt; &lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt; &lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt; &lt;!--&lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt;--&gt; &lt;!--&lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt;--&gt; &lt;!--&lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt;--&gt; &lt;!--&lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt;--&gt; &lt;/div&gt; &lt;div class=&quot;box2&quot;&gt; &lt;span&gt;填充填充&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 第二步然后开始写css样式了（我会把踩坑经历放上去，所以不要一步一步走，看效果）： 设置父元素box的样式：1234567.box&#123; margin: 0 auto; width: 40%; background: #ccc; height: 15rem; border: 5px solid red; /*为了区分各个box界限*/ &#125; 设置box1的样式：12345.box1&#123; min-height: 3rem; max-height: 13rem; background: coral; &#125; 现在界面是这样子的： 现在尝试把html解除注释： 然后浏览器里面变成这样了。。。 excuse me？？？说好的滚动条呢？说好的自适应呢？ 下面就到了关键的部分了（文章末尾有demo，不想看的话，可以自己试试。）： 在上面我们已经设置了最大高度和最小高度，因为box1空间不够所以溢出来了。 overflow属性大家去看下，http://www.w3school.com.cn/cssref/pr_pos_overflow.asp知道你们不会去看，所以我又放图片了。。。 所以对于这部分我们要隐藏起来。 加个overflow: hidden;变成。 大家也都注意到了overflow: scroll;这个属性，是的，我们加上去试试。 滚动条是出来了，但是X轴的滚动条是什么鬼？所以百度好久的答案，你们有福了！—————overflow-x: hidden; 然后我顺便查到上面的简写方式。原来用overflow-x: hidden;overflow-y: auto;这两行代码就可以做到！我刚才是这样子的12345678.box1&#123; min-height: 3rem; overflow: hidden; max-height: 13rem; background: coral; overflow: scroll; overflow-x: hidden; &#125; 最终的代码是这样的。1234567.box1&#123; min-height: 3rem; max-height: 13rem; background: coral; overflow-x: hidden; overflow-y: auto; &#125; 好了今天的内容就到这里了。。等等，好像有什么不对的地方？说好的div高度自适应呢？？额。。。关于这个问题，我只有一个取巧的办法。我先放两张图片： ps：这样就算是自适应了吧？ 现在的情况是这样子的： 我把他们两个的背景颜色都改成一样的，再来看下： 这里也是，实际上，他的box就那么大。 写这篇花了一个半小时，主要是自己昨天才弄懂的，然后今天做demo 的时候又忘记怎么自适应div了，弄了老半天，然后用F12看昨天的代码才恍然大悟！（其实昨天没真懂，这会是真懂了），写的是真的累，码字不易，望且看且珍惜，给个喜欢吧。 最后又到了观众朋友们最喜欢的求赞求关注环节：希望看完的朋友点个喜欢，想关注我这个菜鸡是如何成长的也可以关注一下我，基本上每个月都不会少于十五篇文章（看到干货我也会进行分享）。然后github也互相加个star。码字不易，感谢支持，感激不尽！ 说好的demo，差点忘记，回来更新。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;div-height-roll-demo&lt;/title&gt; &lt;style&gt; .box&#123; margin: 0 auto; width: 40%; background: #ccc; height: 25rem; border: 5px solid red; /*为了区分各个box界限*/ &#125; .box1&#123; min-height: 3rem; max-height: 13rem; background: coral; overflow-x: hidden; overflow-y: auto; &#125; .box2&#123; text-align: center; border-top: 3px solid black; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;box1&quot;&gt; &lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt; &lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt; &lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt; &lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt; &lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt; &lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt; &lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt; &lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt; &lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt; &lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt; &lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt; &lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt; &lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt; &lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt; &lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt; &lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt; &lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt; &lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt; &lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt; &lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt; &lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt; &lt;span&gt;填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充填充&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;box2&quot;&gt; &lt;span&gt;填充填充&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
</search>
